// File:src/Three.js
/**
 * @author mrdoob / http://mrdoob.com/
 */
var THREE = {
    REVISION: "74"
};
//
"function" == typeof define && define.amd ? define("three", THREE) : "undefined" != typeof exports && "undefined" != typeof module && (module.exports = THREE),
    //
    void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)),
    //
    void 0 === Math.sign && (
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign
        Math.sign = function(a) {
            return 0 > a ? -1 : a > 0 ? 1 : +a
        }), void 0 === Function.prototype.name && void 0 !== Object.defineProperty &&
    // Missing in IE9-11.
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name
    Object.defineProperty(Function.prototype, "name", {
        get: function() {
            return this.toString().match(/^\s*function\s*(\S*)\s*\(/)[1]
        }
    }), void 0 === Object.assign &&
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
    Object.defineProperty(Object, "assign", {
        writable: !0,
        configurable: !0,
        value: function(a) {
            "use strict";
            if (void 0 === a || null === a) throw new TypeError("Cannot convert first argument to object");
            for (var b = Object(a), c = 1, d = arguments.length; c !== d; ++c) {
                var e = arguments[c];
                if (void 0 !== e && null !== e) {
                    e = Object(e);
                    for (var f = Object.keys(e), g = 0, h = f.length; g !== h; ++g) {
                        var i = f[g],
                            j = Object.getOwnPropertyDescriptor(e, i);
                        void 0 !== j && j.enumerable && (b[i] = e[i])
                    }
                }
            }
            return b
        }
    }),
    // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button
    THREE.MOUSE = {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2
    },
    // GL STATE CONSTANTS
    THREE.CullFaceNone = 0, THREE.CullFaceBack = 1, THREE.CullFaceFront = 2, THREE.CullFaceFrontBack = 3, THREE.FrontFaceDirectionCW = 0, THREE.FrontFaceDirectionCCW = 1,
    // SHADOWING TYPES
    THREE.BasicShadowMap = 0, THREE.PCFShadowMap = 1, THREE.PCFSoftShadowMap = 2,
    // MATERIAL CONSTANTS
    // side
    THREE.FrontSide = 0, THREE.BackSide = 1, THREE.DoubleSide = 2,
    // shading
    THREE.FlatShading = 1, THREE.SmoothShading = 2,
    // colors
    THREE.NoColors = 0, THREE.FaceColors = 1, THREE.VertexColors = 2,
    // blending modes
    THREE.NoBlending = 0, THREE.NormalBlending = 1, THREE.AdditiveBlending = 2, THREE.SubtractiveBlending = 3, THREE.MultiplyBlending = 4, THREE.CustomBlending = 5,
    // custom blending equations
    // (numbers start from 100 not to clash with other
    // mappings to OpenGL constants defined in Texture.js)
    THREE.AddEquation = 100, THREE.SubtractEquation = 101, THREE.ReverseSubtractEquation = 102, THREE.MinEquation = 103, THREE.MaxEquation = 104,
    // custom blending destination factors
    THREE.ZeroFactor = 200, THREE.OneFactor = 201, THREE.SrcColorFactor = 202, THREE.OneMinusSrcColorFactor = 203, THREE.SrcAlphaFactor = 204, THREE.OneMinusSrcAlphaFactor = 205, THREE.DstAlphaFactor = 206, THREE.OneMinusDstAlphaFactor = 207,
    // custom blending source factors
    //THREE.ZeroFactor = 200;
    //THREE.OneFactor = 201;
    //THREE.SrcAlphaFactor = 204;
    //THREE.OneMinusSrcAlphaFactor = 205;
    //THREE.DstAlphaFactor = 206;
    //THREE.OneMinusDstAlphaFactor = 207;
    THREE.DstColorFactor = 208, THREE.OneMinusDstColorFactor = 209, THREE.SrcAlphaSaturateFactor = 210,
    // depth modes
    THREE.NeverDepth = 0, THREE.AlwaysDepth = 1, THREE.LessDepth = 2, THREE.LessEqualDepth = 3, THREE.EqualDepth = 4, THREE.GreaterEqualDepth = 5, THREE.GreaterDepth = 6, THREE.NotEqualDepth = 7,
    // TEXTURE CONSTANTS
    THREE.MultiplyOperation = 0, THREE.MixOperation = 1, THREE.AddOperation = 2,
    // Mapping modes
    THREE.UVMapping = 300, THREE.CubeReflectionMapping = 301, THREE.CubeRefractionMapping = 302, THREE.EquirectangularReflectionMapping = 303, THREE.EquirectangularRefractionMapping = 304, THREE.SphericalReflectionMapping = 305,
    // Wrapping modes
    THREE.RepeatWrapping = 1e3, THREE.ClampToEdgeWrapping = 1001, THREE.MirroredRepeatWrapping = 1002,
    // Filters
    THREE.NearestFilter = 1003, THREE.NearestMipMapNearestFilter = 1004, THREE.NearestMipMapLinearFilter = 1005, THREE.LinearFilter = 1006, THREE.LinearMipMapNearestFilter = 1007, THREE.LinearMipMapLinearFilter = 1008,
    // Data types
    THREE.UnsignedByteType = 1009, THREE.ByteType = 1010, THREE.ShortType = 1011, THREE.UnsignedShortType = 1012, THREE.IntType = 1013, THREE.UnsignedIntType = 1014, THREE.FloatType = 1015, THREE.HalfFloatType = 1025,
    // Pixel types
    //THREE.UnsignedByteType = 1009;
    THREE.UnsignedShort4444Type = 1016, THREE.UnsignedShort5551Type = 1017, THREE.UnsignedShort565Type = 1018,
    // Pixel formats
    THREE.AlphaFormat = 1019, THREE.RGBFormat = 1020, THREE.RGBAFormat = 1021, THREE.LuminanceFormat = 1022, THREE.LuminanceAlphaFormat = 1023,
    // THREE.RGBEFormat handled as THREE.RGBAFormat in shaders
    THREE.RGBEFormat = THREE.RGBAFormat, //1024;
    // DDS / ST3C Compressed texture formats
    THREE.RGB_S3TC_DXT1_Format = 2001, THREE.RGBA_S3TC_DXT1_Format = 2002, THREE.RGBA_S3TC_DXT3_Format = 2003, THREE.RGBA_S3TC_DXT5_Format = 2004,
    // PVRTC compressed texture formats
    THREE.RGB_PVRTC_4BPPV1_Format = 2100, THREE.RGB_PVRTC_2BPPV1_Format = 2101, THREE.RGBA_PVRTC_4BPPV1_Format = 2102, THREE.RGBA_PVRTC_2BPPV1_Format = 2103,
    // ETC compressed texture formats
    THREE.RGB_ETC1_Format = 2151,
    // Loop styles for AnimationAction
    THREE.LoopOnce = 2200, THREE.LoopRepeat = 2201, THREE.LoopPingPong = 2202,
    // Interpolation
    THREE.InterpolateDiscrete = 2300, THREE.InterpolateLinear = 2301, THREE.InterpolateSmooth = 2302,
    // Interpolant ending modes
    THREE.ZeroCurvatureEnding = 2400, THREE.ZeroSlopeEnding = 2401, THREE.WrapAroundEnding = 2402,
    // Triangle Draw modes
    THREE.TrianglesDrawMode = 0, THREE.TriangleStripDrawMode = 1, THREE.TriangleFanDrawMode = 2,
    // File:src/math/Color.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.Color = function(a) {
        return 3 === arguments.length ? this.fromArray(arguments) : this.set(a)
    }, THREE.Color.prototype = {
        constructor: THREE.Color,
        r: 1,
        g: 1,
        b: 1,
        set: function(a) {
            return a instanceof THREE.Color ? this.copy(a) : "number" == typeof a ? this.setHex(a) : "string" == typeof a && this.setStyle(a), this
        },
        setScalar: function(a) {
            this.r = a, this.g = a, this.b = a
        },
        setHex: function(a) {
            return a = Math.floor(a), this.r = (a >> 16 & 255) / 255, this.g = (a >> 8 & 255) / 255, this.b = (255 & a) / 255, this
        },
        setRGB: function(a, b, c) {
            return this.r = a, this.g = b, this.b = c, this
        },
        setHSL: function() {
            function a(a, b, c) {
                return 0 > c && (c += 1), c > 1 && (c -= 1), 1 / 6 > c ? a + 6 * (b - a) * c : .5 > c ? b : 2 / 3 > c ? a + 6 * (b - a) * (2 / 3 - c) : a
            }
            return function(b, c, d) {
                if (b = THREE.Math.euclideanModulo(b, 1), c = THREE.Math.clamp(c, 0, 1), d = THREE.Math.clamp(d, 0, 1), 0 === c) this.r = this.g = this.b = d;
                else {
                    var e = .5 >= d ? d * (1 + c) : d + c - d * c,
                        f = 2 * d - e;
                    this.r = a(f, e, b + 1 / 3), this.g = a(f, e, b), this.b = a(f, e, b - 1 / 3)
                }
                return this
            }
        }(),
        setStyle: function(a) {
            function b(b) {
                void 0 !== b && parseFloat(b) < 1 && console.warn("THREE.Color: Alpha component of " + a + " will be ignored.")
            }
            var c;
            if (c = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(a)) {
                // rgb / hsl
                var d, e = c[1],
                    f = c[2];
                switch (e) {
                    case "rgb":
                    case "rgba":
                        if (d = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(f))
                        // rgb(255,0,0) rgba(255,0,0,0.5)
                            return this.r = Math.min(255, parseInt(d[1], 10)) / 255, this.g = Math.min(255, parseInt(d[2], 10)) / 255, this.b = Math.min(255, parseInt(d[3], 10)) / 255, b(d[5]), this;
                        if (d = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(f))
                        // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
                            return this.r = Math.min(100, parseInt(d[1], 10)) / 100, this.g = Math.min(100, parseInt(d[2], 10)) / 100, this.b = Math.min(100, parseInt(d[3], 10)) / 100, b(d[5]), this;
                        break;
                    case "hsl":
                    case "hsla":
                        if (d = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(f)) {
                            // hsl(120,50%,50%) hsla(120,50%,50%,0.5)
                            var g = parseFloat(d[1]) / 360,
                                h = parseInt(d[2], 10) / 100,
                                i = parseInt(d[3], 10) / 100;
                            return b(d[5]), this.setHSL(g, h, i)
                        }
                }
            } else if (c = /^\#([A-Fa-f0-9]+)$/.exec(a)) {
                // hex color
                var j = c[1],
                    k = j.length;
                if (3 === k)
                // #ff0
                    return this.r = parseInt(j.charAt(0) + j.charAt(0), 16) / 255, this.g = parseInt(j.charAt(1) + j.charAt(1), 16) / 255, this.b = parseInt(j.charAt(2) + j.charAt(2), 16) / 255, this;
                if (6 === k)
                // #ff0000
                    return this.r = parseInt(j.charAt(0) + j.charAt(1), 16) / 255, this.g = parseInt(j.charAt(2) + j.charAt(3), 16) / 255, this.b = parseInt(j.charAt(4) + j.charAt(5), 16) / 255, this
            }
            if (a && a.length > 0) {
                // color keywords
                var j = THREE.ColorKeywords[a];
                void 0 !== j ?
                    // red
                    this.setHex(j) :
                    // unknown color
                    console.warn("THREE.Color: Unknown color " + a)
            }
            return this
        },
        clone: function() {
            return new this.constructor(this.r, this.g, this.b)
        },
        copy: function(a) {
            return this.r = a.r, this.g = a.g, this.b = a.b, this
        },
        copyGammaToLinear: function(a, b) {
            return void 0 === b && (b = 2), this.r = Math.pow(a.r, b), this.g = Math.pow(a.g, b), this.b = Math.pow(a.b, b), this
        },
        copyLinearToGamma: function(a, b) {
            void 0 === b && (b = 2);
            var c = b > 0 ? 1 / b : 1;
            return this.r = Math.pow(a.r, c), this.g = Math.pow(a.g, c), this.b = Math.pow(a.b, c), this
        },
        convertGammaToLinear: function() {
            var a = this.r,
                b = this.g,
                c = this.b;
            return this.r = a * a, this.g = b * b, this.b = c * c, this
        },
        convertLinearToGamma: function() {
            return this.r = Math.sqrt(this.r), this.g = Math.sqrt(this.g), this.b = Math.sqrt(this.b), this
        },
        getHex: function() {
            return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
        },
        getHexString: function() {
            return ("000000" + this.getHex().toString(16)).slice(-6)
        },
        getHSL: function(a) {
            // h,s,l ranges are in 0.0 - 1.0
            var b, c, d = a || {
                    h: 0,
                    s: 0,
                    l: 0
                },
                e = this.r,
                f = this.g,
                g = this.b,
                h = Math.max(e, f, g),
                i = Math.min(e, f, g),
                j = (i + h) / 2;
            if (i === h) b = 0, c = 0;
            else {
                var k = h - i;
                switch (c = .5 >= j ? k / (h + i) : k / (2 - h - i), h) {
                    case e:
                        b = (f - g) / k + (g > f ? 6 : 0);
                        break;
                    case f:
                        b = (g - e) / k + 2;
                        break;
                    case g:
                        b = (e - f) / k + 4
                }
                b /= 6
            }
            return d.h = b, d.s = c, d.l = j, d
        },
        getStyle: function() {
            return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
        },
        offsetHSL: function(a, b, c) {
            var d = this.getHSL();
            return d.h += a, d.s += b, d.l += c, this.setHSL(d.h, d.s, d.l), this
        },
        add: function(a) {
            return this.r += a.r, this.g += a.g, this.b += a.b, this
        },
        addColors: function(a, b) {
            return this.r = a.r + b.r, this.g = a.g + b.g, this.b = a.b + b.b, this
        },
        addScalar: function(a) {
            return this.r += a, this.g += a, this.b += a, this
        },
        multiply: function(a) {
            return this.r *= a.r, this.g *= a.g, this.b *= a.b, this
        },
        multiplyScalar: function(a) {
            return this.r *= a, this.g *= a, this.b *= a, this
        },
        lerp: function(a, b) {
            return this.r += (a.r - this.r) * b, this.g += (a.g - this.g) * b, this.b += (a.b - this.b) * b, this
        },
        equals: function(a) {
            return a.r === this.r && a.g === this.g && a.b === this.b
        },
        fromArray: function(a, b) {
            return void 0 === b && (b = 0), this.r = a[b], this.g = a[b + 1], this.b = a[b + 2], this
        },
        toArray: function(a, b) {
            return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this.r, a[b + 1] = this.g, a[b + 2] = this.b, a
        }
    }, THREE.ColorKeywords = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    },
    // File:src/math/Quaternion.js
    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author WestLangley / http://github.com/WestLangley
     * @author bhouston / http://clara.io
     */
    THREE.Quaternion = function(a, b, c, d) {
        this._x = a || 0, this._y = b || 0, this._z = c || 0, this._w = void 0 !== d ? d : 1
    }, THREE.Quaternion.prototype = {
        constructor: THREE.Quaternion,
        get x() {
            return this._x
        },
        set x(a) {
            this._x = a, this.onChangeCallback()
        },
        get y() {
            return this._y
        },
        set y(a) {
            this._y = a, this.onChangeCallback()
        },
        get z() {
            return this._z
        },
        set z(a) {
            this._z = a, this.onChangeCallback()
        },
        get w() {
            return this._w
        },
        set w(a) {
            this._w = a, this.onChangeCallback()
        },
        set: function(a, b, c, d) {
            return this._x = a, this._y = b, this._z = c, this._w = d, this.onChangeCallback(), this
        },
        clone: function() {
            return new this.constructor(this._x, this._y, this._z, this._w)
        },
        copy: function(a) {
            return this._x = a.x, this._y = a.y, this._z = a.z, this._w = a.w, this.onChangeCallback(), this
        },
        setFromEuler: function(a, b) {
            if (a instanceof THREE.Euler == !1) throw new Error("THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            // http://www.mathworks.com/matlabcentral/fileexchange/
            // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
            //	content/SpinCalc.m
            var c = Math.cos(a._x / 2),
                d = Math.cos(a._y / 2),
                e = Math.cos(a._z / 2),
                f = Math.sin(a._x / 2),
                g = Math.sin(a._y / 2),
                h = Math.sin(a._z / 2),
                i = a.order;
            return "XYZ" === i ? (this._x = f * d * e + c * g * h, this._y = c * g * e - f * d * h, this._z = c * d * h + f * g * e, this._w = c * d * e - f * g * h) : "YXZ" === i ? (this._x = f * d * e + c * g * h, this._y = c * g * e - f * d * h, this._z = c * d * h - f * g * e, this._w = c * d * e + f * g * h) : "ZXY" === i ? (this._x = f * d * e - c * g * h, this._y = c * g * e + f * d * h, this._z = c * d * h + f * g * e, this._w = c * d * e - f * g * h) : "ZYX" === i ? (this._x = f * d * e - c * g * h, this._y = c * g * e + f * d * h, this._z = c * d * h - f * g * e, this._w = c * d * e + f * g * h) : "YZX" === i ? (this._x = f * d * e + c * g * h, this._y = c * g * e + f * d * h, this._z = c * d * h - f * g * e, this._w = c * d * e - f * g * h) : "XZY" === i && (this._x = f * d * e - c * g * h, this._y = c * g * e - f * d * h, this._z = c * d * h + f * g * e, this._w = c * d * e + f * g * h), b !== !1 && this.onChangeCallback(), this
        },
        setFromAxisAngle: function(a, b) {
            // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
            // assumes axis is normalized
            var c = b / 2,
                d = Math.sin(c);
            return this._x = a.x * d, this._y = a.y * d, this._z = a.z * d, this._w = Math.cos(c), this.onChangeCallback(), this
        },
        setFromRotationMatrix: function(a) {
            // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
            // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
            var b, c = a.elements,
                d = c[0],
                e = c[4],
                f = c[8],
                g = c[1],
                h = c[5],
                i = c[9],
                j = c[2],
                k = c[6],
                l = c[10],
                m = d + h + l;
            return m > 0 ? (b = .5 / Math.sqrt(m + 1), this._w = .25 / b, this._x = (k - i) * b, this._y = (f - j) * b, this._z = (g - e) * b) : d > h && d > l ? (b = 2 * Math.sqrt(1 + d - h - l), this._w = (k - i) / b, this._x = .25 * b, this._y = (e + g) / b, this._z = (f + j) / b) : h > l ? (b = 2 * Math.sqrt(1 + h - d - l), this._w = (f - j) / b, this._x = (e + g) / b, this._y = .25 * b, this._z = (i + k) / b) : (b = 2 * Math.sqrt(1 + l - d - h), this._w = (g - e) / b, this._x = (f + j) / b, this._y = (i + k) / b, this._z = .25 * b), this.onChangeCallback(), this
        },
        setFromUnitVectors: function() {
            // http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final
            // assumes direction vectors vFrom and vTo are normalized
            var a, b, c = 1e-6;
            return function(d, e) {
                return void 0 === a && (a = new THREE.Vector3), b = d.dot(e) + 1, c > b ? (b = 0, Math.abs(d.x) > Math.abs(d.z) ? a.set(-d.y, d.x, 0) : a.set(0, -d.z, d.y)) : a.crossVectors(d, e), this._x = a.x, this._y = a.y, this._z = a.z, this._w = b, this.normalize(), this
            }
        }(),
        inverse: function() {
            return this.conjugate().normalize(), this
        },
        conjugate: function() {
            return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this
        },
        dot: function(a) {
            return this._x * a._x + this._y * a._y + this._z * a._z + this._w * a._w
        },
        lengthSq: function() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        },
        length: function() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        },
        normalize: function() {
            var a = this.length();
            return 0 === a ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (a = 1 / a, this._x = this._x * a, this._y = this._y * a, this._z = this._z * a, this._w = this._w * a), this.onChangeCallback(), this
        },
        multiply: function(a, b) {
            return void 0 !== b ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(a, b)) : this.multiplyQuaternions(this, a)
        },
        multiplyQuaternions: function(a, b) {
            // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
            var c = a._x,
                d = a._y,
                e = a._z,
                f = a._w,
                g = b._x,
                h = b._y,
                i = b._z,
                j = b._w;
            return this._x = c * j + f * g + d * i - e * h, this._y = d * j + f * h + e * g - c * i, this._z = e * j + f * i + c * h - d * g, this._w = f * j - c * g - d * h - e * i, this.onChangeCallback(), this
        },
        slerp: function(a, b) {
            if (0 === b) return this;
            if (1 === b) return this.copy(a);
            var c = this._x,
                d = this._y,
                e = this._z,
                f = this._w,
                g = f * a._w + c * a._x + d * a._y + e * a._z;
            if (0 > g ? (this._w = -a._w, this._x = -a._x, this._y = -a._y, this._z = -a._z, g = -g) : this.copy(a), g >= 1) return this._w = f, this._x = c, this._y = d, this._z = e, this;
            var h = Math.sqrt(1 - g * g);
            if (Math.abs(h) < .001) return this._w = .5 * (f + this._w), this._x = .5 * (c + this._x), this._y = .5 * (d + this._y), this._z = .5 * (e + this._z), this;
            var i = Math.atan2(h, g),
                j = Math.sin((1 - b) * i) / h,
                k = Math.sin(b * i) / h;
            return this._w = f * j + this._w * k, this._x = c * j + this._x * k, this._y = d * j + this._y * k, this._z = e * j + this._z * k, this.onChangeCallback(), this
        },
        equals: function(a) {
            return a._x === this._x && a._y === this._y && a._z === this._z && a._w === this._w
        },
        fromArray: function(a, b) {
            return void 0 === b && (b = 0), this._x = a[b], this._y = a[b + 1], this._z = a[b + 2], this._w = a[b + 3], this.onChangeCallback(), this
        },
        toArray: function(a, b) {
            return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this._x, a[b + 1] = this._y, a[b + 2] = this._z, a[b + 3] = this._w, a
        },
        onChange: function(a) {
            return this.onChangeCallback = a, this
        },
        onChangeCallback: function() {}
    }, Object.assign(THREE.Quaternion, {
        slerp: function(a, b, c, d) {
            return c.copy(a).slerp(b, d)
        },
        slerpFlat: function(a, b, c, d, e, f, g) {
            // fuzz-free, array-based Quaternion SLERP operation
            var h = c[d + 0],
                i = c[d + 1],
                j = c[d + 2],
                k = c[d + 3],
                l = e[f + 0],
                m = e[f + 1],
                n = e[f + 2],
                o = e[f + 3];
            if (k !== o || h !== l || i !== m || j !== n) {
                var p = 1 - g,
                    q = h * l + i * m + j * n + k * o,
                    r = q >= 0 ? 1 : -1,
                    s = 1 - q * q;
                // Skip the Slerp for tiny steps to avoid numeric problems:
                if (s > Number.EPSILON) {
                    var t = Math.sqrt(s),
                        u = Math.atan2(t, q * r);
                    p = Math.sin(p * u) / t, g = Math.sin(g * u) / t
                }
                var v = g * r;
                // Normalize in case we just did a lerp:
                if (h = h * p + l * v, i = i * p + m * v, j = j * p + n * v, k = k * p + o * v, p === 1 - g) {
                    var w = 1 / Math.sqrt(h * h + i * i + j * j + k * k);
                    h *= w, i *= w, j *= w, k *= w
                }
            }
            a[b] = h, a[b + 1] = i, a[b + 2] = j, a[b + 3] = k
        }
    }),
    // File:src/math/Vector2.js
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author philogb / http://blog.thejit.org/
     * @author egraether / http://egraether.com/
     * @author zz85 / http://www.lab4games.net/zz85/blog
     */
    THREE.Vector2 = function(a, b) {
        this.x = a || 0, this.y = b || 0
    }, THREE.Vector2.prototype = {
        constructor: THREE.Vector2,
        get width() {
            return this.x
        },
        set width(a) {
            this.x = a
        },
        get height() {
            return this.y
        },
        set height(a) {
            this.y = a
        },
        //
        set: function(a, b) {
            return this.x = a, this.y = b, this
        },
        setScalar: function(a) {
            return this.x = a, this.y = a, this
        },
        setX: function(a) {
            return this.x = a, this
        },
        setY: function(a) {
            return this.y = a, this
        },
        setComponent: function(a, b) {
            switch (a) {
                case 0:
                    this.x = b;
                    break;
                case 1:
                    this.y = b;
                    break;
                default:
                    throw new Error("index is out of range: " + a)
            }
        },
        getComponent: function(a) {
            switch (a) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error("index is out of range: " + a)
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y)
        },
        copy: function(a) {
            return this.x = a.x, this.y = a.y, this
        },
        add: function(a, b) {
            return void 0 !== b ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b)) : (this.x += a.x, this.y += a.y, this)
        },
        addScalar: function(a) {
            return this.x += a, this.y += a, this
        },
        addVectors: function(a, b) {
            return this.x = a.x + b.x, this.y = a.y + b.y, this
        },
        addScaledVector: function(a, b) {
            return this.x += a.x * b, this.y += a.y * b, this
        },
        sub: function(a, b) {
            return void 0 !== b ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b)) : (this.x -= a.x, this.y -= a.y, this)
        },
        subScalar: function(a) {
            return this.x -= a, this.y -= a, this
        },
        subVectors: function(a, b) {
            return this.x = a.x - b.x, this.y = a.y - b.y, this
        },
        multiply: function(a) {
            return this.x *= a.x, this.y *= a.y, this
        },
        multiplyScalar: function(a) {
            return isFinite(a) ? (this.x *= a, this.y *= a) : (this.x = 0, this.y = 0), this
        },
        divide: function(a) {
            return this.x /= a.x, this.y /= a.y, this
        },
        divideScalar: function(a) {
            return this.multiplyScalar(1 / a)
        },
        min: function(a) {
            return this.x = Math.min(this.x, a.x), this.y = Math.min(this.y, a.y), this
        },
        max: function(a) {
            return this.x = Math.max(this.x, a.x), this.y = Math.max(this.y, a.y), this
        },
        clamp: function(a, b) {
            // This function assumes min < max, if this assumption isn't true it will not operate correctly
            return this.x = Math.max(a.x, Math.min(b.x, this.x)), this.y = Math.max(a.y, Math.min(b.y, this.y)), this
        },
        clampScalar: function() {
            var a, b;
            return function(c, d) {
                return void 0 === a && (a = new THREE.Vector2, b = new THREE.Vector2), a.set(c, c), b.set(d, d), this.clamp(a, b)
            }
        }(),
        clampLength: function(a, b) {
            var c = this.length();
            return this.multiplyScalar(Math.max(a, Math.min(b, c)) / c), this
        },
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this
        },
        dot: function(a) {
            return this.x * a.x + this.y * a.y
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        },
        lengthManhattan: function() {
            return Math.abs(this.x) + Math.abs(this.y)
        },
        normalize: function() {
            return this.divideScalar(this.length())
        },
        angle: function() {
            // computes the angle in radians with respect to the positive x-axis
            var a = Math.atan2(this.y, this.x);
            return 0 > a && (a += 2 * Math.PI), a
        },
        distanceTo: function(a) {
            return Math.sqrt(this.distanceToSquared(a))
        },
        distanceToSquared: function(a) {
            var b = this.x - a.x,
                c = this.y - a.y;
            return b * b + c * c
        },
        setLength: function(a) {
            return this.multiplyScalar(a / this.length())
        },
        lerp: function(a, b) {
            return this.x += (a.x - this.x) * b, this.y += (a.y - this.y) * b, this
        },
        lerpVectors: function(a, b, c) {
            return this.subVectors(b, a).multiplyScalar(c).add(a), this
        },
        equals: function(a) {
            return a.x === this.x && a.y === this.y
        },
        fromArray: function(a, b) {
            return void 0 === b && (b = 0), this.x = a[b], this.y = a[b + 1], this
        },
        toArray: function(a, b) {
            return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this.x, a[b + 1] = this.y, a
        },
        fromAttribute: function(a, b, c) {
            return void 0 === c && (c = 0), b = b * a.itemSize + c, this.x = a.array[b], this.y = a.array[b + 1], this
        },
        rotateAround: function(a, b) {
            var c = Math.cos(b),
                d = Math.sin(b),
                e = this.x - a.x,
                f = this.y - a.y;
            return this.x = e * c - f * d + a.x, this.y = e * d + f * c + a.y, this
        }
    },
    // File:src/math/Vector3.js
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author *kile / http://kile.stravaganza.org/
     * @author philogb / http://blog.thejit.org/
     * @author mikael emtinger / http://gomo.se/
     * @author egraether / http://egraether.com/
     * @author WestLangley / http://github.com/WestLangley
     */
    THREE.Vector3 = function(a, b, c) {
        this.x = a || 0, this.y = b || 0, this.z = c || 0
    }, THREE.Vector3.prototype = {
        constructor: THREE.Vector3,
        set: function(a, b, c) {
            return this.x = a, this.y = b, this.z = c, this
        },
        setScalar: function(a) {
            return this.x = a, this.y = a, this.z = a, this
        },
        setX: function(a) {
            return this.x = a, this
        },
        setY: function(a) {
            return this.y = a, this
        },
        setZ: function(a) {
            return this.z = a, this
        },
        setComponent: function(a, b) {
            switch (a) {
                case 0:
                    this.x = b;
                    break;
                case 1:
                    this.y = b;
                    break;
                case 2:
                    this.z = b;
                    break;
                default:
                    throw new Error("index is out of range: " + a)
            }
        },
        getComponent: function(a) {
            switch (a) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw new Error("index is out of range: " + a)
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y, this.z)
        },
        copy: function(a) {
            return this.x = a.x, this.y = a.y, this.z = a.z, this
        },
        add: function(a, b) {
            return void 0 !== b ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b)) : (this.x += a.x, this.y += a.y, this.z += a.z, this)
        },
        addScalar: function(a) {
            return this.x += a, this.y += a, this.z += a, this
        },
        addVectors: function(a, b) {
            return this.x = a.x + b.x, this.y = a.y + b.y, this.z = a.z + b.z, this
        },
        addScaledVector: function(a, b) {
            return this.x += a.x * b, this.y += a.y * b, this.z += a.z * b, this
        },
        sub: function(a, b) {
            return void 0 !== b ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b)) : (this.x -= a.x, this.y -= a.y, this.z -= a.z, this)
        },
        subScalar: function(a) {
            return this.x -= a, this.y -= a, this.z -= a, this
        },
        subVectors: function(a, b) {
            return this.x = a.x - b.x, this.y = a.y - b.y, this.z = a.z - b.z, this
        },
        multiply: function(a, b) {
            return void 0 !== b ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(a, b)) : (this.x *= a.x, this.y *= a.y, this.z *= a.z, this)
        },
        multiplyScalar: function(a) {
            return isFinite(a) ? (this.x *= a, this.y *= a, this.z *= a) : (this.x = 0, this.y = 0, this.z = 0), this
        },
        multiplyVectors: function(a, b) {
            return this.x = a.x * b.x, this.y = a.y * b.y, this.z = a.z * b.z, this
        },
        applyEuler: function() {
            var a;
            return function(b) {
                return b instanceof THREE.Euler == !1 && console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), void 0 === a && (a = new THREE.Quaternion), this.applyQuaternion(a.setFromEuler(b)), this
            }
        }(),
        applyAxisAngle: function() {
            var a;
            return function(b, c) {
                return void 0 === a && (a = new THREE.Quaternion), this.applyQuaternion(a.setFromAxisAngle(b, c)), this
            }
        }(),
        applyMatrix3: function(a) {
            var b = this.x,
                c = this.y,
                d = this.z,
                e = a.elements;
            return this.x = e[0] * b + e[3] * c + e[6] * d, this.y = e[1] * b + e[4] * c + e[7] * d, this.z = e[2] * b + e[5] * c + e[8] * d, this
        },
        applyMatrix4: function(a) {
            // input: THREE.Matrix4 affine matrix
            var b = this.x,
                c = this.y,
                d = this.z,
                e = a.elements;
            return this.x = e[0] * b + e[4] * c + e[8] * d + e[12], this.y = e[1] * b + e[5] * c + e[9] * d + e[13], this.z = e[2] * b + e[6] * c + e[10] * d + e[14], this
        },
        applyProjection: function(a) {
            // input: THREE.Matrix4 projection matrix
            var b = this.x,
                c = this.y,
                d = this.z,
                e = a.elements,
                f = 1 / (e[3] * b + e[7] * c + e[11] * d + e[15]); // perspective divide
            return this.x = (e[0] * b + e[4] * c + e[8] * d + e[12]) * f, this.y = (e[1] * b + e[5] * c + e[9] * d + e[13]) * f, this.z = (e[2] * b + e[6] * c + e[10] * d + e[14]) * f, this
        },
        applyQuaternion: function(a) {
            var b = this.x,
                c = this.y,
                d = this.z,
                e = a.x,
                f = a.y,
                g = a.z,
                h = a.w,
                i = h * b + f * d - g * c,
                j = h * c + g * b - e * d,
                k = h * d + e * c - f * b,
                l = -e * b - f * c - g * d;
            // calculate result * inverse quat
            return this.x = i * h + l * -e + j * -g - k * -f, this.y = j * h + l * -f + k * -e - i * -g, this.z = k * h + l * -g + i * -f - j * -e, this
        },
        project: function() {
            var a;
            return function(b) {
                return void 0 === a && (a = new THREE.Matrix4), a.multiplyMatrices(b.projectionMatrix, a.getInverse(b.matrixWorld)), this.applyProjection(a)
            }
        }(),
        unproject: function() {
            var a;
            return function(b) {
                return void 0 === a && (a = new THREE.Matrix4), a.multiplyMatrices(b.matrixWorld, a.getInverse(b.projectionMatrix)), this.applyProjection(a)
            }
        }(),
        transformDirection: function(a) {
            // input: THREE.Matrix4 affine matrix
            // vector interpreted as a direction
            var b = this.x,
                c = this.y,
                d = this.z,
                e = a.elements;
            return this.x = e[0] * b + e[4] * c + e[8] * d, this.y = e[1] * b + e[5] * c + e[9] * d, this.z = e[2] * b + e[6] * c + e[10] * d, this.normalize(), this
        },
        divide: function(a) {
            return this.x /= a.x, this.y /= a.y, this.z /= a.z, this
        },
        divideScalar: function(a) {
            return this.multiplyScalar(1 / a)
        },
        min: function(a) {
            return this.x = Math.min(this.x, a.x), this.y = Math.min(this.y, a.y), this.z = Math.min(this.z, a.z), this
        },
        max: function(a) {
            return this.x = Math.max(this.x, a.x), this.y = Math.max(this.y, a.y), this.z = Math.max(this.z, a.z), this
        },
        clamp: function(a, b) {
            // This function assumes min < max, if this assumption isn't true it will not operate correctly
            return this.x = Math.max(a.x, Math.min(b.x, this.x)), this.y = Math.max(a.y, Math.min(b.y, this.y)), this.z = Math.max(a.z, Math.min(b.z, this.z)), this
        },
        clampScalar: function() {
            var a, b;
            return function(c, d) {
                return void 0 === a && (a = new THREE.Vector3, b = new THREE.Vector3), a.set(c, c, c), b.set(d, d, d), this.clamp(a, b)
            }
        }(),
        clampLength: function(a, b) {
            var c = this.length();
            return this.multiplyScalar(Math.max(a, Math.min(b, c)) / c), this
        },
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
        },
        dot: function(a) {
            return this.x * a.x + this.y * a.y + this.z * a.z
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        },
        lengthManhattan: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        },
        normalize: function() {
            return this.divideScalar(this.length())
        },
        setLength: function(a) {
            return this.multiplyScalar(a / this.length())
        },
        lerp: function(a, b) {
            return this.x += (a.x - this.x) * b, this.y += (a.y - this.y) * b, this.z += (a.z - this.z) * b, this
        },
        lerpVectors: function(a, b, c) {
            return this.subVectors(b, a).multiplyScalar(c).add(a), this
        },
        cross: function(a, b) {
            if (void 0 !== b) return console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(a, b);
            var c = this.x,
                d = this.y,
                e = this.z;
            return this.x = d * a.z - e * a.y, this.y = e * a.x - c * a.z, this.z = c * a.y - d * a.x, this
        },
        crossVectors: function(a, b) {
            var c = a.x,
                d = a.y,
                e = a.z,
                f = b.x,
                g = b.y,
                h = b.z;
            return this.x = d * h - e * g, this.y = e * f - c * h, this.z = c * g - d * f, this
        },
        projectOnVector: function() {
            var a, b;
            return function(c) {
                return void 0 === a && (a = new THREE.Vector3), a.copy(c).normalize(), b = this.dot(a), this.copy(a).multiplyScalar(b)
            }
        }(),
        projectOnPlane: function() {
            var a;
            return function(b) {
                return void 0 === a && (a = new THREE.Vector3), a.copy(this).projectOnVector(b), this.sub(a)
            }
        }(),
        reflect: function() {
            // reflect incident vector off plane orthogonal to normal
            // normal is assumed to have unit length
            var a;
            return function(b) {
                return void 0 === a && (a = new THREE.Vector3), this.sub(a.copy(b).multiplyScalar(2 * this.dot(b)))
            }
        }(),
        angleTo: function(a) {
            var b = this.dot(a) / Math.sqrt(this.lengthSq() * a.lengthSq());
            // clamp, to handle numerical problems
            return Math.acos(THREE.Math.clamp(b, -1, 1))
        },
        distanceTo: function(a) {
            return Math.sqrt(this.distanceToSquared(a))
        },
        distanceToSquared: function(a) {
            var b = this.x - a.x,
                c = this.y - a.y,
                d = this.z - a.z;
            return b * b + c * c + d * d
        },
        setFromMatrixPosition: function(a) {
            return this.x = a.elements[12], this.y = a.elements[13], this.z = a.elements[14], this
        },
        setFromMatrixScale: function(a) {
            var b = this.set(a.elements[0], a.elements[1], a.elements[2]).length(),
                c = this.set(a.elements[4], a.elements[5], a.elements[6]).length(),
                d = this.set(a.elements[8], a.elements[9], a.elements[10]).length();
            return this.x = b, this.y = c, this.z = d, this
        },
        setFromMatrixColumn: function(a, b) {
            var c = 4 * a,
                d = b.elements;
            return this.x = d[c], this.y = d[c + 1], this.z = d[c + 2], this
        },
        equals: function(a) {
            return a.x === this.x && a.y === this.y && a.z === this.z
        },
        fromArray: function(a, b) {
            return void 0 === b && (b = 0), this.x = a[b], this.y = a[b + 1], this.z = a[b + 2], this
        },
        toArray: function(a, b) {
            return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this.x, a[b + 1] = this.y, a[b + 2] = this.z, a
        },
        fromAttribute: function(a, b, c) {
            return void 0 === c && (c = 0), b = b * a.itemSize + c, this.x = a.array[b], this.y = a.array[b + 1], this.z = a.array[b + 2], this
        }
    },
    // File:src/math/Vector4.js
    /**
     * @author supereggbert / http://www.paulbrunt.co.uk/
     * @author philogb / http://blog.thejit.org/
     * @author mikael emtinger / http://gomo.se/
     * @author egraether / http://egraether.com/
     * @author WestLangley / http://github.com/WestLangley
     */
    THREE.Vector4 = function(a, b, c, d) {
        this.x = a || 0, this.y = b || 0, this.z = c || 0, this.w = void 0 !== d ? d : 1
    }, THREE.Vector4.prototype = {
        constructor: THREE.Vector4,
        set: function(a, b, c, d) {
            return this.x = a, this.y = b, this.z = c, this.w = d, this
        },
        setScalar: function(a) {
            return this.x = a, this.y = a, this.z = a, this.w = a, this
        },
        setX: function(a) {
            return this.x = a, this
        },
        setY: function(a) {
            return this.y = a, this
        },
        setZ: function(a) {
            return this.z = a, this
        },
        setW: function(a) {
            return this.w = a, this
        },
        setComponent: function(a, b) {
            switch (a) {
                case 0:
                    this.x = b;
                    break;
                case 1:
                    this.y = b;
                    break;
                case 2:
                    this.z = b;
                    break;
                case 3:
                    this.w = b;
                    break;
                default:
                    throw new Error("index is out of range: " + a)
            }
        },
        getComponent: function(a) {
            switch (a) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw new Error("index is out of range: " + a)
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y, this.z, this.w)
        },
        copy: function(a) {
            return this.x = a.x, this.y = a.y, this.z = a.z, this.w = void 0 !== a.w ? a.w : 1, this
        },
        add: function(a, b) {
            return void 0 !== b ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b)) : (this.x += a.x, this.y += a.y, this.z += a.z, this.w += a.w, this)
        },
        addScalar: function(a) {
            return this.x += a, this.y += a, this.z += a, this.w += a, this
        },
        addVectors: function(a, b) {
            return this.x = a.x + b.x, this.y = a.y + b.y, this.z = a.z + b.z, this.w = a.w + b.w, this
        },
        addScaledVector: function(a, b) {
            return this.x += a.x * b, this.y += a.y * b, this.z += a.z * b, this.w += a.w * b, this
        },
        sub: function(a, b) {
            return void 0 !== b ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b)) : (this.x -= a.x, this.y -= a.y, this.z -= a.z, this.w -= a.w, this)
        },
        subScalar: function(a) {
            return this.x -= a, this.y -= a, this.z -= a, this.w -= a, this
        },
        subVectors: function(a, b) {
            return this.x = a.x - b.x, this.y = a.y - b.y, this.z = a.z - b.z, this.w = a.w - b.w, this
        },
        multiplyScalar: function(a) {
            return isFinite(a) ? (this.x *= a, this.y *= a, this.z *= a, this.w *= a) : (this.x = 0, this.y = 0, this.z = 0, this.w = 0), this
        },
        applyMatrix4: function(a) {
            var b = this.x,
                c = this.y,
                d = this.z,
                e = this.w,
                f = a.elements;
            return this.x = f[0] * b + f[4] * c + f[8] * d + f[12] * e, this.y = f[1] * b + f[5] * c + f[9] * d + f[13] * e, this.z = f[2] * b + f[6] * c + f[10] * d + f[14] * e, this.w = f[3] * b + f[7] * c + f[11] * d + f[15] * e, this
        },
        divideScalar: function(a) {
            return this.multiplyScalar(1 / a)
        },
        setAxisAngleFromQuaternion: function(a) {
            // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
            // q is assumed to be normalized
            this.w = 2 * Math.acos(a.w);
            var b = Math.sqrt(1 - a.w * a.w);
            return 1e-4 > b ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = a.x / b, this.y = a.y / b, this.z = a.z / b), this
        },
        setAxisAngleFromRotationMatrix: function(a) {
            // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
            // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
            var b, c, d, e, // variables for result
                f = .01, // margin to allow for rounding errors
                g = .1, // margin to distinguish between 0 and 180 degrees
                h = a.elements,
                i = h[0],
                j = h[4],
                k = h[8],
                l = h[1],
                m = h[5],
                n = h[9],
                o = h[2],
                p = h[6],
                q = h[10];
            if (Math.abs(j - l) < f && Math.abs(k - o) < f && Math.abs(n - p) < f) {
                // singularity found
                // first check for identity matrix which must have +1 for all terms
                // in leading diagonal and zero in other terms
                if (Math.abs(j + l) < g && Math.abs(k + o) < g && Math.abs(n + p) < g && Math.abs(i + m + q - 3) < g)
                // this singularity is identity matrix so angle = 0
                    return this.set(1, 0, 0, 0), this;
                // otherwise this singularity is angle = 180
                b = Math.PI;
                var r = (i + 1) / 2,
                    s = (m + 1) / 2,
                    t = (q + 1) / 2,
                    u = (j + l) / 4,
                    v = (k + o) / 4,
                    w = (n + p) / 4;
                // m11 is the largest diagonal term
                // m22 is the largest diagonal term
                // m33 is the largest diagonal term so base result on this
                return r > s && r > t ? f > r ? (c = 0, d = .707106781, e = .707106781) : (c = Math.sqrt(r), d = u / c, e = v / c) : s > t ? f > s ? (c = .707106781, d = 0, e = .707106781) : (d = Math.sqrt(s), c = u / d, e = w / d) : f > t ? (c = .707106781, d = .707106781, e = 0) : (e = Math.sqrt(t), c = v / e, d = w / e), this.set(c, d, e, b), this
            }
            // as we have reached here there are no singularities so we can handle normally
            var x = Math.sqrt((p - n) * (p - n) + (k - o) * (k - o) + (l - j) * (l - j)); // used to normalize
            // prevent divide by zero, should not happen if matrix is orthogonal and should be
            // caught by singularity test above, but I've left it in just in case
            return Math.abs(x) < .001 && (x = 1), this.x = (p - n) / x, this.y = (k - o) / x, this.z = (l - j) / x, this.w = Math.acos((i + m + q - 1) / 2), this
        },
        min: function(a) {
            return this.x = Math.min(this.x, a.x), this.y = Math.min(this.y, a.y), this.z = Math.min(this.z, a.z), this.w = Math.min(this.w, a.w), this
        },
        max: function(a) {
            return this.x = Math.max(this.x, a.x), this.y = Math.max(this.y, a.y), this.z = Math.max(this.z, a.z), this.w = Math.max(this.w, a.w), this
        },
        clamp: function(a, b) {
            // This function assumes min < max, if this assumption isn't true it will not operate correctly
            return this.x = Math.max(a.x, Math.min(b.x, this.x)), this.y = Math.max(a.y, Math.min(b.y, this.y)), this.z = Math.max(a.z, Math.min(b.z, this.z)), this.w = Math.max(a.w, Math.min(b.w, this.w)), this
        },
        clampScalar: function() {
            var a, b;
            return function(c, d) {
                return void 0 === a && (a = new THREE.Vector4, b = new THREE.Vector4), a.set(c, c, c, c), b.set(d, d, d, d), this.clamp(a, b)
            }
        }(),
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
        },
        dot: function(a) {
            return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        },
        lengthManhattan: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        },
        normalize: function() {
            return this.divideScalar(this.length())
        },
        setLength: function(a) {
            return this.multiplyScalar(a / this.length())
        },
        lerp: function(a, b) {
            return this.x += (a.x - this.x) * b, this.y += (a.y - this.y) * b, this.z += (a.z - this.z) * b, this.w += (a.w - this.w) * b, this
        },
        lerpVectors: function(a, b, c) {
            return this.subVectors(b, a).multiplyScalar(c).add(a), this
        },
        equals: function(a) {
            return a.x === this.x && a.y === this.y && a.z === this.z && a.w === this.w
        },
        fromArray: function(a, b) {
            return void 0 === b && (b = 0), this.x = a[b], this.y = a[b + 1], this.z = a[b + 2], this.w = a[b + 3], this
        },
        toArray: function(a, b) {
            return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this.x, a[b + 1] = this.y, a[b + 2] = this.z, a[b + 3] = this.w, a
        },
        fromAttribute: function(a, b, c) {
            return void 0 === c && (c = 0), b = b * a.itemSize + c, this.x = a.array[b], this.y = a.array[b + 1], this.z = a.array[b + 2], this.w = a.array[b + 3], this
        }
    },
    // File:src/math/Euler.js
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author WestLangley / http://github.com/WestLangley
     * @author bhouston / http://clara.io
     */
    THREE.Euler = function(a, b, c, d) {
        this._x = a || 0, this._y = b || 0, this._z = c || 0, this._order = d || THREE.Euler.DefaultOrder
    }, THREE.Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], THREE.Euler.DefaultOrder = "XYZ", THREE.Euler.prototype = {
        constructor: THREE.Euler,
        get x() {
            return this._x
        },
        set x(a) {
            this._x = a, this.onChangeCallback()
        },
        get y() {
            return this._y
        },
        set y(a) {
            this._y = a, this.onChangeCallback()
        },
        get z() {
            return this._z
        },
        set z(a) {
            this._z = a, this.onChangeCallback()
        },
        get order() {
            return this._order
        },
        set order(a) {
            this._order = a, this.onChangeCallback()
        },
        set: function(a, b, c, d) {
            return this._x = a, this._y = b, this._z = c, this._order = d || this._order, this.onChangeCallback(), this
        },
        clone: function() {
            return new this.constructor(this._x, this._y, this._z, this._order)
        },
        copy: function(a) {
            return this._x = a._x, this._y = a._y, this._z = a._z, this._order = a._order, this.onChangeCallback(), this
        },
        setFromRotationMatrix: function(a, b, c) {
            var d = THREE.Math.clamp,
                e = a.elements,
                f = e[0],
                g = e[4],
                h = e[8],
                i = e[1],
                j = e[5],
                k = e[9],
                l = e[2],
                m = e[6],
                n = e[10];
            return b = b || this._order, "XYZ" === b ? (this._y = Math.asin(d(h, -1, 1)), Math.abs(h) < .99999 ? (this._x = Math.atan2(-k, n), this._z = Math.atan2(-g, f)) : (this._x = Math.atan2(m, j), this._z = 0)) : "YXZ" === b ? (this._x = Math.asin(-d(k, -1, 1)), Math.abs(k) < .99999 ? (this._y = Math.atan2(h, n), this._z = Math.atan2(i, j)) : (this._y = Math.atan2(-l, f), this._z = 0)) : "ZXY" === b ? (this._x = Math.asin(d(m, -1, 1)), Math.abs(m) < .99999 ? (this._y = Math.atan2(-l, n), this._z = Math.atan2(-g, j)) : (this._y = 0, this._z = Math.atan2(i, f))) : "ZYX" === b ? (this._y = Math.asin(-d(l, -1, 1)), Math.abs(l) < .99999 ? (this._x = Math.atan2(m, n), this._z = Math.atan2(i, f)) : (this._x = 0, this._z = Math.atan2(-g, j))) : "YZX" === b ? (this._z = Math.asin(d(i, -1, 1)), Math.abs(i) < .99999 ? (this._x = Math.atan2(-k, j), this._y = Math.atan2(-l, f)) : (this._x = 0, this._y = Math.atan2(h, n))) : "XZY" === b ? (this._z = Math.asin(-d(g, -1, 1)), Math.abs(g) < .99999 ? (this._x = Math.atan2(m, j), this._y = Math.atan2(h, f)) : (this._x = Math.atan2(-k, n), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + b), this._order = b, c !== !1 && this.onChangeCallback(), this
        },
        setFromQuaternion: function() {
            var a;
            return function(b, c, d) {
                return void 0 === a && (a = new THREE.Matrix4), a.makeRotationFromQuaternion(b), this.setFromRotationMatrix(a, c, d), this
            }
        }(),
        setFromVector3: function(a, b) {
            return this.set(a.x, a.y, a.z, b || this._order)
        },
        reorder: function() {
            // WARNING: this discards revolution information -bhouston
            var a = new THREE.Quaternion;
            return function(b) {
                a.setFromEuler(this), this.setFromQuaternion(a, b)
            }
        }(),
        equals: function(a) {
            return a._x === this._x && a._y === this._y && a._z === this._z && a._order === this._order
        },
        fromArray: function(a) {
            return this._x = a[0], this._y = a[1], this._z = a[2], void 0 !== a[3] && (this._order = a[3]), this.onChangeCallback(), this
        },
        toArray: function(a, b) {
            return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this._x, a[b + 1] = this._y, a[b + 2] = this._z, a[b + 3] = this._order, a
        },
        toVector3: function(a) {
            return a ? a.set(this._x, this._y, this._z) : new THREE.Vector3(this._x, this._y, this._z)
        },
        onChange: function(a) {
            return this.onChangeCallback = a, this
        },
        onChangeCallback: function() {}
    },
    // File:src/math/Line3.js
    /**
     * @author bhouston / http://clara.io
     */
    THREE.Line3 = function(a, b) {
        this.start = void 0 !== a ? a : new THREE.Vector3, this.end = void 0 !== b ? b : new THREE.Vector3
    }, THREE.Line3.prototype = {
        constructor: THREE.Line3,
        set: function(a, b) {
            return this.start.copy(a), this.end.copy(b), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(a) {
            return this.start.copy(a.start), this.end.copy(a.end), this
        },
        center: function(a) {
            var b = a || new THREE.Vector3;
            return b.addVectors(this.start, this.end).multiplyScalar(.5)
        },
        delta: function(a) {
            var b = a || new THREE.Vector3;
            return b.subVectors(this.end, this.start)
        },
        distanceSq: function() {
            return this.start.distanceToSquared(this.end)
        },
        distance: function() {
            return this.start.distanceTo(this.end)
        },
        at: function(a, b) {
            var c = b || new THREE.Vector3;
            return this.delta(c).multiplyScalar(a).add(this.start)
        },
        closestPointToPointParameter: function() {
            var a = new THREE.Vector3,
                b = new THREE.Vector3;
            return function(c, d) {
                a.subVectors(c, this.start), b.subVectors(this.end, this.start);
                var e = b.dot(b),
                    f = b.dot(a),
                    g = f / e;
                return d && (g = THREE.Math.clamp(g, 0, 1)), g
            }
        }(),
        closestPointToPoint: function(a, b, c) {
            var d = this.closestPointToPointParameter(a, b),
                e = c || new THREE.Vector3;
            return this.delta(e).multiplyScalar(d).add(this.start)
        },
        applyMatrix4: function(a) {
            return this.start.applyMatrix4(a), this.end.applyMatrix4(a), this
        },
        equals: function(a) {
            return a.start.equals(this.start) && a.end.equals(this.end)
        }
    },
    // File:src/math/Box2.js
    /**
     * @author bhouston / http://clara.io
     */
    THREE.Box2 = function(a, b) {
        this.min = void 0 !== a ? a : new THREE.Vector2(+(1 / 0), +(1 / 0)), this.max = void 0 !== b ? b : new THREE.Vector2(-(1 / 0), -(1 / 0))
    }, THREE.Box2.prototype = {
        constructor: THREE.Box2,
        set: function(a, b) {
            return this.min.copy(a), this.max.copy(b), this
        },
        setFromPoints: function(a) {
            this.makeEmpty();
            for (var b = 0, c = a.length; c > b; b++) this.expandByPoint(a[b]);
            return this
        },
        setFromCenterAndSize: function() {
            var a = new THREE.Vector2;
            return function(b, c) {
                var d = a.copy(c).multiplyScalar(.5);
                return this.min.copy(b).sub(d), this.max.copy(b).add(d), this
            }
        }(),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(a) {
            return this.min.copy(a.min), this.max.copy(a.max), this
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = +(1 / 0), this.max.x = this.max.y = -(1 / 0), this
        },
        isEmpty: function() {
            // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
            return this.max.x < this.min.x || this.max.y < this.min.y
        },
        center: function(a) {
            var b = a || new THREE.Vector2;
            return b.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        size: function(a) {
            var b = a || new THREE.Vector2;
            return b.subVectors(this.max, this.min)
        },
        expandByPoint: function(a) {
            return this.min.min(a), this.max.max(a), this
        },
        expandByVector: function(a) {
            return this.min.sub(a), this.max.add(a), this
        },
        expandByScalar: function(a) {
            return this.min.addScalar(-a), this.max.addScalar(a), this
        },
        containsPoint: function(a) {
            return !(a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y)
        },
        containsBox: function(a) {
            return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y
        },
        getParameter: function(a, b) {
            // This can potentially have a divide by zero if the box
            // has a size dimension of 0.
            var c = b || new THREE.Vector2;
            return c.set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y))
        },
        intersectsBox: function(a) {
            // using 6 splitting planes to rule out intersections.
            return !(a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y)
        },
        clampPoint: function(a, b) {
            var c = b || new THREE.Vector2;
            return c.copy(a).clamp(this.min, this.max)
        },
        distanceToPoint: function() {
            var a = new THREE.Vector2;
            return function(b) {
                var c = a.copy(b).clamp(this.min, this.max);
                return c.sub(b).length()
            }
        }(),
        intersect: function(a) {
            return this.min.max(a.min), this.max.min(a.max), this
        },
        union: function(a) {
            return this.min.min(a.min), this.max.max(a.max), this
        },
        translate: function(a) {
            return this.min.add(a), this.max.add(a), this
        },
        equals: function(a) {
            return a.min.equals(this.min) && a.max.equals(this.max)
        }
    },
    // File:src/math/Box3.js
    /**
     * @author bhouston / http://clara.io
     * @author WestLangley / http://github.com/WestLangley
     */
    THREE.Box3 = function(a, b) {
        this.min = void 0 !== a ? a : new THREE.Vector3(+(1 / 0), +(1 / 0), +(1 / 0)), this.max = void 0 !== b ? b : new THREE.Vector3(-(1 / 0), -(1 / 0), -(1 / 0))
    }, THREE.Box3.prototype = {
        constructor: THREE.Box3,
        set: function(a, b) {
            return this.min.copy(a), this.max.copy(b), this
        },
        setFromArray: function(a) {
            this.makeEmpty();
            for (var b = +(1 / 0), c = +(1 / 0), d = +(1 / 0), e = -(1 / 0), f = -(1 / 0), g = -(1 / 0), h = 0, i = a.length; i > h; h += 3) {
                var j = a[h],
                    k = a[h + 1],
                    l = a[h + 2];
                b = Math.min(b, j), c = Math.min(c, k), d = Math.min(d, l), e = Math.max(e, j), f = Math.max(f, k), g = Math.max(g, l)
            }
            this.min.set(b, c, d), this.max.set(e, f, g)
        },
        setFromPoints: function(a) {
            this.makeEmpty();
            for (var b = 0, c = a.length; c > b; b++) this.expandByPoint(a[b]);
            return this
        },
        setFromCenterAndSize: function() {
            var a = new THREE.Vector3;
            return function(b, c) {
                var d = a.copy(c).multiplyScalar(.5);
                return this.min.copy(b).sub(d), this.max.copy(b).add(d), this
            }
        }(),
        setFromObject: function() {
            // Computes the world-axis-aligned bounding box of an object (including its children),
            // accounting for both the object's, and children's, world transforms
            var a;
            return function(b) {
                void 0 === a && (a = new THREE.Box3);
                var c = this;
                return this.makeEmpty(), b.updateMatrixWorld(!0), b.traverse(function(b) {
                    var d = b.geometry;
                    void 0 !== d && (null === d.boundingBox && d.computeBoundingBox(), a.copy(d.boundingBox), a.applyMatrix4(b.matrixWorld), c.union(a))
                }), this
            }
        }(),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(a) {
            return this.min.copy(a.min), this.max.copy(a.max), this
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = this.min.z = +(1 / 0), this.max.x = this.max.y = this.max.z = -(1 / 0), this
        },
        isEmpty: function() {
            // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        },
        center: function(a) {
            var b = a || new THREE.Vector3;
            return b.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        size: function(a) {
            var b = a || new THREE.Vector3;
            return b.subVectors(this.max, this.min)
        },
        expandByPoint: function(a) {
            return this.min.min(a), this.max.max(a), this
        },
        expandByVector: function(a) {
            return this.min.sub(a), this.max.add(a), this
        },
        expandByScalar: function(a) {
            return this.min.addScalar(-a), this.max.addScalar(a), this
        },
        containsPoint: function(a) {
            return !(a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y || a.z < this.min.z || a.z > this.max.z)
        },
        containsBox: function(a) {
            return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y && this.min.z <= a.min.z && a.max.z <= this.max.z
        },
        getParameter: function(a, b) {
            // This can potentially have a divide by zero if the box
            // has a size dimension of 0.
            var c = b || new THREE.Vector3;
            return c.set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y), (a.z - this.min.z) / (this.max.z - this.min.z))
        },
        intersectsBox: function(a) {
            // using 6 splitting planes to rule out intersections.
            return !(a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y || a.max.z < this.min.z || a.min.z > this.max.z)
        },
        intersectsSphere: function() {
            var a;
            return function(b) {
                // If that point is inside the sphere, the AABB and sphere intersect.
                // Find the point on the AABB closest to the sphere center.
                return void 0 === a && (a = new THREE.Vector3), this.clampPoint(b.center, a), a.distanceToSquared(b.center) <= b.radius * b.radius
            }
        }(),
        intersectsPlane: function(a) {
            // We compute the minimum and maximum dot product values. If those values
            // are on the same side (back or front) of the plane, then there is no intersection.
            var b, c;
            return a.normal.x > 0 ? (b = a.normal.x * this.min.x, c = a.normal.x * this.max.x) : (b = a.normal.x * this.max.x, c = a.normal.x * this.min.x), a.normal.y > 0 ? (b += a.normal.y * this.min.y, c += a.normal.y * this.max.y) : (b += a.normal.y * this.max.y, c += a.normal.y * this.min.y), a.normal.z > 0 ? (b += a.normal.z * this.min.z, c += a.normal.z * this.max.z) : (b += a.normal.z * this.max.z, c += a.normal.z * this.min.z), b <= a.constant && c >= a.constant
        },
        clampPoint: function(a, b) {
            var c = b || new THREE.Vector3;
            return c.copy(a).clamp(this.min, this.max)
        },
        distanceToPoint: function() {
            var a = new THREE.Vector3;
            return function(b) {
                var c = a.copy(b).clamp(this.min, this.max);
                return c.sub(b).length()
            }
        }(),
        getBoundingSphere: function() {
            var a = new THREE.Vector3;
            return function(b) {
                var c = b || new THREE.Sphere;
                return c.center = this.center(), c.radius = .5 * this.size(a).length(), c
            }
        }(),
        intersect: function(a) {
            return this.min.max(a.min), this.max.min(a.max), this
        },
        union: function(a) {
            return this.min.min(a.min), this.max.max(a.max), this
        },
        applyMatrix4: function() {
            var a = [new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3];
            return function(b) {
                // NOTE: I am using a binary pattern to specify all 2^3 combinations below
                // 000
                // 001
                // 010
                // 011
                // 100
                // 101
                // 110
                // 111
                return a[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(b), a[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(b), a[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(b), a[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(b), a[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(b), a[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(b), a[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(b), a[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(b), this.makeEmpty(), this.setFromPoints(a), this
            }
        }(),
        translate: function(a) {
            return this.min.add(a), this.max.add(a), this
        },
        equals: function(a) {
            return a.min.equals(this.min) && a.max.equals(this.max)
        }
    },
    // File:src/math/Matrix3.js
    /**
     * @author alteredq / http://alteredqualia.com/
     * @author WestLangley / http://github.com/WestLangley
     * @author bhouston / http://clara.io
     */
    THREE.Matrix3 = function() {
        this.elements = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]), arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
    }, THREE.Matrix3.prototype = {
        constructor: THREE.Matrix3,
        set: function(a, b, c, d, e, f, g, h, i) {
            var j = this.elements;
            return j[0] = a, j[3] = b, j[6] = c, j[1] = d, j[4] = e, j[7] = f, j[2] = g, j[5] = h, j[8] = i, this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
        },
        clone: function() {
            return (new this.constructor).fromArray(this.elements)
        },
        copy: function(a) {
            var b = a.elements;
            return this.set(b[0], b[3], b[6], b[1], b[4], b[7], b[2], b[5], b[8]), this
        },
        applyToVector3Array: function() {
            var a;
            return function(b, c, d) {
                void 0 === a && (a = new THREE.Vector3), void 0 === c && (c = 0), void 0 === d && (d = b.length);
                for (var e = 0, f = c; d > e; e += 3, f += 3) a.fromArray(b, f), a.applyMatrix3(this), a.toArray(b, f);
                return b
            }
        }(),
        applyToBuffer: function() {
            var a;
            return function(b, c, d) {
                void 0 === a && (a = new THREE.Vector3), void 0 === c && (c = 0), void 0 === d && (d = b.length / b.itemSize);
                for (var e = 0, f = c; d > e; e++, f++) a.x = b.getX(f), a.y = b.getY(f), a.z = b.getZ(f), a.applyMatrix3(this), b.setXYZ(a.x, a.y, a.z);
                return b
            }
        }(),
        multiplyScalar: function(a) {
            var b = this.elements;
            return b[0] *= a, b[3] *= a, b[6] *= a, b[1] *= a, b[4] *= a, b[7] *= a, b[2] *= a, b[5] *= a, b[8] *= a, this
        },
        determinant: function() {
            var a = this.elements,
                b = a[0],
                c = a[1],
                d = a[2],
                e = a[3],
                f = a[4],
                g = a[5],
                h = a[6],
                i = a[7],
                j = a[8];
            return b * f * j - b * g * i - c * e * j + c * g * h + d * e * i - d * f * h
        },
        getInverse: function(a, b) {
            // input: THREE.Matrix4
            // ( based on http://code.google.com/p/webgl-mjs/ )
            var c = a.elements,
                d = this.elements;
            d[0] = c[10] * c[5] - c[6] * c[9], d[1] = -c[10] * c[1] + c[2] * c[9], d[2] = c[6] * c[1] - c[2] * c[5], d[3] = -c[10] * c[4] + c[6] * c[8], d[4] = c[10] * c[0] - c[2] * c[8], d[5] = -c[6] * c[0] + c[2] * c[4], d[6] = c[9] * c[4] - c[5] * c[8], d[7] = -c[9] * c[0] + c[1] * c[8], d[8] = c[5] * c[0] - c[1] * c[4];
            var e = c[0] * d[0] + c[1] * d[3] + c[2] * d[6];
            // no inverse
            if (0 === e) {
                var f = "THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0";
                if (b) throw new Error(f);
                return console.warn(f), this.identity(), this
            }
            return this.multiplyScalar(1 / e), this
        },
        transpose: function() {
            var a, b = this.elements;
            return a = b[1], b[1] = b[3], b[3] = a, a = b[2], b[2] = b[6], b[6] = a, a = b[5], b[5] = b[7], b[7] = a, this
        },
        flattenToArrayOffset: function(a, b) {
            var c = this.elements;
            return a[b] = c[0], a[b + 1] = c[1], a[b + 2] = c[2], a[b + 3] = c[3], a[b + 4] = c[4], a[b + 5] = c[5], a[b + 6] = c[6], a[b + 7] = c[7], a[b + 8] = c[8], a
        },
        getNormalMatrix: function(a) {
            // input: THREE.Matrix4
            return this.getInverse(a).transpose(), this
        },
        transposeIntoArray: function(a) {
            var b = this.elements;
            return a[0] = b[0], a[1] = b[3], a[2] = b[6], a[3] = b[1], a[4] = b[4], a[5] = b[7], a[6] = b[2], a[7] = b[5], a[8] = b[8], this
        },
        fromArray: function(a) {
            return this.elements.set(a), this
        },
        toArray: function() {
            var a = this.elements;
            return [a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]]
        }
    },
    // File:src/math/Matrix4.js
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author supereggbert / http://www.paulbrunt.co.uk/
     * @author philogb / http://blog.thejit.org/
     * @author jordi_ros / http://plattsoft.com
     * @author D1plo1d / http://github.com/D1plo1d
     * @author alteredq / http://alteredqualia.com/
     * @author mikael emtinger / http://gomo.se/
     * @author timknip / http://www.floorplanner.com/
     * @author bhouston / http://clara.io
     * @author WestLangley / http://github.com/WestLangley
     */
    THREE.Matrix4 = function() {
        this.elements = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
    }, THREE.Matrix4.prototype = {
        constructor: THREE.Matrix4,
        set: function(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {
            var q = this.elements;
            return q[0] = a, q[4] = b, q[8] = c, q[12] = d, q[1] = e, q[5] = f, q[9] = g, q[13] = h, q[2] = i, q[6] = j, q[10] = k, q[14] = l, q[3] = m, q[7] = n, q[11] = o, q[15] = p, this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        },
        clone: function() {
            return (new THREE.Matrix4).fromArray(this.elements)
        },
        copy: function(a) {
            return this.elements.set(a.elements), this
        },
        copyPosition: function(a) {
            var b = this.elements,
                c = a.elements;
            return b[12] = c[12], b[13] = c[13], b[14] = c[14], this
        },
        extractBasis: function(a, b, c) {
            var d = this.elements;
            return a.set(d[0], d[1], d[2]), b.set(d[4], d[5], d[6]), c.set(d[8], d[9], d[10]), this
        },
        makeBasis: function(a, b, c) {
            return this.set(a.x, b.x, c.x, 0, a.y, b.y, c.y, 0, a.z, b.z, c.z, 0, 0, 0, 0, 1), this
        },
        extractRotation: function() {
            var a;
            return function(b) {
                void 0 === a && (a = new THREE.Vector3);
                var c = this.elements,
                    d = b.elements,
                    e = 1 / a.set(d[0], d[1], d[2]).length(),
                    f = 1 / a.set(d[4], d[5], d[6]).length(),
                    g = 1 / a.set(d[8], d[9], d[10]).length();
                return c[0] = d[0] * e, c[1] = d[1] * e, c[2] = d[2] * e, c[4] = d[4] * f, c[5] = d[5] * f, c[6] = d[6] * f, c[8] = d[8] * g, c[9] = d[9] * g, c[10] = d[10] * g, this
            }
        }(),
        makeRotationFromEuler: function(a) {
            a instanceof THREE.Euler == !1 && console.error("THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            var b = this.elements,
                c = a.x,
                d = a.y,
                e = a.z,
                f = Math.cos(c),
                g = Math.sin(c),
                h = Math.cos(d),
                i = Math.sin(d),
                j = Math.cos(e),
                k = Math.sin(e);
            if ("XYZ" === a.order) {
                var l = f * j,
                    m = f * k,
                    n = g * j,
                    o = g * k;
                b[0] = h * j, b[4] = -h * k, b[8] = i, b[1] = m + n * i, b[5] = l - o * i, b[9] = -g * h, b[2] = o - l * i, b[6] = n + m * i, b[10] = f * h
            } else if ("YXZ" === a.order) {
                var p = h * j,
                    q = h * k,
                    r = i * j,
                    s = i * k;
                b[0] = p + s * g, b[4] = r * g - q, b[8] = f * i, b[1] = f * k, b[5] = f * j, b[9] = -g, b[2] = q * g - r, b[6] = s + p * g, b[10] = f * h
            } else if ("ZXY" === a.order) {
                var p = h * j,
                    q = h * k,
                    r = i * j,
                    s = i * k;
                b[0] = p - s * g, b[4] = -f * k, b[8] = r + q * g, b[1] = q + r * g, b[5] = f * j, b[9] = s - p * g, b[2] = -f * i, b[6] = g, b[10] = f * h
            } else if ("ZYX" === a.order) {
                var l = f * j,
                    m = f * k,
                    n = g * j,
                    o = g * k;
                b[0] = h * j, b[4] = n * i - m, b[8] = l * i + o, b[1] = h * k, b[5] = o * i + l, b[9] = m * i - n, b[2] = -i, b[6] = g * h, b[10] = f * h
            } else if ("YZX" === a.order) {
                var t = f * h,
                    u = f * i,
                    v = g * h,
                    w = g * i;
                b[0] = h * j, b[4] = w - t * k, b[8] = v * k + u, b[1] = k, b[5] = f * j, b[9] = -g * j, b[2] = -i * j, b[6] = u * k + v, b[10] = t - w * k
            } else if ("XZY" === a.order) {
                var t = f * h,
                    u = f * i,
                    v = g * h,
                    w = g * i;
                b[0] = h * j, b[4] = -k, b[8] = i * j, b[1] = t * k + w, b[5] = f * j, b[9] = u * k - v, b[2] = v * k - u, b[6] = g * j, b[10] = w * k + t
            }
            // last column
            // bottom row
            return b[3] = 0, b[7] = 0, b[11] = 0, b[12] = 0, b[13] = 0, b[14] = 0, b[15] = 1, this
        },
        makeRotationFromQuaternion: function(a) {
            var b = this.elements,
                c = a.x,
                d = a.y,
                e = a.z,
                f = a.w,
                g = c + c,
                h = d + d,
                i = e + e,
                j = c * g,
                k = c * h,
                l = c * i,
                m = d * h,
                n = d * i,
                o = e * i,
                p = f * g,
                q = f * h,
                r = f * i;
            // last column
            // bottom row
            return b[0] = 1 - (m + o), b[4] = k - r, b[8] = l + q, b[1] = k + r, b[5] = 1 - (j + o), b[9] = n - p, b[2] = l - q, b[6] = n + p, b[10] = 1 - (j + m), b[3] = 0, b[7] = 0, b[11] = 0, b[12] = 0, b[13] = 0, b[14] = 0, b[15] = 1, this
        },
        lookAt: function() {
            var a, b, c;
            return function(d, e, f) {
                void 0 === a && (a = new THREE.Vector3), void 0 === b && (b = new THREE.Vector3), void 0 === c && (c = new THREE.Vector3);
                var g = this.elements;
                return c.subVectors(d, e).normalize(), 0 === c.lengthSq() && (c.z = 1), a.crossVectors(f, c).normalize(), 0 === a.lengthSq() && (c.x += 1e-4, a.crossVectors(f, c).normalize()), b.crossVectors(c, a), g[0] = a.x, g[4] = b.x, g[8] = c.x, g[1] = a.y, g[5] = b.y, g[9] = c.y, g[2] = a.z, g[6] = b.z, g[10] = c.z, this
            }
        }(),
        multiply: function(a, b) {
            return void 0 !== b ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(a, b)) : this.multiplyMatrices(this, a)
        },
        multiplyMatrices: function(a, b) {
            var c = a.elements,
                d = b.elements,
                e = this.elements,
                f = c[0],
                g = c[4],
                h = c[8],
                i = c[12],
                j = c[1],
                k = c[5],
                l = c[9],
                m = c[13],
                n = c[2],
                o = c[6],
                p = c[10],
                q = c[14],
                r = c[3],
                s = c[7],
                t = c[11],
                u = c[15],
                v = d[0],
                w = d[4],
                x = d[8],
                y = d[12],
                z = d[1],
                A = d[5],
                B = d[9],
                C = d[13],
                D = d[2],
                E = d[6],
                F = d[10],
                G = d[14],
                H = d[3],
                I = d[7],
                J = d[11],
                K = d[15];
            return e[0] = f * v + g * z + h * D + i * H, e[4] = f * w + g * A + h * E + i * I, e[8] = f * x + g * B + h * F + i * J, e[12] = f * y + g * C + h * G + i * K, e[1] = j * v + k * z + l * D + m * H, e[5] = j * w + k * A + l * E + m * I, e[9] = j * x + k * B + l * F + m * J, e[13] = j * y + k * C + l * G + m * K, e[2] = n * v + o * z + p * D + q * H, e[6] = n * w + o * A + p * E + q * I, e[10] = n * x + o * B + p * F + q * J, e[14] = n * y + o * C + p * G + q * K, e[3] = r * v + s * z + t * D + u * H, e[7] = r * w + s * A + t * E + u * I, e[11] = r * x + s * B + t * F + u * J, e[15] = r * y + s * C + t * G + u * K, this
        },
        multiplyToArray: function(a, b, c) {
            var d = this.elements;
            return this.multiplyMatrices(a, b), c[0] = d[0], c[1] = d[1], c[2] = d[2], c[3] = d[3], c[4] = d[4], c[5] = d[5], c[6] = d[6], c[7] = d[7], c[8] = d[8], c[9] = d[9], c[10] = d[10], c[11] = d[11], c[12] = d[12], c[13] = d[13], c[14] = d[14], c[15] = d[15], this
        },
        multiplyScalar: function(a) {
            var b = this.elements;
            return b[0] *= a, b[4] *= a, b[8] *= a, b[12] *= a, b[1] *= a, b[5] *= a, b[9] *= a, b[13] *= a, b[2] *= a, b[6] *= a, b[10] *= a, b[14] *= a, b[3] *= a, b[7] *= a, b[11] *= a, b[15] *= a, this
        },
        applyToVector3Array: function() {
            var a;
            return function(b, c, d) {
                void 0 === a && (a = new THREE.Vector3), void 0 === c && (c = 0), void 0 === d && (d = b.length);
                for (var e = 0, f = c; d > e; e += 3, f += 3) a.fromArray(b, f), a.applyMatrix4(this), a.toArray(b, f);
                return b
            }
        }(),
        applyToBuffer: function() {
            var a;
            return function(b, c, d) {
                void 0 === a && (a = new THREE.Vector3), void 0 === c && (c = 0), void 0 === d && (d = b.length / b.itemSize);
                for (var e = 0, f = c; d > e; e++, f++) a.x = b.getX(f), a.y = b.getY(f), a.z = b.getZ(f), a.applyMatrix4(this), b.setXYZ(a.x, a.y, a.z);
                return b
            }
        }(),
        determinant: function() {
            var a = this.elements,
                b = a[0],
                c = a[4],
                d = a[8],
                e = a[12],
                f = a[1],
                g = a[5],
                h = a[9],
                i = a[13],
                j = a[2],
                k = a[6],
                l = a[10],
                m = a[14],
                n = a[3],
                o = a[7],
                p = a[11],
                q = a[15];
            //TODO: make this more efficient
            //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
            return n * (+e * h * k - d * i * k - e * g * l + c * i * l + d * g * m - c * h * m) + o * (+b * h * m - b * i * l + e * f * l - d * f * m + d * i * j - e * h * j) + p * (+b * i * k - b * g * m - e * f * k + c * f * m + e * g * j - c * i * j) + q * (-d * g * j - b * h * k + b * g * l + d * f * k - c * f * l + c * h * j)
        },
        transpose: function() {
            var a, b = this.elements;
            return a = b[1], b[1] = b[4], b[4] = a, a = b[2], b[2] = b[8], b[8] = a, a = b[6], b[6] = b[9], b[9] = a, a = b[3], b[3] = b[12], b[12] = a, a = b[7], b[7] = b[13], b[13] = a, a = b[11], b[11] = b[14], b[14] = a, this
        },
        flattenToArrayOffset: function(a, b) {
            var c = this.elements;
            return a[b] = c[0], a[b + 1] = c[1], a[b + 2] = c[2], a[b + 3] = c[3], a[b + 4] = c[4], a[b + 5] = c[5], a[b + 6] = c[6], a[b + 7] = c[7], a[b + 8] = c[8], a[b + 9] = c[9], a[b + 10] = c[10], a[b + 11] = c[11], a[b + 12] = c[12], a[b + 13] = c[13], a[b + 14] = c[14], a[b + 15] = c[15], a
        },
        getPosition: function() {
            var a;
            return function() {
                void 0 === a && (a = new THREE.Vector3), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
                var b = this.elements;
                return a.set(b[12], b[13], b[14])
            }
        }(),
        setPosition: function(a) {
            var b = this.elements;
            return b[12] = a.x, b[13] = a.y, b[14] = a.z, this
        },
        getInverse: function(a, b) {
            // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
            var c = this.elements,
                d = a.elements,
                e = d[0],
                f = d[4],
                g = d[8],
                h = d[12],
                i = d[1],
                j = d[5],
                k = d[9],
                l = d[13],
                m = d[2],
                n = d[6],
                o = d[10],
                p = d[14],
                q = d[3],
                r = d[7],
                s = d[11],
                t = d[15];
            c[0] = k * p * r - l * o * r + l * n * s - j * p * s - k * n * t + j * o * t, c[4] = h * o * r - g * p * r - h * n * s + f * p * s + g * n * t - f * o * t, c[8] = g * l * r - h * k * r + h * j * s - f * l * s - g * j * t + f * k * t, c[12] = h * k * n - g * l * n - h * j * o + f * l * o + g * j * p - f * k * p, c[1] = l * o * q - k * p * q - l * m * s + i * p * s + k * m * t - i * o * t, c[5] = g * p * q - h * o * q + h * m * s - e * p * s - g * m * t + e * o * t, c[9] = h * k * q - g * l * q - h * i * s + e * l * s + g * i * t - e * k * t, c[13] = g * l * m - h * k * m + h * i * o - e * l * o - g * i * p + e * k * p, c[2] = j * p * q - l * n * q + l * m * r - i * p * r - j * m * t + i * n * t, c[6] = h * n * q - f * p * q - h * m * r + e * p * r + f * m * t - e * n * t, c[10] = f * l * q - h * j * q + h * i * r - e * l * r - f * i * t + e * j * t, c[14] = h * j * m - f * l * m - h * i * n + e * l * n + f * i * p - e * j * p, c[3] = k * n * q - j * o * q - k * m * r + i * o * r + j * m * s - i * n * s, c[7] = f * o * q - g * n * q + g * m * r - e * o * r - f * m * s + e * n * s, c[11] = g * j * q - f * k * q - g * i * r + e * k * r + f * i * s - e * j * s, c[15] = f * k * m - g * j * m + g * i * n - e * k * n - f * i * o + e * j * o;
            var u = e * c[0] + i * c[4] + m * c[8] + q * c[12];
            if (0 === u) {
                var v = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";
                if (b) throw new Error(v);
                return console.warn(v), this.identity(), this
            }
            return this.multiplyScalar(1 / u), this
        },
        scale: function(a) {
            var b = this.elements,
                c = a.x,
                d = a.y,
                e = a.z;
            return b[0] *= c, b[4] *= d, b[8] *= e, b[1] *= c, b[5] *= d, b[9] *= e, b[2] *= c, b[6] *= d, b[10] *= e, b[3] *= c, b[7] *= d, b[11] *= e, this
        },
        getMaxScaleOnAxis: function() {
            var a = this.elements,
                b = a[0] * a[0] + a[1] * a[1] + a[2] * a[2],
                c = a[4] * a[4] + a[5] * a[5] + a[6] * a[6],
                d = a[8] * a[8] + a[9] * a[9] + a[10] * a[10];
            return Math.sqrt(Math.max(b, c, d))
        },
        makeTranslation: function(a, b, c) {
            return this.set(1, 0, 0, a, 0, 1, 0, b, 0, 0, 1, c, 0, 0, 0, 1), this
        },
        makeRotationX: function(a) {
            var b = Math.cos(a),
                c = Math.sin(a);
            return this.set(1, 0, 0, 0, 0, b, -c, 0, 0, c, b, 0, 0, 0, 0, 1), this
        },
        makeRotationY: function(a) {
            var b = Math.cos(a),
                c = Math.sin(a);
            return this.set(b, 0, c, 0, 0, 1, 0, 0, -c, 0, b, 0, 0, 0, 0, 1), this
        },
        makeRotationZ: function(a) {
            var b = Math.cos(a),
                c = Math.sin(a);
            return this.set(b, -c, 0, 0, c, b, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        },
        makeRotationAxis: function(a, b) {
            // Based on http://www.gamedev.net/reference/articles/article1199.asp
            var c = Math.cos(b),
                d = Math.sin(b),
                e = 1 - c,
                f = a.x,
                g = a.y,
                h = a.z,
                i = e * f,
                j = e * g;
            return this.set(i * f + c, i * g - d * h, i * h + d * g, 0, i * g + d * h, j * g + c, j * h - d * f, 0, i * h - d * g, j * h + d * f, e * h * h + c, 0, 0, 0, 0, 1), this
        },
        makeScale: function(a, b, c) {
            return this.set(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, 0, 1), this
        },
        compose: function(a, b, c) {
            return this.makeRotationFromQuaternion(b), this.scale(c), this.setPosition(a), this
        },
        decompose: function() {
            var a, b;
            return function(c, d, e) {
                void 0 === a && (a = new THREE.Vector3), void 0 === b && (b = new THREE.Matrix4);
                var f = this.elements,
                    g = a.set(f[0], f[1], f[2]).length(),
                    h = a.set(f[4], f[5], f[6]).length(),
                    i = a.set(f[8], f[9], f[10]).length(),
                    j = this.determinant();
                0 > j && (g = -g), c.x = f[12], c.y = f[13], c.z = f[14],
                    // scale the rotation part
                    b.elements.set(this.elements); // at this point matrix is incomplete so we can't use .copy()
                var k = 1 / g,
                    l = 1 / h,
                    m = 1 / i;
                return b.elements[0] *= k, b.elements[1] *= k, b.elements[2] *= k, b.elements[4] *= l, b.elements[5] *= l, b.elements[6] *= l, b.elements[8] *= m, b.elements[9] *= m, b.elements[10] *= m, d.setFromRotationMatrix(b), e.x = g, e.y = h, e.z = i, this
            }
        }(),
        makeFrustum: function(a, b, c, d, e, f) {
            var g = this.elements,
                h = 2 * e / (b - a),
                i = 2 * e / (d - c),
                j = (b + a) / (b - a),
                k = (d + c) / (d - c),
                l = -(f + e) / (f - e),
                m = -2 * f * e / (f - e);
            return g[0] = h, g[4] = 0, g[8] = j, g[12] = 0, g[1] = 0, g[5] = i, g[9] = k, g[13] = 0, g[2] = 0, g[6] = 0, g[10] = l, g[14] = m, g[3] = 0, g[7] = 0, g[11] = -1, g[15] = 0, this
        },
        makePerspective: function(a, b, c, d) {
            var e = c * Math.tan(THREE.Math.degToRad(.5 * a)),
                f = -e,
                g = f * b,
                h = e * b;
            return this.makeFrustum(g, h, f, e, c, d)
        },
        makeOrthographic: function(a, b, c, d, e, f) {
            var g = this.elements,
                h = b - a,
                i = c - d,
                j = f - e,
                k = (b + a) / h,
                l = (c + d) / i,
                m = (f + e) / j;
            return g[0] = 2 / h, g[4] = 0, g[8] = 0, g[12] = -k, g[1] = 0, g[5] = 2 / i, g[9] = 0, g[13] = -l, g[2] = 0, g[6] = 0, g[10] = -2 / j, g[14] = -m, g[3] = 0, g[7] = 0, g[11] = 0, g[15] = 1, this
        },
        equals: function(a) {
            for (var b = this.elements, c = a.elements, d = 0; 16 > d; d++)
                if (b[d] !== c[d]) return !1;
            return !0
        },
        fromArray: function(a) {
            return this.elements.set(a), this
        },
        toArray: function() {
            var a = this.elements;
            return [a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]]
        }
    },
    // File:src/math/Ray.js
    /**
     * @author bhouston / http://clara.io
     */
    THREE.Ray = function(a, b) {
        this.origin = void 0 !== a ? a : new THREE.Vector3, this.direction = void 0 !== b ? b : new THREE.Vector3
    }, THREE.Ray.prototype = {
        constructor: THREE.Ray,
        set: function(a, b) {
            return this.origin.copy(a), this.direction.copy(b), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(a) {
            return this.origin.copy(a.origin), this.direction.copy(a.direction), this
        },
        at: function(a, b) {
            var c = b || new THREE.Vector3;
            return c.copy(this.direction).multiplyScalar(a).add(this.origin)
        },
        lookAt: function(a) {
            this.direction.copy(a).sub(this.origin).normalize()
        },
        recast: function() {
            var a = new THREE.Vector3;
            return function(b) {
                return this.origin.copy(this.at(b, a)), this
            }
        }(),
        closestPointToPoint: function(a, b) {
            var c = b || new THREE.Vector3;
            c.subVectors(a, this.origin);
            var d = c.dot(this.direction);
            return 0 > d ? c.copy(this.origin) : c.copy(this.direction).multiplyScalar(d).add(this.origin)
        },
        distanceToPoint: function(a) {
            return Math.sqrt(this.distanceSqToPoint(a))
        },
        distanceSqToPoint: function() {
            var a = new THREE.Vector3;
            return function(b) {
                var c = a.subVectors(b, this.origin).dot(this.direction);
                // point behind the ray
                // point behind the ray
                return 0 > c ? this.origin.distanceToSquared(b) : (a.copy(this.direction).multiplyScalar(c).add(this.origin), a.distanceToSquared(b))
            }
        }(),
        distanceSqToSegment: function() {
            var a = new THREE.Vector3,
                b = new THREE.Vector3,
                c = new THREE.Vector3;
            return function(d, e, f, g) {
                // from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp
                // It returns the min distance between the ray and the segment
                // defined by v0 and v1
                // It can also set two optional targets :
                // - The closest point on the ray
                // - The closest point on the segment
                a.copy(d).add(e).multiplyScalar(.5), b.copy(e).sub(d).normalize(), c.copy(this.origin).sub(a);
                var h, i, j, k, l = .5 * d.distanceTo(e),
                    m = -this.direction.dot(b),
                    n = c.dot(this.direction),
                    o = -c.dot(b),
                    p = c.lengthSq(),
                    q = Math.abs(1 - m * m);
                if (q > 0)
                    if (h = m * o - n, i = m * n - o, k = l * q, h >= 0)
                        if (i >= -k)
                            if (k >= i) {
                                // region 0
                                // Minimum at interior points of ray and segment.
                                var r = 1 / q;
                                h *= r, i *= r, j = h * (h + m * i + 2 * n) + i * (m * h + i + 2 * o) + p
                            } else i = l, h = Math.max(0, -(m * i + n)), j = -h * h + i * (i + 2 * o) + p;
                else i = -l, h = Math.max(0, -(m * i + n)), j = -h * h + i * (i + 2 * o) + p;
                else -k >= i ? (h = Math.max(0, -(-m * l + n)), i = h > 0 ? -l : Math.min(Math.max(-l, -o), l), j = -h * h + i * (i + 2 * o) + p) : k >= i ? (h = 0, i = Math.min(Math.max(-l, -o), l), j = i * (i + 2 * o) + p) : (h = Math.max(0, -(m * l + n)), i = h > 0 ? l : Math.min(Math.max(-l, -o), l), j = -h * h + i * (i + 2 * o) + p);
                else i = m > 0 ? -l : l, h = Math.max(0, -(m * i + n)), j = -h * h + i * (i + 2 * o) + p;
                return f && f.copy(this.direction).multiplyScalar(h).add(this.origin), g && g.copy(b).multiplyScalar(i).add(a), j
            }
        }(),
        intersectSphere: function() {
            var a = new THREE.Vector3;
            return function(b, c) {
                a.subVectors(b.center, this.origin);
                var d = a.dot(this.direction),
                    e = a.dot(a) - d * d,
                    f = b.radius * b.radius;
                if (e > f) return null;
                var g = Math.sqrt(f - e),
                    h = d - g,
                    i = d + g;
                // test to see if both t0 and t1 are behind the ray - if so, return null
                // test to see if both t0 and t1 are behind the ray - if so, return null
                // test to see if t0 is behind the ray:
                // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
                // in order to always return an intersect point that is in front of the ray.
                return 0 > h && 0 > i ? null : 0 > h ? this.at(i, c) : this.at(h, c)
            }
        }(),
        intersectsSphere: function(a) {
            return this.distanceToPoint(a.center) <= a.radius
        },
        distanceToPlane: function(a) {
            var b = a.normal.dot(this.direction);
            if (0 === b)
            // line is coplanar, return origin
            // line is coplanar, return origin
                return 0 === a.distanceToPoint(this.origin) ? 0 : null;
            var c = -(this.origin.dot(a.normal) + a.constant) / b;
            // Return if the ray never intersects the plane
            return c >= 0 ? c : null
        },
        intersectPlane: function(a, b) {
            var c = this.distanceToPlane(a);
            return null === c ? null : this.at(c, b)
        },
        intersectsPlane: function(a) {
            // check if the ray lies on the plane first
            var b = a.distanceToPoint(this.origin);
            if (0 === b) return !0;
            var c = a.normal.dot(this.direction);
            return 0 > c * b
        },
        intersectBox: function(a, b) {
            var c, d, e, f, g, h, i = 1 / this.direction.x,
                j = 1 / this.direction.y,
                k = 1 / this.direction.z,
                l = this.origin;
            // These lines also handle the case where tmin or tmax is NaN
            // (result of 0 * Infinity). x !== x returns true if x is NaN
            //return point closest to the ray (positive side)
            return i >= 0 ? (c = (a.min.x - l.x) * i, d = (a.max.x - l.x) * i) : (c = (a.max.x - l.x) * i, d = (a.min.x - l.x) * i), j >= 0 ? (e = (a.min.y - l.y) * j, f = (a.max.y - l.y) * j) : (e = (a.max.y - l.y) * j, f = (a.min.y - l.y) * j), c > f || e > d ? null : ((e > c || c !== c) && (c = e), (d > f || d !== d) && (d = f), k >= 0 ? (g = (a.min.z - l.z) * k, h = (a.max.z - l.z) * k) : (g = (a.max.z - l.z) * k, h = (a.min.z - l.z) * k), c > h || g > d ? null : ((g > c || c !== c) && (c = g), (d > h || d !== d) && (d = h), 0 > d ? null : this.at(c >= 0 ? c : d, b)))
        },
        intersectsBox: function() {
            var a = new THREE.Vector3;
            return function(b) {
                return null !== this.intersectBox(b, a)
            }
        }(),
        intersectTriangle: function() {
            // Compute the offset origin, edges, and normal.
            var a = new THREE.Vector3,
                b = new THREE.Vector3,
                c = new THREE.Vector3,
                d = new THREE.Vector3;
            return function(e, f, g, h, i) {
                // from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp
                b.subVectors(f, e), c.subVectors(g, e), d.crossVectors(b, c);
                // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
                // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
                //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
                //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
                //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
                var j, k = this.direction.dot(d);
                if (k > 0) {
                    if (h) return null;
                    j = 1
                } else {
                    if (!(0 > k)) return null;
                    j = -1, k = -k
                }
                a.subVectors(this.origin, e);
                var l = j * this.direction.dot(c.crossVectors(a, c));
                // b1 < 0, no intersection
                if (0 > l) return null;
                var m = j * this.direction.dot(b.cross(a));
                // b2 < 0, no intersection
                if (0 > m) return null;
                // b1+b2 > 1, no intersection
                if (l + m > k) return null;
                // Line intersects triangle, check if ray does.
                var n = -j * a.dot(d);
                // t < 0, no intersection
                // t < 0, no intersection
                return 0 > n ? null : this.at(n / k, i)
            }
        }(),
        applyMatrix4: function(a) {
            return this.direction.add(this.origin).applyMatrix4(a), this.origin.applyMatrix4(a), this.direction.sub(this.origin), this.direction.normalize(), this
        },
        equals: function(a) {
            return a.origin.equals(this.origin) && a.direction.equals(this.direction)
        }
    },
    // File:src/math/Sphere.js
    /**
     * @author bhouston / http://clara.io
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.Sphere = function(a, b) {
        this.center = void 0 !== a ? a : new THREE.Vector3, this.radius = void 0 !== b ? b : 0
    }, THREE.Sphere.prototype = {
        constructor: THREE.Sphere,
        set: function(a, b) {
            return this.center.copy(a), this.radius = b, this
        },
        setFromPoints: function() {
            var a = new THREE.Box3;
            return function(b, c) {
                var d = this.center;
                void 0 !== c ? d.copy(c) : a.setFromPoints(b).center(d);
                for (var e = 0, f = 0, g = b.length; g > f; f++) e = Math.max(e, d.distanceToSquared(b[f]));
                return this.radius = Math.sqrt(e), this
            }
        }(),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(a) {
            return this.center.copy(a.center), this.radius = a.radius, this
        },
        empty: function() {
            return this.radius <= 0
        },
        containsPoint: function(a) {
            return a.distanceToSquared(this.center) <= this.radius * this.radius
        },
        distanceToPoint: function(a) {
            return a.distanceTo(this.center) - this.radius
        },
        intersectsSphere: function(a) {
            var b = this.radius + a.radius;
            return a.center.distanceToSquared(this.center) <= b * b
        },
        intersectsBox: function(a) {
            return a.intersectsSphere(this)
        },
        intersectsPlane: function(a) {
            // We use the following equation to compute the signed distance from
            // the center of the sphere to the plane.
            //
            // distance = q * n - d
            //
            // If this distance is greater than the radius of the sphere,
            // then there is no intersection.
            return Math.abs(this.center.dot(a.normal) - a.constant) <= this.radius
        },
        clampPoint: function(a, b) {
            var c = this.center.distanceToSquared(a),
                d = b || new THREE.Vector3;
            return d.copy(a), c > this.radius * this.radius && (d.sub(this.center).normalize(), d.multiplyScalar(this.radius).add(this.center)), d
        },
        getBoundingBox: function(a) {
            var b = a || new THREE.Box3;
            return b.set(this.center, this.center), b.expandByScalar(this.radius), b
        },
        applyMatrix4: function(a) {
            return this.center.applyMatrix4(a), this.radius = this.radius * a.getMaxScaleOnAxis(), this
        },
        translate: function(a) {
            return this.center.add(a), this
        },
        equals: function(a) {
            return a.center.equals(this.center) && a.radius === this.radius
        }
    },
    // File:src/math/Frustum.js
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     * @author bhouston / http://clara.io
     */
    THREE.Frustum = function(a, b, c, d, e, f) {
        this.planes = [void 0 !== a ? a : new THREE.Plane, void 0 !== b ? b : new THREE.Plane, void 0 !== c ? c : new THREE.Plane, void 0 !== d ? d : new THREE.Plane, void 0 !== e ? e : new THREE.Plane, void 0 !== f ? f : new THREE.Plane]
    }, THREE.Frustum.prototype = {
        constructor: THREE.Frustum,
        set: function(a, b, c, d, e, f) {
            var g = this.planes;
            return g[0].copy(a), g[1].copy(b), g[2].copy(c), g[3].copy(d), g[4].copy(e), g[5].copy(f), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(a) {
            for (var b = this.planes, c = 0; 6 > c; c++) b[c].copy(a.planes[c]);
            return this
        },
        setFromMatrix: function(a) {
            var b = this.planes,
                c = a.elements,
                d = c[0],
                e = c[1],
                f = c[2],
                g = c[3],
                h = c[4],
                i = c[5],
                j = c[6],
                k = c[7],
                l = c[8],
                m = c[9],
                n = c[10],
                o = c[11],
                p = c[12],
                q = c[13],
                r = c[14],
                s = c[15];
            return b[0].setComponents(g - d, k - h, o - l, s - p).normalize(), b[1].setComponents(g + d, k + h, o + l, s + p).normalize(), b[2].setComponents(g + e, k + i, o + m, s + q).normalize(), b[3].setComponents(g - e, k - i, o - m, s - q).normalize(), b[4].setComponents(g - f, k - j, o - n, s - r).normalize(), b[5].setComponents(g + f, k + j, o + n, s + r).normalize(), this
        },
        intersectsObject: function() {
            var a = new THREE.Sphere;
            return function(b) {
                var c = b.geometry;
                return null === c.boundingSphere && c.computeBoundingSphere(), a.copy(c.boundingSphere), a.applyMatrix4(b.matrixWorld), this.intersectsSphere(a)
            }
        }(),
        intersectsSphere: function(a) {
            for (var b = this.planes, c = a.center, d = -a.radius, e = 0; 6 > e; e++) {
                var f = b[e].distanceToPoint(c);
                if (d > f) return !1
            }
            return !0
        },
        intersectsBox: function() {
            var a = new THREE.Vector3,
                b = new THREE.Vector3;
            return function(c) {
                for (var d = this.planes, e = 0; 6 > e; e++) {
                    var f = d[e];
                    a.x = f.normal.x > 0 ? c.min.x : c.max.x, b.x = f.normal.x > 0 ? c.max.x : c.min.x, a.y = f.normal.y > 0 ? c.min.y : c.max.y, b.y = f.normal.y > 0 ? c.max.y : c.min.y, a.z = f.normal.z > 0 ? c.min.z : c.max.z, b.z = f.normal.z > 0 ? c.max.z : c.min.z;
                    var g = f.distanceToPoint(a),
                        h = f.distanceToPoint(b);
                    // if both outside plane, no intersection
                    if (0 > g && 0 > h) return !1
                }
                return !0
            }
        }(),
        containsPoint: function(a) {
            for (var b = this.planes, c = 0; 6 > c; c++)
                if (b[c].distanceToPoint(a) < 0) return !1;
            return !0
        }
    },
    // File:src/math/Plane.js
    /**
     * @author bhouston / http://clara.io
     */
    THREE.Plane = function(a, b) {
        this.normal = void 0 !== a ? a : new THREE.Vector3(1, 0, 0), this.constant = void 0 !== b ? b : 0
    }, THREE.Plane.prototype = {
        constructor: THREE.Plane,
        set: function(a, b) {
            return this.normal.copy(a), this.constant = b, this
        },
        setComponents: function(a, b, c, d) {
            return this.normal.set(a, b, c), this.constant = d, this
        },
        setFromNormalAndCoplanarPoint: function(a, b) { // must be this.normal, not normal, as this.normal is normalized
            return this.normal.copy(a), this.constant = -b.dot(this.normal), this
        },
        setFromCoplanarPoints: function() {
            var a = new THREE.Vector3,
                b = new THREE.Vector3;
            return function(c, d, e) {
                var f = a.subVectors(e, d).cross(b.subVectors(c, d)).normalize();
                // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
                return this.setFromNormalAndCoplanarPoint(f, c), this
            }
        }(),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(a) {
            return this.normal.copy(a.normal), this.constant = a.constant, this
        },
        normalize: function() {
            // Note: will lead to a divide by zero if the plane is invalid.
            var a = 1 / this.normal.length();
            return this.normal.multiplyScalar(a), this.constant *= a, this
        },
        negate: function() {
            return this.constant *= -1, this.normal.negate(), this
        },
        distanceToPoint: function(a) {
            return this.normal.dot(a) + this.constant
        },
        distanceToSphere: function(a) {
            return this.distanceToPoint(a.center) - a.radius
        },
        projectPoint: function(a, b) {
            return this.orthoPoint(a, b).sub(a).negate()
        },
        orthoPoint: function(a, b) {
            var c = this.distanceToPoint(a),
                d = b || new THREE.Vector3;
            return d.copy(this.normal).multiplyScalar(c)
        },
        intersectLine: function() {
            var a = new THREE.Vector3;
            return function(b, c) {
                var d = c || new THREE.Vector3,
                    e = b.delta(a),
                    f = this.normal.dot(e);
                if (0 !== f) {
                    var g = -(b.start.dot(this.normal) + this.constant) / f;
                    if (!(0 > g || g > 1)) return d.copy(e).multiplyScalar(g).add(b.start)
                } else
                // line is coplanar, return origin
                if (0 === this.distanceToPoint(b.start)) return d.copy(b.start)
            }
        }(),
        intersectsLine: function(a) {
            // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
            var b = this.distanceToPoint(a.start),
                c = this.distanceToPoint(a.end);
            return 0 > b && c > 0 || 0 > c && b > 0
        },
        intersectsBox: function(a) {
            return a.intersectsPlane(this)
        },
        intersectsSphere: function(a) {
            return a.intersectsPlane(this)
        },
        coplanarPoint: function(a) {
            var b = a || new THREE.Vector3;
            return b.copy(this.normal).multiplyScalar(-this.constant)
        },
        applyMatrix4: function() {
            var a = new THREE.Vector3,
                b = new THREE.Vector3,
                c = new THREE.Matrix3;
            return function(d, e) {
                // compute new normal based on theory here:
                // http://www.songho.ca/opengl/gl_normaltransform.html
                var f = e || c.getNormalMatrix(d),
                    g = a.copy(this.normal).applyMatrix3(f),
                    h = this.coplanarPoint(b);
                return h.applyMatrix4(d), this.setFromNormalAndCoplanarPoint(g, h), this
            }
        }(),
        translate: function(a) {
            return this.constant = this.constant - a.dot(this.normal), this
        },
        equals: function(a) {
            return a.normal.equals(this.normal) && a.constant === this.constant
        }
    },
    // File:src/math/Math.js
    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.Math = {
        generateUUID: function() {
            // http://www.broofa.com/Tools/Math.uuid.htm
            var a, b = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),
                c = new Array(36),
                d = 0;
            return function() {
                for (var e = 0; 36 > e; e++) 8 === e || 13 === e || 18 === e || 23 === e ? c[e] = "-" : 14 === e ? c[e] = "4" : (2 >= d && (d = 33554432 + 16777216 * Math.random() | 0), a = 15 & d, d >>= 4, c[e] = b[19 === e ? 3 & a | 8 : a]);
                return c.join("")
            }
        }(),
        clamp: function(a, b, c) {
            return Math.max(b, Math.min(c, a))
        },
        // compute euclidian modulo of m % n
        // https://en.wikipedia.org/wiki/Modulo_operation
        euclideanModulo: function(a, b) {
            return (a % b + b) % b
        },
        // Linear mapping from range <a1, a2> to range <b1, b2>
        mapLinear: function(a, b, c, d, e) {
            return d + (a - b) * (e - d) / (c - b)
        },
        // http://en.wikipedia.org/wiki/Smoothstep
        smoothstep: function(a, b, c) {
            return b >= a ? 0 : a >= c ? 1 : (a = (a - b) / (c - b), a * a * (3 - 2 * a))
        },
        smootherstep: function(a, b, c) {
            return b >= a ? 0 : a >= c ? 1 : (a = (a - b) / (c - b), a * a * a * (a * (6 * a - 15) + 10))
        },
        random16: function() {
            return console.warn("THREE.Math.random16() has been deprecated. Use Math.random() instead."), Math.random()
        },
        // Random integer from <low, high> interval
        randInt: function(a, b) {
            return a + Math.floor(Math.random() * (b - a + 1))
        },
        // Random float from <low, high> interval
        randFloat: function(a, b) {
            return a + Math.random() * (b - a)
        },
        // Random float from <-range/2, range/2> interval
        randFloatSpread: function(a) {
            return a * (.5 - Math.random())
        },
        degToRad: function() {
            var a = Math.PI / 180;
            return function(b) {
                return b * a
            }
        }(),
        radToDeg: function() {
            var a = 180 / Math.PI;
            return function(b) {
                return b * a
            }
        }(),
        isPowerOfTwo: function(a) {
            return 0 === (a & a - 1) && 0 !== a
        },
        nearestPowerOfTwo: function(a) {
            return Math.pow(2, Math.round(Math.log(a) / Math.LN2))
        },
        nextPowerOfTwo: function(a) {
            return a--, a |= a >> 1, a |= a >> 2, a |= a >> 4, a |= a >> 8, a |= a >> 16, a++, a
        }
    },
    // File:src/math/Spline.js
    /**
     * Spline from Tween.js, slightly optimized (and trashed)
     * http://sole.github.com/tween.js/examples/05_spline.html
     *
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */
    THREE.Spline = function(a) {
        // Catmull-Rom
        function b(a, b, c, d, e, f, g) {
            var h = .5 * (c - a),
                i = .5 * (d - b);
            return (2 * (b - c) + h + i) * g + (-3 * (b - c) - 2 * h - i) * f + h * e + b
        }
        this.points = a;
        var c, d, e, f, g, h, i, j, k, l = [],
            m = {
                x: 0,
                y: 0,
                z: 0
            };
        this.initFromArray = function(a) {
                this.points = [];
                for (var b = 0; b < a.length; b++) this.points[b] = {
                    x: a[b][0],
                    y: a[b][1],
                    z: a[b][2]
                }
            }, this.getPoint = function(a) {
                return c = (this.points.length - 1) * a, d = Math.floor(c), e = c - d, l[0] = 0 === d ? d : d - 1, l[1] = d, l[2] = d > this.points.length - 2 ? this.points.length - 1 : d + 1, l[3] = d > this.points.length - 3 ? this.points.length - 1 : d + 2, h = this.points[l[0]], i = this.points[l[1]], j = this.points[l[2]], k = this.points[l[3]], f = e * e, g = e * f, m.x = b(h.x, i.x, j.x, k.x, e, f, g), m.y = b(h.y, i.y, j.y, k.y, e, f, g), m.z = b(h.z, i.z, j.z, k.z, e, f, g), m
            }, this.getControlPointsArray = function() {
                var a, b, c = this.points.length,
                    d = [];
                for (a = 0; c > a; a++) b = this.points[a], d[a] = [b.x, b.y, b.z];
                return d
            },
            // approximate length by summing linear segments
            this.getLength = function(a) {
                var b, c, d, e, f = 0,
                    g = 0,
                    h = 0,
                    i = new THREE.Vector3,
                    j = new THREE.Vector3,
                    k = [],
                    l = 0;
                for (
                    // first point has 0 length
                    k[0] = 0, a || (a = 100), d = this.points.length * a, i.copy(this.points[0]), b = 1; d > b; b++) c = b / d, e = this.getPoint(c), j.copy(e), l += j.distanceTo(i), i.copy(e), f = (this.points.length - 1) * c, g = Math.floor(f), g !== h && (k[g] = l, h = g);
                // last point ends with total length
                return k[k.length] = l, {
                    chunks: k,
                    total: l
                }
            }, this.reparametrizeByArcLength = function(a) {
                var b, c, d, e, f, g, h, i, j = [],
                    k = new THREE.Vector3,
                    l = this.getLength();
                for (j.push(k.copy(this.points[0]).clone()), b = 1; b < this.points.length; b++) {
                    for (g = l.chunks[b] - l.chunks[b - 1], h = Math.ceil(a * g / l.total), e = (b - 1) / (this.points.length - 1), f = b / (this.points.length - 1), c = 1; h - 1 > c; c++) d = e + c * (1 / h) * (f - e), i = this.getPoint(d), j.push(k.copy(i).clone());
                    j.push(k.copy(this.points[b]).clone())
                }
                this.points = j
            }
    },
    // File:src/math/Triangle.js
    /**
     * @author bhouston / http://clara.io
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.Triangle = function(a, b, c) {
        this.a = void 0 !== a ? a : new THREE.Vector3, this.b = void 0 !== b ? b : new THREE.Vector3, this.c = void 0 !== c ? c : new THREE.Vector3
    }, THREE.Triangle.normal = function() {
        var a = new THREE.Vector3;
        return function(b, c, d, e) {
            var f = e || new THREE.Vector3;
            f.subVectors(d, c), a.subVectors(b, c), f.cross(a);
            var g = f.lengthSq();
            return g > 0 ? f.multiplyScalar(1 / Math.sqrt(g)) : f.set(0, 0, 0)
        }
    }(),
    // static/instance method to calculate barycentric coordinates
    // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
    THREE.Triangle.barycoordFromPoint = function() {
        var a = new THREE.Vector3,
            b = new THREE.Vector3,
            c = new THREE.Vector3;
        return function(d, e, f, g, h) {
            a.subVectors(g, e), b.subVectors(f, e), c.subVectors(d, e);
            var i = a.dot(a),
                j = a.dot(b),
                k = a.dot(c),
                l = b.dot(b),
                m = b.dot(c),
                n = i * l - j * j,
                o = h || new THREE.Vector3;
            // collinear or singular triangle
            if (0 === n)
            // arbitrary location outside of triangle?
            // not sure if this is the best idea, maybe should be returning undefined
                return o.set(-2, -1, -1);
            var p = 1 / n,
                q = (l * k - j * m) * p,
                r = (i * m - j * k) * p;
            // barycentric coordinates must always sum to 1
            return o.set(1 - q - r, r, q)
        }
    }(), THREE.Triangle.containsPoint = function() {
        var a = new THREE.Vector3;
        return function(b, c, d, e) {
            var f = THREE.Triangle.barycoordFromPoint(b, c, d, e, a);
            return f.x >= 0 && f.y >= 0 && f.x + f.y <= 1
        }
    }(), THREE.Triangle.prototype = {
        constructor: THREE.Triangle,
        set: function(a, b, c) {
            return this.a.copy(a), this.b.copy(b), this.c.copy(c), this
        },
        setFromPointsAndIndices: function(a, b, c, d) {
            return this.a.copy(a[b]), this.b.copy(a[c]), this.c.copy(a[d]), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(a) {
            return this.a.copy(a.a), this.b.copy(a.b), this.c.copy(a.c), this
        },
        area: function() {
            var a = new THREE.Vector3,
                b = new THREE.Vector3;
            return function() {
                return a.subVectors(this.c, this.b), b.subVectors(this.a, this.b), .5 * a.cross(b).length()
            }
        }(),
        midpoint: function(a) {
            var b = a || new THREE.Vector3;
            return b.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
        },
        normal: function(a) {
            return THREE.Triangle.normal(this.a, this.b, this.c, a)
        },
        plane: function(a) {
            var b = a || new THREE.Plane;
            return b.setFromCoplanarPoints(this.a, this.b, this.c)
        },
        barycoordFromPoint: function(a, b) {
            return THREE.Triangle.barycoordFromPoint(a, this.a, this.b, this.c, b)
        },
        containsPoint: function(a) {
            return THREE.Triangle.containsPoint(a, this.a, this.b, this.c)
        },
        equals: function(a) {
            return a.a.equals(this.a) && a.b.equals(this.b) && a.c.equals(this.c)
        }
    },
    // File:src/math/Interpolant.js
    /**
     * Abstract base class of interpolants over parametric samples.
     *
     * The parameter domain is one dimensional, typically the time or a path
     * along a curve defined by the data.
     *
     * The sample values can have any dimensionality and derived classes may
     * apply special interpretations to the data.
     *
     * This class provides the interval seek in a Template Method, deferring
     * the actual interpolation to derived classes.
     *
     * Time complexity is O(1) for linear access crossing at most two points
     * and O(log N) for random access, where N is the number of positions.
     *
     * References:
     *
     * 		http://www.oodesign.com/template-method-pattern.html
     *
     * @author tschw
     */
    THREE.Interpolant = function(a, b, c, d) {
        this.parameterPositions = a, this._cachedIndex = 0, this.resultBuffer = void 0 !== d ? d : new b.constructor(c), this.sampleValues = b, this.valueSize = c
    }, THREE.Interpolant.prototype = {
        constructor: THREE.Interpolant,
        evaluate: function(a) {
            var b = this.parameterPositions,
                c = this._cachedIndex,
                d = b[c],
                e = b[c - 1];
            a: {
                    b: {
                        var f;
                        c: {
                                //- See http://jsperf.com/comparison-to-undefined/3
                                //- slower code:
                                //-
                                //- 				if ( t >= t1 || t1 === undefined ) {
                                d: if (!(d > a)) {
                                        for (var g = c + 2;;) {
                                            if (void 0 === d) {
                                                if (e > a) break d;
                                                // after end
                                                return c = b.length, this._cachedIndex = c, this.afterEnd_(c - 1, a, e)
                                            }
                                            if (c === g) break;
                                            if (e = d, d = b[++c], d > a)
                                            // we have arrived at the sought interval
                                                break b
                                        }
                                        // prepare binary search on the right side of the index
                                        f = b.length;
                                        break c
                                    }
                                    //- slower code:
                                    //-					if ( t < t0 || t0 === undefined ) {
                                    {
                                        if (a >= e)
                                        // the interval is valid
                                            break a;
                                        // looping?
                                        var h = b[1];
                                        h > a && (c = 2, e = h);
                                        // linear reverse scan
                                        for (var g = c - 2;;) {
                                            if (void 0 === e)
                                            // before start
                                                return this._cachedIndex = 0, this.beforeStart_(0, a, d);
                                            if (c === g) break;
                                            if (d = e, e = b[--c - 1], a >= e)
                                            // we have arrived at the sought interval
                                                break b
                                        }
                                        f = c, c = 0
                                    }
                            } // linear scan
                            // binary search
                        for (; f > c;) {
                            var i = c + f >>> 1;
                            a < b[i] ? f = i : c = i + 1
                        }
                        // check boundary cases, again
                        if (d = b[c], e = b[c - 1], void 0 === e) return this._cachedIndex = 0, this.beforeStart_(0, a, d);
                        if (void 0 === d) return c = b.length, this._cachedIndex = c, this.afterEnd_(c - 1, e, a)
                    } // seek
                    this._cachedIndex = c,
                    this.intervalChanged_(c, e, d)
                } // validate_interval
            return this.interpolate_(c, e, a, d)
        },
        settings: null, // optional, subclass-specific settings structure
        // Note: The indirection allows central control of many interpolants.
        // --- Protected interface
        DefaultSettings_: {},
        getSettings_: function() {
            return this.settings || this.DefaultSettings_
        },
        copySampleValue_: function(a) {
            for (var b = this.resultBuffer, c = this.sampleValues, d = this.valueSize, e = a * d, f = 0; f !== d; ++f) b[f] = c[e + f];
            return b
        },
        // Template methods for derived classes:
        interpolate_: function(a, b, c, d) {
            throw new Error("call to abstract method")
        },
        intervalChanged_: function(a, b, c) {}
    }, Object.assign(THREE.Interpolant.prototype, {
        beforeStart_: //( 0, t, t0 ), returns this.resultBuffer
            THREE.Interpolant.prototype.copySampleValue_,
        afterEnd_: //( N-1, tN-1, t ), returns this.resultBuffer
            THREE.Interpolant.prototype.copySampleValue_
    }),
    // File:src/math/interpolants/CubicInterpolant.js
    /**
     * Fast and simple cubic spline interpolant.
     *
     * It was derived from a Hermitian construction setting the first derivative
     * at each sample position to the linear slope between neighboring positions
     * over their parameter interval.
     *
     * @author tschw
     */
    THREE.CubicInterpolant = function(a, b, c, d) {
        THREE.Interpolant.call(this, a, b, c, d), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0
    }, THREE.CubicInterpolant.prototype = Object.assign(Object.create(THREE.Interpolant.prototype), {
        constructor: THREE.CubicInterpolant,
        DefaultSettings_: {
            endingStart: THREE.ZeroCurvatureEnding,
            endingEnd: THREE.ZeroCurvatureEnding
        },
        intervalChanged_: function(a, b, c) {
            var d = this.parameterPositions,
                e = a - 2,
                f = a + 1,
                g = d[e],
                h = d[f];
            if (void 0 === g) switch (this.getSettings_().endingStart) {
                case THREE.ZeroSlopeEnding:
                    // f'(t0) = 0
                    e = a, g = 2 * b - c;
                    break;
                case THREE.WrapAroundEnding:
                    // use the other end of the curve
                    e = d.length - 2, g = b + d[e] - d[e + 1];
                    break;
                default: // ZeroCurvatureEnding
                    // f''(t0) = 0 a.k.a. Natural Spline
                    e = a, g = c
            }
            if (void 0 === h) switch (this.getSettings_().endingEnd) {
                case THREE.ZeroSlopeEnding:
                    // f'(tN) = 0
                    f = a, h = 2 * c - b;
                    break;
                case THREE.WrapAroundEnding:
                    // use the other end of the curve
                    f = 1, h = c + d[1] - d[0];
                    break;
                default: // ZeroCurvatureEnding
                    // f''(tN) = 0, a.k.a. Natural Spline
                    f = a - 1, h = b
            }
            var i = .5 * (c - b),
                j = this.valueSize;
            this._weightPrev = i / (b - g), this._weightNext = i / (h - c), this._offsetPrev = e * j, this._offsetNext = f * j
        },
        interpolate_: function(a, b, c, d) {
            // combine data linearly
            for (var e = this.resultBuffer, f = this.sampleValues, g = this.valueSize, h = a * g, i = h - g, j = this._offsetPrev, k = this._offsetNext, l = this._weightPrev, m = this._weightNext, n = (c - b) / (d - b), o = n * n, p = o * n, q = -l * p + 2 * l * o - l * n, r = (1 + l) * p + (-1.5 - 2 * l) * o + (-.5 + l) * n + 1, s = (-1 - m) * p + (1.5 + m) * o + .5 * n, t = m * p - m * o, u = 0; u !== g; ++u) e[u] = q * f[j + u] + r * f[i + u] + s * f[h + u] + t * f[k + u];
            return e
        }
    }),
    // File:src/math/interpolants/DiscreteInterpolant.js
    /**
     *
     * Interpolant that evaluates to the sample value at the position preceeding
     * the parameter.
     *
     * @author tschw
     */
    THREE.DiscreteInterpolant = function(a, b, c, d) {
        THREE.Interpolant.call(this, a, b, c, d)
    }, THREE.DiscreteInterpolant.prototype = Object.assign(Object.create(THREE.Interpolant.prototype), {
        constructor: THREE.DiscreteInterpolant,
        interpolate_: function(a, b, c, d) {
            return this.copySampleValue_(a - 1)
        }
    }),
    // File:src/math/interpolants/LinearInterpolant.js
    /**
     * @author tschw
     */
    THREE.LinearInterpolant = function(a, b, c, d) {
        THREE.Interpolant.call(this, a, b, c, d)
    }, THREE.LinearInterpolant.prototype = Object.assign(Object.create(THREE.Interpolant.prototype), {
        constructor: THREE.LinearInterpolant,
        interpolate_: function(a, b, c, d) {
            for (var e = this.resultBuffer, f = this.sampleValues, g = this.valueSize, h = a * g, i = h - g, j = (c - b) / (d - b), k = 1 - j, l = 0; l !== g; ++l) e[l] = f[i + l] * k + f[h + l] * j;
            return e
        }
    }),
    // File:src/math/interpolants/QuaternionLinearInterpolant.js
    /**
     * Spherical linear unit quaternion interpolant.
     *
     * @author tschw
     */
    THREE.QuaternionLinearInterpolant = function(a, b, c, d) {
        THREE.Interpolant.call(this, a, b, c, d)
    }, THREE.QuaternionLinearInterpolant.prototype = Object.assign(Object.create(THREE.Interpolant.prototype), {
        constructor: THREE.QuaternionLinearInterpolant,
        interpolate_: function(a, b, c, d) {
            for (var e = this.resultBuffer, f = this.sampleValues, g = this.valueSize, h = a * g, i = (c - b) / (d - b), j = h + g; h !== j; h += 4) THREE.Quaternion.slerpFlat(e, 0, f, h - g, f, h, i);
            return e
        }
    }),
    // File:src/core/Clock.js
    /**
     * @author alteredq / http://alteredqualia.com/
     */
    THREE.Clock = function(a) {
        this.autoStart = void 0 !== a ? a : !0, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
    }, THREE.Clock.prototype = {
        constructor: THREE.Clock,
        start: function() {
            this.startTime = performance.now(), this.oldTime = this.startTime, this.running = !0
        },
        stop: function() {
            this.getElapsedTime(), this.running = !1
        },
        getElapsedTime: function() {
            return this.getDelta(), this.elapsedTime
        },
        getDelta: function() {
            var a = 0;
            if (this.autoStart && !this.running && this.start(), this.running) {
                var b = performance.now();
                a = .001 * (b - this.oldTime), this.oldTime = b, this.elapsedTime += a
            }
            return a
        }
    },
    // File:src/core/EventDispatcher.js
    /**
     * https://github.com/mrdoob/eventdispatcher.js/
     */
    THREE.EventDispatcher = function() {}, THREE.EventDispatcher.prototype = {
        constructor: THREE.EventDispatcher,
        apply: function(a) {
            a.addEventListener = THREE.EventDispatcher.prototype.addEventListener, a.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener, a.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener, a.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent
        },
        addEventListener: function(a, b) {
            void 0 === this._listeners && (this._listeners = {});
            var c = this._listeners;
            void 0 === c[a] && (c[a] = []), -1 === c[a].indexOf(b) && c[a].push(b)
        },
        hasEventListener: function(a, b) {
            if (void 0 === this._listeners) return !1;
            var c = this._listeners;
            return void 0 !== c[a] && -1 !== c[a].indexOf(b)
        },
        removeEventListener: function(a, b) {
            if (void 0 !== this._listeners) {
                var c = this._listeners,
                    d = c[a];
                if (void 0 !== d) {
                    var e = d.indexOf(b); - 1 !== e && d.splice(e, 1)
                }
            }
        },
        dispatchEvent: function(a) {
            if (void 0 !== this._listeners) {
                var b = this._listeners,
                    c = b[a.type];
                if (void 0 !== c) {
                    a.target = this;
                    for (var d = [], e = c.length, f = 0; e > f; f++) d[f] = c[f];
                    for (var f = 0; e > f; f++) d[f].call(this, a)
                }
            }
        }
    },
    // File:src/core/Layers.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.Layers = function() {
        this.mask = 1
    }, THREE.Layers.prototype = {
        constructor: THREE.Layers,
        set: function(a) {
            this.mask = 1 << a
        },
        enable: function(a) {
            this.mask |= 1 << a
        },
        toggle: function(a) {
            this.mask ^= 1 << a
        },
        disable: function(a) {
            this.mask &= ~(1 << a)
        },
        test: function(a) {
            return 0 !== (this.mask & a.mask)
        }
    },
    // File:src/core/Raycaster.js
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author bhouston / http://clara.io/
     * @author stephomi / http://stephaneginier.com/
     */
    function(a) {
        function b(a, b) {
            return a.distance - b.distance
        }

        function c(a, b, d, e) {
            if (a.visible !== !1 && (a.raycast(b, d), e === !0))
                for (var f = a.children, g = 0, h = f.length; h > g; g++) c(f[g], b, d, !0)
        }
        a.Raycaster = function(b, c, d, e) {
                this.ray = new a.Ray(b, c),
                    // direction is assumed to be normalized (for accurate distance calculations)
                    this.near = d || 0, this.far = e || 1 / 0, this.params = {
                        Mesh: {},
                        Line: {},
                        LOD: {},
                        Points: {
                            threshold: 1
                        },
                        Sprite: {}
                    }, Object.defineProperties(this.params, {
                        PointCloud: {
                            get: function() {
                                return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
                            }
                        }
                    })
            },
            //
            a.Raycaster.prototype = {
                constructor: a.Raycaster,
                linePrecision: 1,
                set: function(a, b) {
                    // direction is assumed to be normalized (for accurate distance calculations)
                    this.ray.set(a, b)
                },
                setFromCamera: function(b, c) {
                    c instanceof a.PerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(c.matrixWorld), this.ray.direction.set(b.x, b.y, .5).unproject(c).sub(this.ray.origin).normalize()) : c instanceof a.OrthographicCamera ? (this.ray.origin.set(b.x, b.y, -1).unproject(c), this.ray.direction.set(0, 0, -1).transformDirection(c.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
                },
                intersectObject: function(a, d) {
                    var e = [];
                    return c(a, this, e, d), e.sort(b), e
                },
                intersectObjects: function(a, d) {
                    var e = [];
                    if (Array.isArray(a) === !1) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), e;
                    for (var f = 0, g = a.length; g > f; f++) c(a[f], this, e, d);
                    return e.sort(b), e
                }
            }
    }(THREE),
    // File:src/core/Object3D.js
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author WestLangley / http://github.com/WestLangley
     * @author elephantatwork / www.elephantatwork.ch
     */
    THREE.Object3D = function() {
        function a() {
            e.setFromEuler(d, !1)
        }

        function b() {
            d.setFromQuaternion(e, void 0, !1)
        }
        Object.defineProperty(this, "id", {
            value: THREE.Object3DIdCount++
        }), this.uuid = THREE.Math.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = THREE.Object3D.DefaultUp.clone();
        var c = new THREE.Vector3,
            d = new THREE.Euler,
            e = new THREE.Quaternion,
            f = new THREE.Vector3(1, 1, 1);
        d.onChange(a), e.onChange(b), Object.defineProperties(this, {
            position: {
                enumerable: !0,
                value: c
            },
            rotation: {
                enumerable: !0,
                value: d
            },
            quaternion: {
                enumerable: !0,
                value: e
            },
            scale: {
                enumerable: !0,
                value: f
            },
            modelViewMatrix: {
                value: new THREE.Matrix4
            },
            normalMatrix: {
                value: new THREE.Matrix3
            }
        }), this.rotationAutoUpdate = !0, this.matrix = new THREE.Matrix4, this.matrixWorld = new THREE.Matrix4, this.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new THREE.Layers, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
    }, THREE.Object3D.DefaultUp = new THREE.Vector3(0, 1, 0), THREE.Object3D.DefaultMatrixAutoUpdate = !0, THREE.Object3D.prototype = {
        constructor: THREE.Object3D,
        applyMatrix: function(a) {
            this.matrix.multiplyMatrices(a, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale)
        },
        setRotationFromAxisAngle: function(a, b) {
            // assumes axis is normalized
            this.quaternion.setFromAxisAngle(a, b)
        },
        setRotationFromEuler: function(a) {
            this.quaternion.setFromEuler(a, !0)
        },
        setRotationFromMatrix: function(a) {
            // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
            this.quaternion.setFromRotationMatrix(a)
        },
        setRotationFromQuaternion: function(a) {
            // assumes q is normalized
            this.quaternion.copy(a)
        },
        rotateOnAxis: function() {
            // rotate object on axis in object space
            // axis is assumed to be normalized
            var a = new THREE.Quaternion;
            return function(b, c) {
                return a.setFromAxisAngle(b, c), this.quaternion.multiply(a), this
            }
        }(),
        rotateX: function() {
            var a = new THREE.Vector3(1, 0, 0);
            return function(b) {
                return this.rotateOnAxis(a, b)
            }
        }(),
        rotateY: function() {
            var a = new THREE.Vector3(0, 1, 0);
            return function(b) {
                return this.rotateOnAxis(a, b)
            }
        }(),
        rotateZ: function() {
            var a = new THREE.Vector3(0, 0, 1);
            return function(b) {
                return this.rotateOnAxis(a, b)
            }
        }(),
        translateOnAxis: function() {
            // translate object by distance along axis in object space
            // axis is assumed to be normalized
            var a = new THREE.Vector3;
            return function(b, c) {
                return a.copy(b).applyQuaternion(this.quaternion), this.position.add(a.multiplyScalar(c)), this
            }
        }(),
        translateX: function() {
            var a = new THREE.Vector3(1, 0, 0);
            return function(b) {
                return this.translateOnAxis(a, b)
            }
        }(),
        translateY: function() {
            var a = new THREE.Vector3(0, 1, 0);
            return function(b) {
                return this.translateOnAxis(a, b)
            }
        }(),
        translateZ: function() {
            var a = new THREE.Vector3(0, 0, 1);
            return function(b) {
                return this.translateOnAxis(a, b)
            }
        }(),
        localToWorld: function(a) {
            return a.applyMatrix4(this.matrixWorld)
        },
        worldToLocal: function() {
            var a = new THREE.Matrix4;
            return function(b) {
                return b.applyMatrix4(a.getInverse(this.matrixWorld))
            }
        }(),
        lookAt: function() {
            // This routine does not support objects with rotated and/or translated parent(s)
            var a = new THREE.Matrix4;
            return function(b) {
                a.lookAt(b, this.position, this.up), this.quaternion.setFromRotationMatrix(a)
            }
        }(),
        add: function(a) {
            if (arguments.length > 1) {
                for (var b = 0; b < arguments.length; b++) this.add(arguments[b]);
                return this
            }
            return a === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", a), this) : (a instanceof THREE.Object3D ? (null !== a.parent && a.parent.remove(a), a.parent = this, a.dispatchEvent({
                type: "added"
            }), this.children.push(a)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", a), this)
        },
        remove: function(a) {
            if (arguments.length > 1)
                for (var b = 0; b < arguments.length; b++) this.remove(arguments[b]);
            var c = this.children.indexOf(a); - 1 !== c && (a.parent = null, a.dispatchEvent({
                type: "removed"
            }), this.children.splice(c, 1))
        },
        getObjectById: function(a) {
            return this.getObjectByProperty("id", a)
        },
        getObjectByName: function(a) {
            return this.getObjectByProperty("name", a)
        },
        getObjectByProperty: function(a, b) {
            if (this[a] === b) return this;
            for (var c = 0, d = this.children.length; d > c; c++) {
                var e = this.children[c],
                    f = e.getObjectByProperty(a, b);
                if (void 0 !== f) return f
            }
        },
        getWorldPosition: function(a) {
            var b = a || new THREE.Vector3;
            return this.updateMatrixWorld(!0), b.setFromMatrixPosition(this.matrixWorld)
        },
        getWorldQuaternion: function() {
            var a = new THREE.Vector3,
                b = new THREE.Vector3;
            return function(c) {
                var d = c || new THREE.Quaternion;
                return this.updateMatrixWorld(!0), this.matrixWorld.decompose(a, d, b), d
            }
        }(),
        getWorldRotation: function() {
            var a = new THREE.Quaternion;
            return function(b) {
                var c = b || new THREE.Euler;
                return this.getWorldQuaternion(a), c.setFromQuaternion(a, this.rotation.order, !1)
            }
        }(),
        getWorldScale: function() {
            var a = new THREE.Vector3,
                b = new THREE.Quaternion;
            return function(c) {
                var d = c || new THREE.Vector3;
                return this.updateMatrixWorld(!0), this.matrixWorld.decompose(a, b, d), d
            }
        }(),
        getWorldDirection: function() {
            var a = new THREE.Quaternion;
            return function(b) {
                var c = b || new THREE.Vector3;
                return this.getWorldQuaternion(a), c.set(0, 0, 1).applyQuaternion(a)
            }
        }(),
        raycast: function() {},
        traverse: function(a) {
            a(this);
            for (var b = this.children, c = 0, d = b.length; d > c; c++) b[c].traverse(a)
        },
        traverseVisible: function(a) {
            if (this.visible !== !1) {
                a(this);
                for (var b = this.children, c = 0, d = b.length; d > c; c++) b[c].traverseVisible(a)
            }
        },
        traverseAncestors: function(a) {
            var b = this.parent;
            null !== b && (a(b), b.traverseAncestors(a))
        },
        updateMatrix: function() {
            this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
        },
        updateMatrixWorld: function(a) {
            this.matrixAutoUpdate === !0 && this.updateMatrix(), this.matrixWorldNeedsUpdate !== !0 && a !== !0 || (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, a = !0);
            // update children
            for (var b = 0, c = this.children.length; c > b; b++) this.children[b].updateMatrixWorld(a)
        },
        toJSON: function(a) {
            // extract data from the cache hash
            // remove metadata on each item
            // and return as array
            function b(a) {
                var b = [];
                for (var c in a) {
                    var d = a[c];
                    delete d.metadata, b.push(d)
                }
                return b
            }
            var c = void 0 === a,
                d = {};
            // meta is a hash used to collect geometries, materials.
            // not providing it implies that this is the root object
            // being serialized.
            c && (a = {
                geometries: {},
                materials: {},
                textures: {},
                images: {}
            }, d.metadata = {
                version: 4.4,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            // standard Object3D serialization
            var e = {};
            //
            if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), "{}" !== JSON.stringify(this.userData) && (e.userData = this.userData), this.castShadow === !0 && (e.castShadow = !0), this.receiveShadow === !0 && (e.receiveShadow = !0), this.visible === !1 && (e.visible = !1), e.matrix = this.matrix.toArray(),
                //
                void 0 !== this.geometry && (void 0 === a.geometries[this.geometry.uuid] && (a.geometries[this.geometry.uuid] = this.geometry.toJSON(a)), e.geometry = this.geometry.uuid), void 0 !== this.material && (void 0 === a.materials[this.material.uuid] && (a.materials[this.material.uuid] = this.material.toJSON(a)), e.material = this.material.uuid), this.children.length > 0) {
                e.children = [];
                for (var f = 0; f < this.children.length; f++) e.children.push(this.children[f].toJSON(a).object)
            }
            if (c) {
                var g = b(a.geometries),
                    h = b(a.materials),
                    i = b(a.textures),
                    j = b(a.images);
                g.length > 0 && (d.geometries = g), h.length > 0 && (d.materials = h), i.length > 0 && (d.textures = i), j.length > 0 && (d.images = j)
            }
            return d.object = e, d
        },
        clone: function(a) {
            return (new this.constructor).copy(this, a)
        },
        copy: function(a, b) {
            if (void 0 === b && (b = !0), this.name = a.name, this.up.copy(a.up), this.position.copy(a.position), this.quaternion.copy(a.quaternion), this.scale.copy(a.scale), this.rotationAutoUpdate = a.rotationAutoUpdate, this.matrix.copy(a.matrix), this.matrixWorld.copy(a.matrixWorld), this.matrixAutoUpdate = a.matrixAutoUpdate, this.matrixWorldNeedsUpdate = a.matrixWorldNeedsUpdate, this.visible = a.visible, this.castShadow = a.castShadow, this.receiveShadow = a.receiveShadow, this.frustumCulled = a.frustumCulled, this.renderOrder = a.renderOrder, this.userData = JSON.parse(JSON.stringify(a.userData)), b === !0)
                for (var c = 0; c < a.children.length; c++) {
                    var d = a.children[c];
                    this.add(d.clone())
                }
            return this
        }
    }, THREE.EventDispatcher.prototype.apply(THREE.Object3D.prototype), THREE.Object3DIdCount = 0,
    // File:src/core/Face3.js
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */
    THREE.Face3 = function(a, b, c, d, e, f) {
        this.a = a, this.b = b, this.c = c, this.normal = d instanceof THREE.Vector3 ? d : new THREE.Vector3, this.vertexNormals = Array.isArray(d) ? d : [], this.color = e instanceof THREE.Color ? e : new THREE.Color, this.vertexColors = Array.isArray(e) ? e : [], this.materialIndex = void 0 !== f ? f : 0
    }, THREE.Face3.prototype = {
        constructor: THREE.Face3,
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(a) {
            this.a = a.a, this.b = a.b, this.c = a.c, this.normal.copy(a.normal), this.color.copy(a.color), this.materialIndex = a.materialIndex;
            for (var b = 0, c = a.vertexNormals.length; c > b; b++) this.vertexNormals[b] = a.vertexNormals[b].clone();
            for (var b = 0, c = a.vertexColors.length; c > b; b++) this.vertexColors[b] = a.vertexColors[b].clone();
            return this
        }
    },
    // File:src/core/BufferAttribute.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.BufferAttribute = function(a, b) {
        this.uuid = THREE.Math.generateUUID(), this.array = a, this.itemSize = b, this.dynamic = !1, this.updateRange = {
            offset: 0,
            count: -1
        }, this.version = 0
    }, THREE.BufferAttribute.prototype = {
        constructor: THREE.BufferAttribute,
        get count() {
            return this.array.length / this.itemSize
        },
        set needsUpdate(a) {
            a === !0 && this.version++
        },
        setDynamic: function(a) {
            return this.dynamic = a, this
        },
        copy: function(a) {
            return this.array = new a.array.constructor(a.array), this.itemSize = a.itemSize, this.dynamic = a.dynamic, this
        },
        copyAt: function(a, b, c) {
            a *= this.itemSize, c *= b.itemSize;
            for (var d = 0, e = this.itemSize; e > d; d++) this.array[a + d] = b.array[c + d];
            return this
        },
        copyArray: function(a) {
            return this.array.set(a), this
        },
        copyColorsArray: function(a) {
            for (var b = this.array, c = 0, d = 0, e = a.length; e > d; d++) {
                var f = a[d];
                void 0 === f && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", d), f = new THREE.Color), b[c++] = f.r, b[c++] = f.g, b[c++] = f.b
            }
            return this
        },
        copyIndicesArray: function(a) {
            for (var b = this.array, c = 0, d = 0, e = a.length; e > d; d++) {
                var f = a[d];
                b[c++] = f.a, b[c++] = f.b, b[c++] = f.c
            }
            return this
        },
        copyVector2sArray: function(a) {
            for (var b = this.array, c = 0, d = 0, e = a.length; e > d; d++) {
                var f = a[d];
                void 0 === f && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", d), f = new THREE.Vector2), b[c++] = f.x, b[c++] = f.y
            }
            return this
        },
        copyVector3sArray: function(a) {
            for (var b = this.array, c = 0, d = 0, e = a.length; e > d; d++) {
                var f = a[d];
                void 0 === f && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", d), f = new THREE.Vector3), b[c++] = f.x, b[c++] = f.y, b[c++] = f.z
            }
            return this
        },
        copyVector4sArray: function(a) {
            for (var b = this.array, c = 0, d = 0, e = a.length; e > d; d++) {
                var f = a[d];
                void 0 === f && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", d), f = new THREE.Vector4), b[c++] = f.x, b[c++] = f.y, b[c++] = f.z, b[c++] = f.w
            }
            return this
        },
        set: function(a, b) {
            return void 0 === b && (b = 0), this.array.set(a, b), this
        },
        getX: function(a) {
            return this.array[a * this.itemSize]
        },
        setX: function(a, b) {
            return this.array[a * this.itemSize] = b, this
        },
        getY: function(a) {
            return this.array[a * this.itemSize + 1]
        },
        setY: function(a, b) {
            return this.array[a * this.itemSize + 1] = b, this
        },
        getZ: function(a) {
            return this.array[a * this.itemSize + 2]
        },
        setZ: function(a, b) {
            return this.array[a * this.itemSize + 2] = b, this
        },
        getW: function(a) {
            return this.array[a * this.itemSize + 3]
        },
        setW: function(a, b) {
            return this.array[a * this.itemSize + 3] = b, this
        },
        setXY: function(a, b, c) {
            return a *= this.itemSize, this.array[a + 0] = b, this.array[a + 1] = c, this
        },
        setXYZ: function(a, b, c, d) {
            return a *= this.itemSize, this.array[a + 0] = b, this.array[a + 1] = c, this.array[a + 2] = d, this
        },
        setXYZW: function(a, b, c, d, e) {
            return a *= this.itemSize, this.array[a + 0] = b, this.array[a + 1] = c, this.array[a + 2] = d, this.array[a + 3] = e, this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    },
    //
    THREE.Int8Attribute = function(a, b) {
        return new THREE.BufferAttribute(new Int8Array(a), b)
    }, THREE.Uint8Attribute = function(a, b) {
        return new THREE.BufferAttribute(new Uint8Array(a), b)
    }, THREE.Uint8ClampedAttribute = function(a, b) {
        return new THREE.BufferAttribute(new Uint8ClampedArray(a), b)
    }, THREE.Int16Attribute = function(a, b) {
        return new THREE.BufferAttribute(new Int16Array(a), b)
    }, THREE.Uint16Attribute = function(a, b) {
        return new THREE.BufferAttribute(new Uint16Array(a), b)
    }, THREE.Int32Attribute = function(a, b) {
        return new THREE.BufferAttribute(new Int32Array(a), b)
    }, THREE.Uint32Attribute = function(a, b) {
        return new THREE.BufferAttribute(new Uint32Array(a), b)
    }, THREE.Float32Attribute = function(a, b) {
        return new THREE.BufferAttribute(new Float32Array(a), b)
    }, THREE.Float64Attribute = function(a, b) {
        return new THREE.BufferAttribute(new Float64Array(a), b)
    },
    // Deprecated
    THREE.DynamicBufferAttribute = function(a, b) {
        return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), new THREE.BufferAttribute(a, b).setDynamic(!0)
    },
    // File:src/core/InstancedBufferAttribute.js
    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     */
    THREE.InstancedBufferAttribute = function(a, b, c) {
        THREE.BufferAttribute.call(this, a, b), this.meshPerAttribute = c || 1
    }, THREE.InstancedBufferAttribute.prototype = Object.create(THREE.BufferAttribute.prototype), THREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute, THREE.InstancedBufferAttribute.prototype.copy = function(a) {
        return THREE.BufferAttribute.prototype.copy.call(this, a), this.meshPerAttribute = a.meshPerAttribute, this
    },
    // File:src/core/InterleavedBuffer.js
    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     */
    THREE.InterleavedBuffer = function(a, b) {
        this.uuid = THREE.Math.generateUUID(), this.array = a, this.stride = b, this.dynamic = !1, this.updateRange = {
            offset: 0,
            count: -1
        }, this.version = 0
    }, THREE.InterleavedBuffer.prototype = {
        constructor: THREE.InterleavedBuffer,
        get length() {
            return this.array.length
        },
        get count() {
            return this.array.length / this.stride
        },
        set needsUpdate(a) {
            a === !0 && this.version++
        },
        setDynamic: function(a) {
            return this.dynamic = a, this
        },
        copy: function(a) {
            return this.array = new a.array.constructor(a.array), this.stride = a.stride, this.dynamic = a.dynamic, this
        },
        copyAt: function(a, b, c) {
            a *= this.stride, c *= b.stride;
            for (var d = 0, e = this.stride; e > d; d++) this.array[a + d] = b.array[c + d];
            return this
        },
        set: function(a, b) {
            return void 0 === b && (b = 0), this.array.set(a, b), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    },
    // File:src/core/InstancedInterleavedBuffer.js
    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     */
    THREE.InstancedInterleavedBuffer = function(a, b, c) {
        THREE.InterleavedBuffer.call(this, a, b), this.meshPerAttribute = c || 1
    }, THREE.InstancedInterleavedBuffer.prototype = Object.create(THREE.InterleavedBuffer.prototype), THREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer, THREE.InstancedInterleavedBuffer.prototype.copy = function(a) {
        return THREE.InterleavedBuffer.prototype.copy.call(this, a), this.meshPerAttribute = a.meshPerAttribute, this
    },
    // File:src/core/InterleavedBufferAttribute.js
    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     */
    THREE.InterleavedBufferAttribute = function(a, b, c) {
        this.uuid = THREE.Math.generateUUID(), this.data = a, this.itemSize = b, this.offset = c
    }, THREE.InterleavedBufferAttribute.prototype = {
        constructor: THREE.InterleavedBufferAttribute,
        get length() {
            return console.warn("THREE.BufferAttribute: .length has been deprecated. Please use .count."), this.array.length
        },
        get count() {
            return this.data.count
        },
        setX: function(a, b) {
            return this.data.array[a * this.data.stride + this.offset] = b, this
        },
        setY: function(a, b) {
            return this.data.array[a * this.data.stride + this.offset + 1] = b, this
        },
        setZ: function(a, b) {
            return this.data.array[a * this.data.stride + this.offset + 2] = b, this
        },
        setW: function(a, b) {
            return this.data.array[a * this.data.stride + this.offset + 3] = b, this
        },
        getX: function(a) {
            return this.data.array[a * this.data.stride + this.offset]
        },
        getY: function(a) {
            return this.data.array[a * this.data.stride + this.offset + 1]
        },
        getZ: function(a) {
            return this.data.array[a * this.data.stride + this.offset + 2]
        },
        getW: function(a) {
            return this.data.array[a * this.data.stride + this.offset + 3]
        },
        setXY: function(a, b, c) {
            return a = a * this.data.stride + this.offset, this.data.array[a + 0] = b, this.data.array[a + 1] = c, this
        },
        setXYZ: function(a, b, c, d) {
            return a = a * this.data.stride + this.offset, this.data.array[a + 0] = b, this.data.array[a + 1] = c, this.data.array[a + 2] = d, this
        },
        setXYZW: function(a, b, c, d, e) {
            return a = a * this.data.stride + this.offset, this.data.array[a + 0] = b, this.data.array[a + 1] = c, this.data.array[a + 2] = d, this.data.array[a + 3] = e, this
        }
    },
    // File:src/core/Geometry.js
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author kile / http://kile.stravaganza.org/
     * @author alteredq / http://alteredqualia.com/
     * @author mikael emtinger / http://gomo.se/
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * @author bhouston / http://clara.io
     */
    THREE.Geometry = function() {
        Object.defineProperty(this, "id", {
                value: THREE.GeometryIdCount++
            }), this.uuid = THREE.Math.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                []
            ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null,
            // update flags
            this.verticesNeedUpdate = !1, this.elementsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1
    }, THREE.Geometry.prototype = {
        constructor: THREE.Geometry,
        applyMatrix: function(a) {
            for (var b = (new THREE.Matrix3).getNormalMatrix(a), c = 0, d = this.vertices.length; d > c; c++) {
                var e = this.vertices[c];
                e.applyMatrix4(a)
            }
            for (var c = 0, d = this.faces.length; d > c; c++) {
                var f = this.faces[c];
                f.normal.applyMatrix3(b).normalize();
                for (var g = 0, h = f.vertexNormals.length; h > g; g++) f.vertexNormals[g].applyMatrix3(b).normalize()
            }
            null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0
        },
        rotateX: function() {
            // rotate geometry around world x-axis
            var a;
            return function(b) {
                return void 0 === a && (a = new THREE.Matrix4), a.makeRotationX(b), this.applyMatrix(a), this
            }
        }(),
        rotateY: function() {
            // rotate geometry around world y-axis
            var a;
            return function(b) {
                return void 0 === a && (a = new THREE.Matrix4), a.makeRotationY(b), this.applyMatrix(a), this
            }
        }(),
        rotateZ: function() {
            // rotate geometry around world z-axis
            var a;
            return function(b) {
                return void 0 === a && (a = new THREE.Matrix4), a.makeRotationZ(b), this.applyMatrix(a), this
            }
        }(),
        translate: function() {
            // translate geometry
            var a;
            return function(b, c, d) {
                return void 0 === a && (a = new THREE.Matrix4), a.makeTranslation(b, c, d), this.applyMatrix(a), this
            }
        }(),
        scale: function() {
            // scale geometry
            var a;
            return function(b, c, d) {
                return void 0 === a && (a = new THREE.Matrix4), a.makeScale(b, c, d), this.applyMatrix(a), this
            }
        }(),
        lookAt: function() {
            var a;
            return function(b) {
                void 0 === a && (a = new THREE.Object3D), a.lookAt(b), a.updateMatrix(), this.applyMatrix(a.matrix)
            }
        }(),
        fromBufferGeometry: function(a) {
            function b(a, b, d) {
                var e = void 0 !== g ? [k[a].clone(), k[b].clone(), k[d].clone()] : [],
                    f = void 0 !== h ? [c.colors[a].clone(), c.colors[b].clone(), c.colors[d].clone()] : [],
                    n = new THREE.Face3(a, b, d, e, f);
                c.faces.push(n), void 0 !== i && c.faceVertexUvs[0].push([l[a].clone(), l[b].clone(), l[d].clone()]), void 0 !== j && c.faceVertexUvs[1].push([m[a].clone(), m[b].clone(), m[d].clone()])
            }
            var c = this,
                d = null !== a.index ? a.index.array : void 0,
                e = a.attributes,
                f = e.position.array,
                g = void 0 !== e.normal ? e.normal.array : void 0,
                h = void 0 !== e.color ? e.color.array : void 0,
                i = void 0 !== e.uv ? e.uv.array : void 0,
                j = void 0 !== e.uv2 ? e.uv2.array : void 0;
            void 0 !== j && (this.faceVertexUvs[1] = []);
            for (var k = [], l = [], m = [], n = 0, o = 0; n < f.length; n += 3, o += 2) c.vertices.push(new THREE.Vector3(f[n], f[n + 1], f[n + 2])), void 0 !== g && k.push(new THREE.Vector3(g[n], g[n + 1], g[n + 2])), void 0 !== h && c.colors.push(new THREE.Color(h[n], h[n + 1], h[n + 2])), void 0 !== i && l.push(new THREE.Vector2(i[o], i[o + 1])), void 0 !== j && m.push(new THREE.Vector2(j[o], j[o + 1]));
            if (void 0 !== d) {
                var p = a.groups;
                if (p.length > 0)
                    for (var n = 0; n < p.length; n++)
                        for (var q = p[n], r = q.start, s = q.count, o = r, t = r + s; t > o; o += 3) b(d[o], d[o + 1], d[o + 2]);
                else
                    for (var n = 0; n < d.length; n += 3) b(d[n], d[n + 1], d[n + 2])
            } else
                for (var n = 0; n < f.length / 3; n += 3) b(n, n + 1, n + 2);
            return this.computeFaceNormals(), null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone()), null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone()), this
        },
        center: function() {
            this.computeBoundingBox();
            var a = this.boundingBox.center().negate();
            return this.translate(a.x, a.y, a.z), a
        },
        normalize: function() {
            this.computeBoundingSphere();
            var a = this.boundingSphere.center,
                b = this.boundingSphere.radius,
                c = 0 === b ? 1 : 1 / b,
                d = new THREE.Matrix4;
            return d.set(c, 0, 0, -c * a.x, 0, c, 0, -c * a.y, 0, 0, c, -c * a.z, 0, 0, 0, 1), this.applyMatrix(d), this
        },
        computeFaceNormals: function() {
            for (var a = new THREE.Vector3, b = new THREE.Vector3, c = 0, d = this.faces.length; d > c; c++) {
                var e = this.faces[c],
                    f = this.vertices[e.a],
                    g = this.vertices[e.b],
                    h = this.vertices[e.c];
                a.subVectors(h, g), b.subVectors(f, g), a.cross(b), a.normalize(), e.normal.copy(a)
            }
        },
        computeVertexNormals: function(a) {
            void 0 === a && (a = !0);
            var b, c, d, e, f, g;
            for (g = new Array(this.vertices.length), b = 0, c = this.vertices.length; c > b; b++) g[b] = new THREE.Vector3;
            if (a) {
                // vertex normals weighted by triangle areas
                // http://www.iquilezles.org/www/articles/normals/normals.htm
                var h, i, j, k = new THREE.Vector3,
                    l = new THREE.Vector3;
                for (d = 0, e = this.faces.length; e > d; d++) f = this.faces[d], h = this.vertices[f.a], i = this.vertices[f.b], j = this.vertices[f.c], k.subVectors(j, i), l.subVectors(h, i), k.cross(l), g[f.a].add(k), g[f.b].add(k), g[f.c].add(k)
            } else
                for (d = 0, e = this.faces.length; e > d; d++) f = this.faces[d], g[f.a].add(f.normal), g[f.b].add(f.normal), g[f.c].add(f.normal);
            for (b = 0, c = this.vertices.length; c > b; b++) g[b].normalize();
            for (d = 0, e = this.faces.length; e > d; d++) {
                f = this.faces[d];
                var m = f.vertexNormals;
                3 === m.length ? (m[0].copy(g[f.a]), m[1].copy(g[f.b]), m[2].copy(g[f.c])) : (m[0] = g[f.a].clone(), m[1] = g[f.b].clone(), m[2] = g[f.c].clone())
            }
            this.faces.length > 0 && (this.normalsNeedUpdate = !0)
        },
        computeMorphNormals: function() {
            var a, b, c, d, e;
            // save original normals
            // - create temp variables on first access
            //   otherwise just copy (for faster repeated calls)
            for (c = 0, d = this.faces.length; d > c; c++)
                for (e = this.faces[c], e.__originalFaceNormal ? e.__originalFaceNormal.copy(e.normal) : e.__originalFaceNormal = e.normal.clone(), e.__originalVertexNormals || (e.__originalVertexNormals = []), a = 0, b = e.vertexNormals.length; b > a; a++) e.__originalVertexNormals[a] ? e.__originalVertexNormals[a].copy(e.vertexNormals[a]) : e.__originalVertexNormals[a] = e.vertexNormals[a].clone();
            // use temp geometry to compute face and vertex normals for each morph
            var f = new THREE.Geometry;
            for (f.faces = this.faces, a = 0, b = this.morphTargets.length; b > a; a++) {
                // create on first access
                if (!this.morphNormals[a]) {
                    this.morphNormals[a] = {}, this.morphNormals[a].faceNormals = [], this.morphNormals[a].vertexNormals = [];
                    var g, h, i = this.morphNormals[a].faceNormals,
                        j = this.morphNormals[a].vertexNormals;
                    for (c = 0, d = this.faces.length; d > c; c++) g = new THREE.Vector3, h = {
                        a: new THREE.Vector3,
                        b: new THREE.Vector3,
                        c: new THREE.Vector3
                    }, i.push(g), j.push(h)
                }
                var k = this.morphNormals[a];
                // set vertices to morph target
                f.vertices = this.morphTargets[a].vertices,
                    // compute morph normals
                    f.computeFaceNormals(), f.computeVertexNormals();
                // store morph normals
                var g, h;
                for (c = 0, d = this.faces.length; d > c; c++) e = this.faces[c], g = k.faceNormals[c], h = k.vertexNormals[c], g.copy(e.normal), h.a.copy(e.vertexNormals[0]), h.b.copy(e.vertexNormals[1]), h.c.copy(e.vertexNormals[2])
            }
            // restore original normals
            for (c = 0, d = this.faces.length; d > c; c++) e = this.faces[c], e.normal = e.__originalFaceNormal, e.vertexNormals = e.__originalVertexNormals
        },
        computeTangents: function() {
            console.warn("THREE.Geometry: .computeTangents() has been removed.")
        },
        computeLineDistances: function() {
            for (var a = 0, b = this.vertices, c = 0, d = b.length; d > c; c++) c > 0 && (a += b[c].distanceTo(b[c - 1])), this.lineDistances[c] = a
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new THREE.Box3), this.boundingBox.setFromPoints(this.vertices)
        },
        computeBoundingSphere: function() {
            null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere), this.boundingSphere.setFromPoints(this.vertices)
        },
        merge: function(a, b, c) {
            if (a instanceof THREE.Geometry == !1) return void console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", a);
            var d, e = this.vertices.length,
                f = this.vertices,
                g = a.vertices,
                h = this.faces,
                i = a.faces,
                j = this.faceVertexUvs[0],
                k = a.faceVertexUvs[0];
            void 0 === c && (c = 0), void 0 !== b && (d = (new THREE.Matrix3).getNormalMatrix(b));
            // vertices
            for (var l = 0, m = g.length; m > l; l++) {
                var n = g[l],
                    o = n.clone();
                void 0 !== b && o.applyMatrix4(b), f.push(o)
            }
            // faces
            for (l = 0, m = i.length; m > l; l++) {
                var p, q, r, s = i[l],
                    t = s.vertexNormals,
                    u = s.vertexColors;
                p = new THREE.Face3(s.a + e, s.b + e, s.c + e), p.normal.copy(s.normal), void 0 !== d && p.normal.applyMatrix3(d).normalize();
                for (var v = 0, w = t.length; w > v; v++) q = t[v].clone(), void 0 !== d && q.applyMatrix3(d).normalize(), p.vertexNormals.push(q);
                p.color.copy(s.color);
                for (var v = 0, w = u.length; w > v; v++) r = u[v], p.vertexColors.push(r.clone());
                p.materialIndex = s.materialIndex + c, h.push(p)
            }
            // uvs
            for (l = 0, m = k.length; m > l; l++) {
                var x = k[l],
                    y = [];
                if (void 0 !== x) {
                    for (var v = 0, w = x.length; w > v; v++) y.push(x[v].clone());
                    j.push(y)
                }
            }
        },
        mergeMesh: function(a) {
            return a instanceof THREE.Mesh == !1 ? void console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", a) : (a.matrixAutoUpdate && a.updateMatrix(), void this.merge(a.geometry, a.matrix))
        },
        /*
         * Checks for duplicate vertices with hashmap.
         * Duplicated vertices are removed
         * and faces' vertices are updated.
         */
        mergeVertices: function() {
            var a, b, c, d, e, f, g, h, i = {},
                j = [],
                k = [],
                l = 4,
                m = Math.pow(10, l);
            for (c = 0, d = this.vertices.length; d > c; c++) a = this.vertices[c], b = Math.round(a.x * m) + "_" + Math.round(a.y * m) + "_" + Math.round(a.z * m), void 0 === i[b] ? (i[b] = c, j.push(this.vertices[c]), k[c] = j.length - 1) : k[c] = k[i[b]];
            // if faces are completely degenerate after merging vertices, we
            // have to remove them from the geometry.
            var n = [];
            for (c = 0, d = this.faces.length; d > c; c++) {
                e = this.faces[c], e.a = k[e.a], e.b = k[e.b], e.c = k[e.c], f = [e.a, e.b, e.c];
                // if any duplicate vertices are found in a Face3
                // we have to remove the face as nothing can be saved
                for (var o = -1, p = 0; 3 > p; p++)
                    if (f[p] === f[(p + 1) % 3]) {
                        o = p, n.push(c);
                        break
                    }
            }
            for (c = n.length - 1; c >= 0; c--) {
                var q = n[c];
                for (this.faces.splice(q, 1), g = 0, h = this.faceVertexUvs.length; h > g; g++) this.faceVertexUvs[g].splice(q, 1)
            }
            // Use unique set of vertices
            var r = this.vertices.length - j.length;
            return this.vertices = j, r
        },
        sortFacesByMaterialIndex: function() {
            // sort faces
            function a(a, b) {
                return a.materialIndex - b.materialIndex
            }
            // tag faces
            for (var b = this.faces, c = b.length, d = 0; c > d; d++) b[d]._id = d;
            b.sort(a);
            // sort uvs
            var e, f, g = this.faceVertexUvs[0],
                h = this.faceVertexUvs[1];
            g && g.length === c && (e = []), h && h.length === c && (f = []);
            for (var d = 0; c > d; d++) {
                var i = b[d]._id;
                e && e.push(g[i]), f && f.push(h[i])
            }
            e && (this.faceVertexUvs[0] = e), f && (this.faceVertexUvs[1] = f)
        },
        toJSON: function() {
            function a(a, b, c) {
                return c ? a | 1 << b : a & ~(1 << b)
            }

            function b(a) {
                var b = a.x.toString() + a.y.toString() + a.z.toString();
                return void 0 !== m[b] ? m[b] : (m[b] = l.length / 3, l.push(a.x, a.y, a.z), m[b])
            }

            function c(a) {
                var b = a.r.toString() + a.g.toString() + a.b.toString();
                return void 0 !== o[b] ? o[b] : (o[b] = n.length, n.push(a.getHex()), o[b])
            }

            function d(a) {
                var b = a.x.toString() + a.y.toString();
                return void 0 !== q[b] ? q[b] : (q[b] = p.length / 2, p.push(a.x, a.y), q[b])
            }
            var e = {
                metadata: {
                    version: 4.4,
                    type: "Geometry",
                    generator: "Geometry.toJSON"
                }
            };
            if (
                // standard Geometry serialization
                e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), void 0 !== this.parameters) {
                var f = this.parameters;
                for (var g in f) void 0 !== f[g] && (e[g] = f[g]);
                return e
            }
            for (var h = [], i = 0; i < this.vertices.length; i++) {
                var j = this.vertices[i];
                h.push(j.x, j.y, j.z)
            }
            for (var k = [], l = [], m = {}, n = [], o = {}, p = [], q = {}, i = 0; i < this.faces.length; i++) {
                var r = this.faces[i],
                    s = !0,
                    t = !1,
                    u = void 0 !== this.faceVertexUvs[0][i],
                    v = r.normal.length() > 0,
                    w = r.vertexNormals.length > 0,
                    x = 1 !== r.color.r || 1 !== r.color.g || 1 !== r.color.b,
                    y = r.vertexColors.length > 0,
                    z = 0;
                if (z = a(z, 0, 0), z = a(z, 1, s), z = a(z, 2, t), z = a(z, 3, u), z = a(z, 4, v), z = a(z, 5, w), z = a(z, 6, x), z = a(z, 7, y), k.push(z), k.push(r.a, r.b, r.c), k.push(r.materialIndex), u) {
                    var A = this.faceVertexUvs[0][i];
                    k.push(d(A[0]), d(A[1]), d(A[2]))
                }
                if (v && k.push(b(r.normal)), w) {
                    var B = r.vertexNormals;
                    k.push(b(B[0]), b(B[1]), b(B[2]))
                }
                if (x && k.push(c(r.color)), y) {
                    var C = r.vertexColors;
                    k.push(c(C[0]), c(C[1]), c(C[2]))
                }
            } // temporal backward compatibility
            return e.data = {}, e.data.vertices = h, e.data.normals = l, n.length > 0 && (e.data.colors = n), p.length > 0 && (e.data.uvs = [p]), e.data.faces = k, e
        },
        clone: function() {
            /*
            		 // Handle primitives

            		 var parameters = this.parameters;

            		 if ( parameters !== undefined ) {

            		 var values = [];

            		 for ( var key in parameters ) {

            		 values.push( parameters[ key ] );

            		 }

            		 var geometry = Object.create( this.constructor.prototype );
            		 this.constructor.apply( geometry, values );
            		 return geometry;

            		 }

            		 return new this.constructor().copy( this );
            		 */
            return (new THREE.Geometry).copy(this)
        },
        copy: function(a) {
            this.vertices = [], this.faces = [], this.faceVertexUvs = [
                []
            ];
            for (var b = a.vertices, c = 0, d = b.length; d > c; c++) this.vertices.push(b[c].clone());
            for (var e = a.faces, c = 0, d = e.length; d > c; c++) this.faces.push(e[c].clone());
            for (var c = 0, d = a.faceVertexUvs.length; d > c; c++) {
                var f = a.faceVertexUvs[c];
                void 0 === this.faceVertexUvs[c] && (this.faceVertexUvs[c] = []);
                for (var g = 0, h = f.length; h > g; g++) {
                    for (var i = f[g], j = [], k = 0, l = i.length; l > k; k++) {
                        var m = i[k];
                        j.push(m.clone())
                    }
                    this.faceVertexUvs[c].push(j)
                }
            }
            return this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }, THREE.EventDispatcher.prototype.apply(THREE.Geometry.prototype), THREE.GeometryIdCount = 0,
    // File:src/core/DirectGeometry.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.DirectGeometry = function() {
        Object.defineProperty(this, "id", {
                value: THREE.GeometryIdCount++
            }), this.uuid = THREE.Math.generateUUID(), this.name = "", this.type = "DirectGeometry", this.indices = [], this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [],
            // this.lineDistances = [];
            this.boundingBox = null, this.boundingSphere = null,
            // update flags
            this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1
    }, THREE.DirectGeometry.prototype = {
        constructor: THREE.DirectGeometry,
        computeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,
        computeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,
        computeFaceNormals: function() {
            console.warn("THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.")
        },
        computeVertexNormals: function() {
            console.warn("THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.")
        },
        computeGroups: function(a) {
            for (var b, c, d = [], e = a.faces, f = 0; f < e.length; f++) {
                var g = e[f];
                // materials
                g.materialIndex !== c && (c = g.materialIndex, void 0 !== b && (b.count = 3 * f - b.start, d.push(b)), b = {
                    start: 3 * f,
                    materialIndex: c
                })
            }
            void 0 !== b && (b.count = 3 * f - b.start, d.push(b)), this.groups = d
        },
        fromGeometry: function(a) {
            var b, c = a.faces,
                d = a.vertices,
                e = a.faceVertexUvs,
                f = e[0] && e[0].length > 0,
                g = e[1] && e[1].length > 0,
                h = a.morphTargets,
                i = h.length;
            if (i > 0) {
                b = [];
                for (var j = 0; i > j; j++) b[j] = [];
                this.morphTargets.position = b
            }
            var k, l = a.morphNormals,
                m = l.length;
            if (m > 0) {
                k = [];
                for (var j = 0; m > j; j++) k[j] = [];
                this.morphTargets.normal = k
            }
            //
            for (var n = a.skinIndices, o = a.skinWeights, p = n.length === d.length, q = o.length === d.length, j = 0; j < c.length; j++) {
                var r = c[j];
                this.vertices.push(d[r.a], d[r.b], d[r.c]);
                var s = r.vertexNormals;
                if (3 === s.length) this.normals.push(s[0], s[1], s[2]);
                else {
                    var t = r.normal;
                    this.normals.push(t, t, t)
                }
                var u = r.vertexColors;
                if (3 === u.length) this.colors.push(u[0], u[1], u[2]);
                else {
                    var v = r.color;
                    this.colors.push(v, v, v)
                }
                if (f === !0) {
                    var w = e[0][j];
                    void 0 !== w ? this.uvs.push(w[0], w[1], w[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", j), this.uvs.push(new THREE.Vector2, new THREE.Vector2, new THREE.Vector2))
                }
                if (g === !0) {
                    var w = e[1][j];
                    void 0 !== w ? this.uvs2.push(w[0], w[1], w[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", j), this.uvs2.push(new THREE.Vector2, new THREE.Vector2, new THREE.Vector2))
                }
                // morphs
                for (var x = 0; i > x; x++) {
                    var y = h[x].vertices;
                    b[x].push(y[r.a], y[r.b], y[r.c])
                }
                for (var x = 0; m > x; x++) {
                    var z = l[x].vertexNormals[j];
                    k[x].push(z.a, z.b, z.c)
                }
                // skins
                p && this.skinIndices.push(n[r.a], n[r.b], n[r.c]), q && this.skinWeights.push(o[r.a], o[r.b], o[r.c])
            }
            return this.computeGroups(a), this.verticesNeedUpdate = a.verticesNeedUpdate, this.normalsNeedUpdate = a.normalsNeedUpdate, this.colorsNeedUpdate = a.colorsNeedUpdate, this.uvsNeedUpdate = a.uvsNeedUpdate, this.groupsNeedUpdate = a.groupsNeedUpdate, this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }, THREE.EventDispatcher.prototype.apply(THREE.DirectGeometry.prototype),
    // File:src/core/BufferGeometry.js
    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.BufferGeometry = function() {
        Object.defineProperty(this, "id", {
            value: THREE.GeometryIdCount++
        }), this.uuid = THREE.Math.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
            start: 0,
            count: 1 / 0
        }
    }, THREE.BufferGeometry.prototype = {
        constructor: THREE.BufferGeometry,
        getIndex: function() {
            return this.index
        },
        setIndex: function(a) {
            this.index = a
        },
        addAttribute: function(a, b) {
            return b instanceof THREE.BufferAttribute == !1 && b instanceof THREE.InterleavedBufferAttribute == !1 ? (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), void this.addAttribute(a, new THREE.BufferAttribute(arguments[1], arguments[2]))) : "index" === a ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), void this.setIndex(b)) : (this.attributes[a] = b, this)
        },
        getAttribute: function(a) {
            return this.attributes[a]
        },
        removeAttribute: function(a) {
            return delete this.attributes[a], this
        },
        addGroup: function(a, b, c) {
            this.groups.push({
                start: a,
                count: b,
                materialIndex: void 0 !== c ? c : 0
            })
        },
        clearGroups: function() {
            this.groups = []
        },
        setDrawRange: function(a, b) {
            this.drawRange.start = a, this.drawRange.count = b
        },
        applyMatrix: function(a) {
            var b = this.attributes.position;
            void 0 !== b && (a.applyToVector3Array(b.array), b.needsUpdate = !0);
            var c = this.attributes.normal;
            if (void 0 !== c) {
                var d = (new THREE.Matrix3).getNormalMatrix(a);
                d.applyToVector3Array(c.array), c.needsUpdate = !0
            }
            null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere()
        },
        rotateX: function() {
            // rotate geometry around world x-axis
            var a;
            return function(b) {
                return void 0 === a && (a = new THREE.Matrix4), a.makeRotationX(b), this.applyMatrix(a), this
            }
        }(),
        rotateY: function() {
            // rotate geometry around world y-axis
            var a;
            return function(b) {
                return void 0 === a && (a = new THREE.Matrix4), a.makeRotationY(b), this.applyMatrix(a), this
            }
        }(),
        rotateZ: function() {
            // rotate geometry around world z-axis
            var a;
            return function(b) {
                return void 0 === a && (a = new THREE.Matrix4), a.makeRotationZ(b), this.applyMatrix(a), this
            }
        }(),
        translate: function() {
            // translate geometry
            var a;
            return function(b, c, d) {
                return void 0 === a && (a = new THREE.Matrix4), a.makeTranslation(b, c, d), this.applyMatrix(a), this
            }
        }(),
        scale: function() {
            // scale geometry
            var a;
            return function(b, c, d) {
                return void 0 === a && (a = new THREE.Matrix4), a.makeScale(b, c, d), this.applyMatrix(a), this
            }
        }(),
        lookAt: function() {
            var a;
            return function(b) {
                void 0 === a && (a = new THREE.Object3D), a.lookAt(b), a.updateMatrix(), this.applyMatrix(a.matrix)
            }
        }(),
        center: function() {
            this.computeBoundingBox();
            var a = this.boundingBox.center().negate();
            return this.translate(a.x, a.y, a.z), a
        },
        setFromObject: function(a) {
            // console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );
            var b = a.geometry;
            if (a instanceof THREE.Points || a instanceof THREE.Line) {
                var c = new THREE.Float32Attribute(3 * b.vertices.length, 3),
                    d = new THREE.Float32Attribute(3 * b.colors.length, 3);
                if (this.addAttribute("position", c.copyVector3sArray(b.vertices)), this.addAttribute("color", d.copyColorsArray(b.colors)), b.lineDistances && b.lineDistances.length === b.vertices.length) {
                    var e = new THREE.Float32Attribute(b.lineDistances.length, 1);
                    this.addAttribute("lineDistance", e.copyArray(b.lineDistances))
                }
                null !== b.boundingSphere && (this.boundingSphere = b.boundingSphere.clone()), null !== b.boundingBox && (this.boundingBox = b.boundingBox.clone())
            } else a instanceof THREE.Mesh && b instanceof THREE.Geometry && this.fromGeometry(b);
            return this
        },
        updateFromObject: function(a) {
            var b = a.geometry;
            if (a instanceof THREE.Mesh) {
                var c = b.__directGeometry;
                if (void 0 === c) return this.fromGeometry(b);
                c.verticesNeedUpdate = b.verticesNeedUpdate, c.normalsNeedUpdate = b.normalsNeedUpdate, c.colorsNeedUpdate = b.colorsNeedUpdate, c.uvsNeedUpdate = b.uvsNeedUpdate, c.groupsNeedUpdate = b.groupsNeedUpdate, b.verticesNeedUpdate = !1, b.normalsNeedUpdate = !1, b.colorsNeedUpdate = !1, b.uvsNeedUpdate = !1, b.groupsNeedUpdate = !1, b = c
            }
            if (b.verticesNeedUpdate === !0) {
                var d = this.attributes.position;
                void 0 !== d && (d.copyVector3sArray(b.vertices), d.needsUpdate = !0), b.verticesNeedUpdate = !1
            }
            if (b.normalsNeedUpdate === !0) {
                var d = this.attributes.normal;
                void 0 !== d && (d.copyVector3sArray(b.normals), d.needsUpdate = !0), b.normalsNeedUpdate = !1
            }
            if (b.colorsNeedUpdate === !0) {
                var d = this.attributes.color;
                void 0 !== d && (d.copyColorsArray(b.colors), d.needsUpdate = !0), b.colorsNeedUpdate = !1
            }
            if (b.uvsNeedUpdate) {
                var d = this.attributes.uv;
                void 0 !== d && (d.copyVector2sArray(b.uvs), d.needsUpdate = !0), b.uvsNeedUpdate = !1
            }
            if (b.lineDistancesNeedUpdate) {
                var d = this.attributes.lineDistance;
                void 0 !== d && (d.copyArray(b.lineDistances), d.needsUpdate = !0), b.lineDistancesNeedUpdate = !1
            }
            return b.groupsNeedUpdate && (b.computeGroups(a.geometry), this.groups = b.groups, b.groupsNeedUpdate = !1), this
        },
        fromGeometry: function(a) {
            return a.__directGeometry = (new THREE.DirectGeometry).fromGeometry(a), this.fromDirectGeometry(a.__directGeometry)
        },
        fromDirectGeometry: function(a) {
            var b = new Float32Array(3 * a.vertices.length);
            if (this.addAttribute("position", new THREE.BufferAttribute(b, 3).copyVector3sArray(a.vertices)), a.normals.length > 0) {
                var c = new Float32Array(3 * a.normals.length);
                this.addAttribute("normal", new THREE.BufferAttribute(c, 3).copyVector3sArray(a.normals))
            }
            if (a.colors.length > 0) {
                var d = new Float32Array(3 * a.colors.length);
                this.addAttribute("color", new THREE.BufferAttribute(d, 3).copyColorsArray(a.colors))
            }
            if (a.uvs.length > 0) {
                var e = new Float32Array(2 * a.uvs.length);
                this.addAttribute("uv", new THREE.BufferAttribute(e, 2).copyVector2sArray(a.uvs))
            }
            if (a.uvs2.length > 0) {
                var f = new Float32Array(2 * a.uvs2.length);
                this.addAttribute("uv2", new THREE.BufferAttribute(f, 2).copyVector2sArray(a.uvs2))
            }
            if (a.indices.length > 0) {
                var g = a.vertices.length > 65535 ? Uint32Array : Uint16Array,
                    h = new g(3 * a.indices.length);
                this.setIndex(new THREE.BufferAttribute(h, 1).copyIndicesArray(a.indices))
            }
            // groups
            this.groups = a.groups;
            // morphs
            for (var i in a.morphTargets) {
                for (var j = [], k = a.morphTargets[i], l = 0, m = k.length; m > l; l++) {
                    var n = k[l],
                        o = new THREE.Float32Attribute(3 * n.length, 3);
                    j.push(o.copyVector3sArray(n))
                }
                this.morphAttributes[i] = j
            }
            // skinning
            if (a.skinIndices.length > 0) {
                var p = new THREE.Float32Attribute(4 * a.skinIndices.length, 4);
                this.addAttribute("skinIndex", p.copyVector4sArray(a.skinIndices))
            }
            if (a.skinWeights.length > 0) {
                var q = new THREE.Float32Attribute(4 * a.skinWeights.length, 4);
                this.addAttribute("skinWeight", q.copyVector4sArray(a.skinWeights))
            }
            //
            return null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone()), null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone()), this
        },
        computeBoundingBox: function() {
            new THREE.Vector3;
            return function() {
                null === this.boundingBox && (this.boundingBox = new THREE.Box3);
                var a = this.attributes.position.array;
                a && this.boundingBox.setFromArray(a), void 0 !== a && 0 !== a.length || (this.boundingBox.min.set(0, 0, 0), this.boundingBox.max.set(0, 0, 0)), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
            }
        }(),
        computeBoundingSphere: function() {
            var a = new THREE.Box3,
                b = new THREE.Vector3;
            return function() {
                null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere);
                var c = this.attributes.position.array;
                if (c) {
                    var d = this.boundingSphere.center;
                    a.setFromArray(c), a.center(d);
                    for (var e = 0, f = 0, g = c.length; g > f; f += 3) b.fromArray(c, f), e = Math.max(e, d.distanceToSquared(b));
                    this.boundingSphere.radius = Math.sqrt(e), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            }
        }(),
        computeFaceNormals: function() {},
        computeVertexNormals: function() {
            var a = this.index,
                b = this.attributes,
                c = this.groups;
            if (b.position) {
                var d = b.position.array;
                if (void 0 === b.normal) this.addAttribute("normal", new THREE.BufferAttribute(new Float32Array(d.length), 3));
                else
                    for (var e = b.normal.array, f = 0, g = e.length; g > f; f++) e[f] = 0;
                var h, i, j, k = b.normal.array,
                    l = new THREE.Vector3,
                    m = new THREE.Vector3,
                    n = new THREE.Vector3,
                    o = new THREE.Vector3,
                    p = new THREE.Vector3;
                // indexed elements
                if (a) {
                    var q = a.array;
                    0 === c.length && this.addGroup(0, q.length);
                    for (var r = 0, s = c.length; s > r; ++r)
                        for (var t = c[r], u = t.start, v = t.count, f = u, g = u + v; g > f; f += 3) h = 3 * q[f + 0], i = 3 * q[f + 1], j = 3 * q[f + 2], l.fromArray(d, h), m.fromArray(d, i), n.fromArray(d, j), o.subVectors(n, m), p.subVectors(l, m), o.cross(p), k[h] += o.x, k[h + 1] += o.y, k[h + 2] += o.z, k[i] += o.x, k[i + 1] += o.y, k[i + 2] += o.z, k[j] += o.x, k[j + 1] += o.y, k[j + 2] += o.z
                } else
                // non-indexed elements (unconnected triangle soup)
                    for (var f = 0, g = d.length; g > f; f += 9) l.fromArray(d, f), m.fromArray(d, f + 3), n.fromArray(d, f + 6), o.subVectors(n, m), p.subVectors(l, m), o.cross(p), k[f] = o.x, k[f + 1] = o.y, k[f + 2] = o.z, k[f + 3] = o.x, k[f + 4] = o.y, k[f + 5] = o.z, k[f + 6] = o.x, k[f + 7] = o.y, k[f + 8] = o.z;
                this.normalizeNormals(), b.normal.needsUpdate = !0
            }
        },
        merge: function(a, b) {
            if (a instanceof THREE.BufferGeometry == !1) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", a);
            void 0 === b && (b = 0);
            var c = this.attributes;
            for (var d in c)
                if (void 0 !== a.attributes[d])
                    for (var e = c[d], f = e.array, g = a.attributes[d], h = g.array, i = g.itemSize, j = 0, k = i * b; j < h.length; j++, k++) f[k] = h[j];
            return this
        },
        normalizeNormals: function() {
            for (var a, b, c, d, e = this.attributes.normal.array, f = 0, g = e.length; g > f; f += 3) a = e[f], b = e[f + 1], c = e[f + 2], d = 1 / Math.sqrt(a * a + b * b + c * c), e[f] *= d, e[f + 1] *= d, e[f + 2] *= d
        },
        toNonIndexed: function() {
            if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
            var a = new THREE.BufferGeometry,
                b = this.index.array,
                c = this.attributes;
            for (var d in c) {
                for (var e = c[d], f = e.array, g = e.itemSize, h = new f.constructor(b.length * g), i = 0, j = 0, k = 0, l = b.length; l > k; k++) {
                    i = b[k] * g;
                    for (var m = 0; g > m; m++) h[j++] = f[i++]
                }
                a.addAttribute(d, new THREE.BufferAttribute(h, g))
            }
            return a
        },
        toJSON: function() {
            var a = {
                metadata: {
                    version: 4.4,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON"
                }
            };
            if (
                // standard BufferGeometry serialization
                a.uuid = this.uuid, a.type = this.type, "" !== this.name && (a.name = this.name), void 0 !== this.parameters) {
                var b = this.parameters;
                for (var c in b) void 0 !== b[c] && (a[c] = b[c]);
                return a
            }
            a.data = {
                attributes: {}
            };
            var d = this.index;
            if (null !== d) {
                var e = Array.prototype.slice.call(d.array);
                a.data.index = {
                    type: d.array.constructor.name,
                    array: e
                }
            }
            var f = this.attributes;
            for (var c in f) {
                var g = f[c],
                    e = Array.prototype.slice.call(g.array);
                a.data.attributes[c] = {
                    itemSize: g.itemSize,
                    type: g.array.constructor.name,
                    array: e
                }
            }
            var h = this.groups;
            h.length > 0 && (a.data.groups = JSON.parse(JSON.stringify(h)));
            var i = this.boundingSphere;
            return null !== i && (a.data.boundingSphere = {
                center: i.center.toArray(),
                radius: i.radius
            }), a
        },
        clone: function() {
            /*
            		 // Handle primitives

            		 var parameters = this.parameters;

            		 if ( parameters !== undefined ) {

            		 var values = [];

            		 for ( var key in parameters ) {

            		 values.push( parameters[ key ] );

            		 }

            		 var geometry = Object.create( this.constructor.prototype );
            		 this.constructor.apply( geometry, values );
            		 return geometry;

            		 }

            		 return new this.constructor().copy( this );
            		 */
            return (new THREE.BufferGeometry).copy(this)
        },
        copy: function(a) {
            var b = a.index;
            null !== b && this.setIndex(b.clone());
            var c = a.attributes;
            for (var d in c) {
                var e = c[d];
                this.addAttribute(d, e.clone())
            }
            for (var f = a.groups, g = 0, h = f.length; h > g; g++) {
                var i = f[g];
                this.addGroup(i.start, i.count)
            }
            return this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }, THREE.EventDispatcher.prototype.apply(THREE.BufferGeometry.prototype), THREE.BufferGeometry.MaxIndex = 65535,
    // File:src/core/InstancedBufferGeometry.js
    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     */
    THREE.InstancedBufferGeometry = function() {
        THREE.BufferGeometry.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0
    }, THREE.InstancedBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype), THREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry, THREE.InstancedBufferGeometry.prototype.addGroup = function(a, b, c) {
        this.groups.push({
            start: a,
            count: b,
            instances: c
        })
    }, THREE.InstancedBufferGeometry.prototype.copy = function(a) {
        var b = a.index;
        null !== b && this.setIndex(b.clone());
        var c = a.attributes;
        for (var d in c) {
            var e = c[d];
            this.addAttribute(d, e.clone())
        }
        for (var f = a.groups, g = 0, h = f.length; h > g; g++) {
            var i = f[g];
            this.addGroup(i.start, i.count, i.instances)
        }
        return this
    }, THREE.EventDispatcher.prototype.apply(THREE.InstancedBufferGeometry.prototype),
    // File:src/core/Uniform.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.Uniform = function(a, b) {
        this.type = a, this.value = b, this.dynamic = !1
    }, THREE.Uniform.prototype = {
        constructor: THREE.Uniform,
        onUpdate: function(a) {
            return this.dynamic = !0, this.onUpdateCallback = a, this
        }
    },
    // File:src/animation/AnimationClip.js
    /**
     *
     * Reusable set of Tracks that represent an animation.
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     */
    THREE.AnimationClip = function(a, b, c) {
        this.name = a || THREE.Math.generateUUID(), this.tracks = c, this.duration = void 0 !== b ? b : -1,
            // this means it should figure out its duration by scanning the tracks
            this.duration < 0 && this.resetDuration(),
            // maybe only do these on demand, as doing them here could potentially slow down loading
            // but leaving these here during development as this ensures a lot of testing of these functions
            this.trim(), this.optimize()
    }, THREE.AnimationClip.prototype = {
        constructor: THREE.AnimationClip,
        resetDuration: function() {
            for (var a = this.tracks, b = 0, c = 0, d = a.length; c !== d; ++c) {
                var e = this.tracks[c];
                b = Math.max(b, e.times[e.times.length - 1])
            }
            this.duration = b
        },
        trim: function() {
            for (var a = 0; a < this.tracks.length; a++) this.tracks[a].trim(0, this.duration);
            return this
        },
        optimize: function() {
            for (var a = 0; a < this.tracks.length; a++) this.tracks[a].optimize();
            return this
        }
    },
    // Static methods:
    Object.assign(THREE.AnimationClip, {
        parse: function(a) {
            for (var b = [], c = a.tracks, d = 1 / (a.fps || 1), e = 0, f = c.length; e !== f; ++e) b.push(THREE.KeyframeTrack.parse(c[e]).scale(d));
            return new THREE.AnimationClip(a.name, a.duration, b)
        },
        toJSON: function(a) {
            for (var b = [], c = a.tracks, d = {
                    name: a.name,
                    duration: a.duration,
                    tracks: b
                }, e = 0, f = c.length; e !== f; ++e) b.push(THREE.KeyframeTrack.toJSON(c[e]));
            return d
        },
        CreateFromMorphTargetSequence: function(a, b, c) {
            for (var d = b.length, e = [], f = 0; d > f; f++) {
                var g = [],
                    h = [];
                g.push((f + d - 1) % d, f, (f + 1) % d), h.push(0, 1, 0);
                var i = THREE.AnimationUtils.getKeyframeOrder(g);
                g = THREE.AnimationUtils.sortedArray(g, 1, i), h = THREE.AnimationUtils.sortedArray(h, 1, i),
                    // if there is a key at the first frame, duplicate it as the
                    // last frame as well for perfect loop.
                    0 === g[0] && (g.push(d), h.push(h[0])), e.push(new THREE.NumberKeyframeTrack(".morphTargetInfluences[" + b[f].name + "]", g, h).scale(1 / c))
            }
            return new THREE.AnimationClip(a, -1, e)
        },
        findByName: function(a, b) {
            for (var c = 0; c < a.length; c++)
                if (a[c].name === b) return a[c];
            return null
        },
        CreateClipsFromMorphTargetSequences: function(a, b) {
            // sort morph target names into animation groups based
            // patterns like Walk_001, Walk_002, Run_001, Run_002
            for (var c = {}, d = /^([\w-]*?)([\d]+)$/, e = 0, f = a.length; f > e; e++) {
                var g = a[e],
                    h = g.name.match(d);
                if (h && h.length > 1) {
                    var i = h[1],
                        j = c[i];
                    j || (c[i] = j = []), j.push(g)
                }
            }
            var k = [];
            for (var i in c) k.push(THREE.AnimationClip.CreateFromMorphTargetSequence(i, c[i], b));
            return k
        },
        // parse the animation.hierarchy format
        parseAnimation: function(a, b, c) {
            if (!a) return console.error("  no animation in JSONLoader data"), null;
            for (var d = function(a, b, c, d, e) {
                    // only return track if there are actually keys.
                    if (0 !== c.length) {
                        var f = [],
                            g = [];
                        THREE.AnimationUtils.flattenJSON(c, f, g, d),
                            // empty keys are filtered out, so check again
                            0 !== f.length && e.push(new a(b, f, g))
                    }
                }, e = [], f = a.name || "default", g = a.length || -1, h = a.fps || 30, i = a.hierarchy || [], j = 0; j < i.length; j++) {
                var k = i[j].keys;
                // skip empty tracks
                if (k && 0 != k.length)
                // process morph targets in a way exactly compatible
                // with AnimationHandler.init( animation )
                    if (k[0].morphTargets) {
                    for (var l = {}, m = 0; m < k.length; m++)
                        if (k[m].morphTargets)
                            for (var n = 0; n < k[m].morphTargets.length; n++) l[k[m].morphTargets[n]] = -1;
                        // create a track for each morph target with all zero
                        // morphTargetInfluences except for the keys in which
                        // the morphTarget is named.
                    for (var o in l) {
                        for (var p = [], q = [], n = 0; n !== k[m].morphTargets.length; ++n) {
                            var r = k[m];
                            p.push(r.time), q.push(r.morphTarget === o ? 1 : 0)
                        }
                        e.push(new THREE.NumberKeyframeTrack(".morphTargetInfluence[" + o + "]", p, q))
                    }
                    g = l.length * (h || 1)
                } else {
                    // ...assume skeletal animation
                    var s = ".bones[" + b[j].name + "]";
                    d(THREE.VectorKeyframeTrack, s + ".position", k, "pos", e), d(THREE.QuaternionKeyframeTrack, s + ".quaternion", k, "rot", e), d(THREE.VectorKeyframeTrack, s + ".scale", k, "scl", e)
                }
            }
            if (0 === e.length) return null;
            var t = new THREE.AnimationClip(f, g, e);
            return t
        }
    }),
    // File:src/animation/AnimationMixer.js
    /**
     *
     * Player for AnimationClips.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */
    THREE.AnimationMixer = function(a) {
        this._root = a, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
    }, THREE.AnimationMixer.prototype = {
        constructor: THREE.AnimationMixer,
        // return an action for a clip optionally using a custom root target
        // object (this method allocates a lot of dynamic memory in case a
        // previously unknown clip/root combination is specified)
        clipAction: function(a, b) {
            var c, d = b || this._root,
                e = d.uuid,
                f = "string" == typeof a ? a : a.name,
                g = a !== f ? a : null,
                h = this._actionsByClip[f];
            if (void 0 !== h) {
                var i = h.actionByRoot[e];
                if (void 0 !== i) return i;
                if (c = h.knownActions[0], g = c._clip, a !== f && a !== g) throw new Error("Different clips with the same name detected!")
            }
            // clip must be known when specified via string
            if (null === g) return null;
            // allocate all resources required to run it
            var j = new THREE.AnimationMixer._Action(this, g, b);
            // and make the action known to the memory manager
            return this._bindAction(j, c), this._addInactiveAction(j, f, e), j
        },
        // get an existing action
        existingAction: function(a, b) {
            var c = b || this._root,
                d = c.uuid,
                e = "string" == typeof a ? a : a.name,
                f = this._actionsByClip[e];
            return void 0 !== f ? f.actionByRoot[d] || null : null
        },
        // deactivates all previously scheduled actions
        stopAllAction: function() {
            var a = this._actions,
                b = this._nActiveActions,
                c = this._bindings,
                d = this._nActiveBindings;
            this._nActiveActions = 0, this._nActiveBindings = 0;
            for (var e = 0; e !== b; ++e) a[e].reset();
            for (var e = 0; e !== d; ++e) c[e].useCount = 0;
            return this
        },
        // advance the time and update apply the animation
        update: function(a) {
            a *= this.timeScale;
            // run active actions
            for (var b = this._actions, c = this._nActiveActions, d = this.time += a, e = Math.sign(a), f = this._accuIndex ^= 1, g = 0; g !== c; ++g) {
                var h = b[g];
                h.enabled && h._update(d, a, e, f)
            }
            for (var i = this._bindings, j = this._nActiveBindings, g = 0; g !== j; ++g) i[g].apply(f);
            return this
        },
        // return this mixer's root target object
        getRoot: function() {
            return this._root
        },
        // free all resources specific to a particular clip
        uncacheClip: function(a) {
            var b = this._actions,
                c = a.name,
                d = this._actionsByClip,
                e = d[c];
            if (void 0 !== e) {
                for (var f = e.knownActions, g = 0, h = f.length; g !== h; ++g) {
                    var i = f[g];
                    this._deactivateAction(i);
                    var j = i._cacheIndex,
                        k = b[b.length - 1];
                    i._cacheIndex = null, i._byClipCacheIndex = null, k._cacheIndex = j, b[j] = k, b.pop(), this._removeInactiveBindingsForAction(i)
                }
                delete d[c]
            }
        },
        // free all resources specific to a particular root target object
        uncacheRoot: function(a) {
            var b = a.uuid,
                c = this._actionsByClip;
            for (var d in c) {
                var e = c[d].actionByRoot,
                    f = e[b];
                void 0 !== f && (this._deactivateAction(f), this._removeInactiveAction(f))
            }
            var g = this._bindingsByRootAndName,
                h = g[b];
            if (void 0 !== h)
                for (var i in h) {
                    var j = h[i];
                    j.restoreOriginalState(), this._removeInactiveBinding(j)
                }
        },
        // remove a targeted clip from the cache
        uncacheAction: function(a, b) {
            var c = this.existingAction(a, b);
            null !== c && (this._deactivateAction(c), this._removeInactiveAction(c))
        }
    }, THREE.EventDispatcher.prototype.apply(THREE.AnimationMixer.prototype), THREE.AnimationMixer._Action = function(a, b, c) {
        this._mixer = a, this._clip = b, this._localRoot = c || null;
        for (var d = b.tracks, e = d.length, f = new Array(e), g = {
                endingStart: THREE.ZeroCurvatureEnding,
                endingEnd: THREE.ZeroCurvatureEnding
            }, h = 0; h !== e; ++h) {
            var i = d[h].createInterpolant(null);
            f[h] = i, i.settings = g
        }
        this._interpolantSettings = g, this._interpolants = f, // bound by the mixer
            // inside: PropertyMixer (managed by the mixer)
            this._propertyBindings = new Array(e), this._cacheIndex = null, // for the memory manager
            this._byClipCacheIndex = null, // for the memory manager
            this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = THREE.LoopRepeat, this._loopCount = -1,
            // global mixer time when the action is to be started
            // it's set back to 'null' upon start of the action
            this._startTime = null,
            // scaled local time of the action
            // gets clamped or wrapped to 0..clip.duration according to loop
            this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, // no. of repetitions when looping
            this.paused = !1, // false -> zero effective time scale
            this.enabled = !0, // true -> zero effective weight
            this.clampWhenFinished = !1, // keep feeding the last frame?
            this.zeroSlopeAtStart = !0, // for smooth interpolation w/o separate
            this.zeroSlopeAtEnd = !0
    }, THREE.AnimationMixer._Action.prototype = {
        constructor: THREE.AnimationMixer._Action,
        // State & Scheduling
        play: function() {
            return this._mixer._activateAction(this), this
        },
        stop: function() {
            return this._mixer._deactivateAction(this), this.reset()
        },
        reset: function() { // forget scheduling
            // restart clip
            // forget previous loops
            return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
        },
        isRunning: function() {
            this._startTime;
            return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
        },
        // return true when play has been called
        isScheduled: function() {
            return this._mixer._isActiveAction(this)
        },
        startAt: function(a) {
            return this._startTime = a, this
        },
        setLoop: function(a, b) {
            return this.loop = a, this.repetitions = b, this
        },
        // Weight
        // set the weight stopping any scheduled fading
        // although .enabled = false yields an effective weight of zero, this
        // method does *not* change .enabled, because it would be confusing
        setEffectiveWeight: function(a) {
            // note: same logic as when updated at runtime
            return this.weight = a, this._effectiveWeight = this.enabled ? a : 0, this.stopFading()
        },
        // return the weight considering fading and .enabled
        getEffectiveWeight: function() {
            return this._effectiveWeight
        },
        fadeIn: function(a) {
            return this._scheduleFading(a, 0, 1)
        },
        fadeOut: function(a) {
            return this._scheduleFading(a, 1, 0)
        },
        crossFadeFrom: function(a, b, c) {
            this._mixer;
            if (a.fadeOut(b), this.fadeIn(b), c) {
                var d = this._clip.duration,
                    e = a._clip.duration,
                    f = e / d,
                    g = d / e;
                a.warp(1, f, b), this.warp(g, 1, b)
            }
            return this
        },
        crossFadeTo: function(a, b, c) {
            return a.crossFadeFrom(this, b, c)
        },
        stopFading: function() {
            var a = this._weightInterpolant;
            return null !== a && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(a)), this
        },
        // Time Scale Control
        // set the weight stopping any scheduled warping
        // although .paused = true yields an effective time scale of zero, this
        // method does *not* change .paused, because it would be confusing
        setEffectiveTimeScale: function(a) {
            return this.timeScale = a, this._effectiveTimeScale = this.paused ? 0 : a, this.stopWarping()
        },
        // return the time scale considering warping and .paused
        getEffectiveTimeScale: function() {
            return this._effectiveTimeScale
        },
        setDuration: function(a) {
            return this.timeScale = this._clip.duration / a, this.stopWarping()
        },
        syncWith: function(a) {
            return this.time = a.time, this.timeScale = a.timeScale, this.stopWarping()
        },
        halt: function(a) {
            return this.warp(this._currentTimeScale, 0, a)
        },
        warp: function(a, b, c) {
            var d = this._mixer,
                e = d.time,
                f = this._timeScaleInterpolant,
                g = this.timeScale;
            null === f && (f = d._lendControlInterpolant(), this._timeScaleInterpolant = f);
            var h = f.parameterPositions,
                i = f.sampleValues;
            return h[0] = e, h[1] = e + c, i[0] = a / g, i[1] = b / g, this
        },
        stopWarping: function() {
            var a = this._timeScaleInterpolant;
            return null !== a && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(a)), this
        },
        // Object Accessors
        getMixer: function() {
            return this._mixer
        },
        getClip: function() {
            return this._clip
        },
        getRoot: function() {
            return this._localRoot || this._mixer._root
        },
        // Interna
        _update: function(a, b, c, d) {
            // called by the mixer
            var e = this._startTime;
            if (null !== e) {
                // check for scheduled start of action
                var f = (a - e) * c;
                if (0 > f || 0 === c) return;
                // start
                this._startTime = null, // unschedule
                    b = c * f
            }
            // apply time scale and advance time
            b *= this._updateTimeScale(a);
            var g = this._updateTime(b),
                h = this._updateWeight(a);
            if (h > 0)
                for (var i = this._interpolants, j = this._propertyBindings, k = 0, l = i.length; k !== l; ++k) i[k].evaluate(g), j[k].accumulate(d, h)
        },
        _updateWeight: function(a) {
            var b = 0;
            if (this.enabled) {
                b = this.weight;
                var c = this._weightInterpolant;
                if (null !== c) {
                    var d = c.evaluate(a)[0];
                    b *= d, a > c.parameterPositions[1] && (this.stopFading(), 0 === d && (this.enabled = !1))
                }
            }
            return this._effectiveWeight = b, b
        },
        _updateTimeScale: function(a) {
            var b = 0;
            if (!this.paused) {
                b = this.timeScale;
                var c = this._timeScaleInterpolant;
                if (null !== c) {
                    var d = c.evaluate(a)[0];
                    b *= d, a > c.parameterPositions[1] && (this.stopWarping(), 0 === b ? this.pause = !0 : this.timeScale = b)
                }
            }
            return this._effectiveTimeScale = b, b
        },
        _updateTime: function(a) {
            var b = this.time + a;
            if (0 === a) return b;
            var c = this._clip.duration,
                d = this.loop,
                e = this._loopCount,
                f = !1;
            switch (d) {
                case THREE.LoopOnce:
                    if (-1 === e && (
                            // just started
                            this.loopCount = 0, this._setEndings(!0, !0, !1)), b >= c) b = c;
                    else {
                        if (!(0 > b)) break;
                        b = 0
                    }
                    // reached the end
                    this.clampWhenFinished ? this.pause = !0 : this.enabled = !1, this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: 0 > a ? -1 : 1
                    });
                    break;
                case THREE.LoopPingPong:
                    f = !0;
                case THREE.LoopRepeat:
                    if (-1 === e && (
                            // just started
                            a > 0 ? (e = 0, this._setEndings(!0, 0 === this.repetitions, f)) :
                            // when looping in reverse direction, the initial
                            // transition through zero counts as a repetition,
                            // so leave loopCount at -1
                            this._setEndings(0 === this.repetitions, !0, f)), b >= c || 0 > b) {
                        // wrap around
                        var g = Math.floor(b / c); // signed
                        b -= c * g, e += Math.abs(g);
                        var h = this.repetitions - e;
                        if (0 > h) {
                            // stop (switch state, clamp time, fire event)
                            this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, b = a > 0 ? c : 0, this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: a > 0 ? 1 : -1
                            });
                            break
                        }
                        if (0 === h) {
                            // transition to last round
                            var i = 0 > a;
                            this._setEndings(i, !i, f)
                        } else this._setEndings(!1, !1, f);
                        this._loopCount = e, this._mixer.dispatchEvent({
                            type: "loop",
                            action: this,
                            loopDelta: g
                        })
                    }
                    if (d === THREE.LoopPingPong && 1 === (1 & e))
                    // invert time for the "pong round"
                        return this.time = b, c - b
            }
            return this.time = b, b
        },
        _setEndings: function(a, b, c) {
            var d = this._interpolantSettings;
            c ? (d.endingStart = THREE.ZeroSlopeEnding, d.endingEnd = THREE.ZeroSlopeEnding) : (
                // assuming for LoopOnce atStart == atEnd == true
                a ? d.endingStart = this.zeroSlopeAtStart ? THREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding : d.endingStart = THREE.WrapAroundEnding, b ? d.endingEnd = this.zeroSlopeAtEnd ? THREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding : d.endingEnd = THREE.WrapAroundEnding)
        },
        _scheduleFading: function(a, b, c) {
            var d = this._mixer,
                e = d.time,
                f = this._weightInterpolant;
            null === f && (f = d._lendControlInterpolant(), this._weightInterpolant = f);
            var g = f.parameterPositions,
                h = f.sampleValues;
            return g[0] = e, h[0] = b, g[1] = e + a, h[1] = c, this
        }
    },
    // Implementation details:
    Object.assign(THREE.AnimationMixer.prototype, {
        _bindAction: function(a, b) {
            var c = a._localRoot || this._root,
                d = a._clip.tracks,
                e = d.length,
                f = a._propertyBindings,
                g = a._interpolants,
                h = c.uuid,
                i = this._bindingsByRootAndName,
                j = i[h];
            void 0 === j && (j = {}, i[h] = j);
            for (var k = 0; k !== e; ++k) {
                var l = d[k],
                    m = l.name,
                    n = j[m];
                if (void 0 !== n) f[k] = n;
                else {
                    if (n = f[k], void 0 !== n) {
                        // existing binding, make sure the cache knows
                        null === n._cacheIndex && (++n.referenceCount, this._addInactiveBinding(n, h, m));
                        continue
                    }
                    var o = b && b._propertyBindings[k].binding.parsedPath;
                    n = new THREE.PropertyMixer(THREE.PropertyBinding.create(c, m, o), l.ValueTypeName, l.getValueSize()), ++n.referenceCount, this._addInactiveBinding(n, h, m), f[k] = n
                }
                g[k].resultBuffer = n.buffer
            }
        },
        _activateAction: function(a) {
            if (!this._isActiveAction(a)) {
                if (null === a._cacheIndex) {
                    // this action has been forgotten by the cache, but the user
                    // appears to be still using it -> rebind
                    var b = (a._localRoot || this._root).uuid,
                        c = a._clip.name,
                        d = this._actionsByClip[c];
                    this._bindAction(a, d && d.knownActions[0]), this._addInactiveAction(a, c, b)
                }
                // increment reference counts / sort out state
                for (var e = a._propertyBindings, f = 0, g = e.length; f !== g; ++f) {
                    var h = e[f];
                    0 === h.useCount++ && (this._lendBinding(h), h.saveOriginalState())
                }
                this._lendAction(a)
            }
        },
        _deactivateAction: function(a) {
            if (this._isActiveAction(a)) {
                // decrement reference counts / sort out state
                for (var b = a._propertyBindings, c = 0, d = b.length; c !== d; ++c) {
                    var e = b[c];
                    0 === --e.useCount && (e.restoreOriginalState(), this._takeBackBinding(e))
                }
                this._takeBackAction(a)
            }
        },
        // Memory manager
        _initMemoryManager: function() {
            this._actions = [], // 'nActiveActions' followed by inactive ones
                this._nActiveActions = 0, this._actionsByClip = {},
                // inside:
                // {
                // 		knownActions: Array< _Action >	- used as prototypes
                // 		actionByRoot: _Action			- lookup
                // }
                this._bindings = [], // 'nActiveBindings' followed by inactive ones
                this._nActiveBindings = 0, this._bindingsByRootAndName = {}, // inside: Map< name, PropertyMixer >
                this._controlInterpolants = [], // same game as above
                this._nActiveControlInterpolants = 0;
            var a = this;
            this.stats = {
                actions: {get total() {
                        return a._actions.length
                    },
                    get inUse() {
                        return a._nActiveActions
                    }
                },
                bindings: {get total() {
                        return a._bindings.length
                    },
                    get inUse() {
                        return a._nActiveBindings
                    }
                },
                controlInterpolants: {get total() {
                        return a._controlInterpolants.length
                    },
                    get inUse() {
                        return a._nActiveControlInterpolants
                    }
                }
            }
        },
        // Memory management for _Action objects
        _isActiveAction: function(a) {
            var b = a._cacheIndex;
            return null !== b && b < this._nActiveActions
        },
        _addInactiveAction: function(a, b, c) {
            var d = this._actions,
                e = this._actionsByClip,
                f = e[b];
            if (void 0 === f) f = {
                knownActions: [a],
                actionByRoot: {}
            }, a._byClipCacheIndex = 0, e[b] = f;
            else {
                var g = f.knownActions;
                a._byClipCacheIndex = g.length, g.push(a)
            }
            a._cacheIndex = d.length, d.push(a), f.actionByRoot[c] = a
        },
        _removeInactiveAction: function(a) {
            var b = this._actions,
                c = b[b.length - 1],
                d = a._cacheIndex;
            c._cacheIndex = d, b[d] = c, b.pop(), a._cacheIndex = null;
            var e = a._clip.name,
                f = this._actionsByClip,
                g = f[e],
                h = g.knownActions,
                i = h[h.length - 1],
                j = a._byClipCacheIndex;
            i._byClipCacheIndex = j, h[j] = i, h.pop(), a._byClipCacheIndex = null;
            var k = g.actionByRoot,
                l = (b._localRoot || this._root).uuid;
            delete k[l], 0 === h.length && delete f[e], this._removeInactiveBindingsForAction(a)
        },
        _removeInactiveBindingsForAction: function(a) {
            for (var b = a._propertyBindings, c = 0, d = b.length; c !== d; ++c) {
                var e = b[c];
                0 === --e.referenceCount && this._removeInactiveBinding(e)
            }
        },
        _lendAction: function(a) {
            // [ active actions |  inactive actions  ]
            // [  active actions >| inactive actions ]
            //                 s        a
            //                  <-swap->
            //                 a        s
            var b = this._actions,
                c = a._cacheIndex,
                d = this._nActiveActions++,
                e = b[d];
            a._cacheIndex = d, b[d] = a, e._cacheIndex = c, b[c] = e
        },
        _takeBackAction: function(a) {
            // [  active actions  | inactive actions ]
            // [ active actions |< inactive actions  ]
            //        a        s
            //         <-swap->
            //        s        a
            var b = this._actions,
                c = a._cacheIndex,
                d = --this._nActiveActions,
                e = b[d];
            a._cacheIndex = d, b[d] = a, e._cacheIndex = c, b[c] = e
        },
        // Memory management for PropertyMixer objects
        _addInactiveBinding: function(a, b, c) {
            var d = this._bindingsByRootAndName,
                e = d[b],
                f = this._bindings;
            void 0 === e && (e = {}, d[b] = e), e[c] = a, a._cacheIndex = f.length, f.push(a)
        },
        _removeInactiveBinding: function(a) {
            var b = this._bindings,
                c = a.binding,
                d = c.rootNode.uuid,
                e = c.path,
                f = this._bindingsByRootAndName,
                g = f[d],
                h = b[b.length - 1],
                i = a._cacheIndex;
            h._cacheIndex = i, b[i] = h, b.pop(), delete g[e];
            a: {
                for (var j in g) break a;
                delete f[d]
            }
        },
        _lendBinding: function(a) {
            var b = this._bindings,
                c = a._cacheIndex,
                d = this._nActiveBindings++,
                e = b[d];
            a._cacheIndex = d, b[d] = a, e._cacheIndex = c, b[c] = e
        },
        _takeBackBinding: function(a) {
            var b = this._bindings,
                c = a._cacheIndex,
                d = --this._nActiveBindings,
                e = b[d];
            a._cacheIndex = d, b[d] = a, e._cacheIndex = c, b[c] = e
        },
        // Memory management of Interpolants for weight and time scale
        _lendControlInterpolant: function() {
            var a = this._controlInterpolants,
                b = this._nActiveControlInterpolants++,
                c = a[b];
            return void 0 === c && (c = new THREE.LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), c.__cacheIndex = b, a[b] = c), c
        },
        _takeBackControlInterpolant: function(a) {
            var b = this._controlInterpolants,
                c = a.__cacheIndex,
                d = --this._nActiveControlInterpolants,
                e = b[d];
            a.__cacheIndex = d, b[d] = a, e.__cacheIndex = c, b[c] = e
        },
        _controlInterpolantsResultBuffer: new Float32Array(1)
    }),
    // File:src/animation/AnimationObjectGroup.js
    /**
     *
     * A group of objects that receives a shared animation state.
     *
     * Usage:
     *
     * 	-	Add objects you would otherwise pass as 'root' to the
     * 		constructor or the .clipAction method of AnimationMixer.
     *
     * 	-	Instead pass this object as 'root'.
     *
     * 	-	You can also add and remove objects later when the mixer
     * 		is running.
     *
     * Note:
     *
     *  	Objects of this class appear as one object to the mixer,
     *  	so cache control of the individual objects must be done
     *  	on the group.
     *
     * Limitation:
     *
     * 	- 	The animated properties must be compatible among the
     * 		all objects in the group.
     *
     *  -	A single property can either be controlled through a
     *  	target group or directly, but not both.
     *
     * @author tschw
     */
    THREE.AnimationObjectGroup = function(a) {
        this.uuid = THREE.Math.generateUUID(),
            // cached objects followed by the active ones
            this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0; // threshold
        // note: read by PropertyBinding.Composite
        var b = {};
        this._indicesByUUID = b; // for bookkeeping
        for (var c = 0, d = arguments.length; c !== d; ++c) b[arguments[c].uuid] = c;
        this._paths = [], // inside: string
            this._parsedPaths = [], // inside: { we don't care, here }
            this._bindings = [], // inside: Array< PropertyBinding >
            this._bindingsIndicesByPath = {}; // inside: indices in these arrays
        var e = this;
        this.stats = {
            objects: {get total() {
                    return e._objects.length
                },
                get inUse() {
                    return this.total - e.nCachedObjects_
                }
            },
            get bindingsPerObject() {
                return e._bindings.length
            }
        }
    }, THREE.AnimationObjectGroup.prototype = {
        constructor: THREE.AnimationObjectGroup,
        add: function(a) {
            for (var b = this._objects, c = b.length, d = this.nCachedObjects_, e = this._indicesByUUID, f = this._paths, g = this._parsedPaths, h = this._bindings, i = h.length, j = 0, k = arguments.length; j !== k; ++j) {
                var l = arguments[j],
                    m = l.uuid,
                    n = e[m];
                if (void 0 === n) {
                    // unknown object -> add it to the ACTIVE region
                    n = c++, e[m] = n, b.push(l);
                    // accounting is done, now do the same for all bindings
                    for (var o = 0, p = i; o !== p; ++o) h[o].push(new THREE.PropertyBinding(l, f[o], g[o]))
                } else if (d > n) {
                    var q = b[n],
                        r = --d,
                        s = b[r];
                    e[s.uuid] = n, b[n] = s, e[m] = r, b[r] = l;
                    // accounting is done, now do the same for all bindings
                    for (var o = 0, p = i; o !== p; ++o) {
                        var t = h[o],
                            u = t[r],
                            v = t[n];
                        t[n] = u, void 0 === v && (
                            // since we do not bother to create new bindings
                            // for objects that are cached, the binding may
                            // or may not exist
                            v = new THREE.PropertyBinding(l, f[o], g[o])), t[r] = v
                    }
                } else b[n] !== q && console.error("Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes...")
            } // for arguments
            this.nCachedObjects_ = d
        },
        remove: function(a) {
            for (var b = this._objects, c = (b.length, this.nCachedObjects_), d = this._indicesByUUID, e = this._bindings, f = e.length, g = 0, h = arguments.length; g !== h; ++g) {
                var i = arguments[g],
                    j = i.uuid,
                    k = d[j];
                if (void 0 !== k && k >= c) {
                    // move existing object into the CACHED region
                    var l = c++,
                        m = b[l];
                    d[m.uuid] = k, b[k] = m, d[j] = l, b[l] = i;
                    // accounting is done, now do the same for all bindings
                    for (var n = 0, o = f; n !== o; ++n) {
                        var p = e[n],
                            q = p[l],
                            r = p[k];
                        p[k] = q, p[l] = r
                    }
                }
            } // for arguments
            this.nCachedObjects_ = c
        },
        // remove & forget
        uncache: function(a) {
            for (var b = this._objects, c = b.length, d = this.nCachedObjects_, e = this._indicesByUUID, f = this._bindings, g = f.length, h = 0, i = arguments.length; h !== i; ++h) {
                var j = arguments[h],
                    k = j.uuid,
                    l = e[k];
                if (void 0 !== l)
                    if (delete e[k], d > l) {
                        // object is cached, shrink the CACHED region
                        var m = --d,
                            n = b[m],
                            o = --c,
                            p = b[o];
                        // last cached object takes this object's place
                        e[n.uuid] = l, b[l] = n,
                            // last object goes to the activated slot and pop
                            e[p.uuid] = m, b[m] = p, b.pop();
                        // accounting is done, now do the same for all bindings
                        for (var q = 0, r = g; q !== r; ++q) {
                            var s = f[q],
                                t = s[m],
                                u = s[o];
                            s[l] = t, s[m] = u, s.pop()
                        }
                    } else {
                        // object is active, just swap with the last and pop
                        var o = --c,
                            p = b[o];
                        e[p.uuid] = l, b[l] = p, b.pop();
                        // accounting is done, now do the same for all bindings
                        for (var q = 0, r = g; q !== r; ++q) {
                            var s = f[q];
                            s[l] = s[o], s.pop()
                        }
                    }
            } // for arguments
            this.nCachedObjects_ = d
        },
        // Internal interface used by befriended PropertyBinding.Composite:
        subscribe_: function(a, b) {
            // returns an array of bindings for the given path that is changed
            // according to the contained objects in the group
            var c = this._bindingsIndicesByPath,
                d = c[a],
                e = this._bindings;
            if (void 0 !== d) return e[d];
            var f = this._paths,
                g = this._parsedPaths,
                h = this._objects,
                i = h.length,
                j = this.nCachedObjects_,
                k = new Array(i);
            d = e.length, c[a] = d, f.push(a), g.push(b), e.push(k);
            for (var l = j, m = h.length; l !== m; ++l) {
                var n = h[l];
                k[l] = new THREE.PropertyBinding(n, a, b)
            }
            return k
        },
        unsubscribe_: function(a) {
            // tells the group to forget about a property path and no longer
            // update the array previously obtained with 'subscribe_'
            var b = this._bindingsIndicesByPath,
                c = b[a];
            if (void 0 !== c) {
                var d = this._paths,
                    e = this._parsedPaths,
                    f = this._bindings,
                    g = f.length - 1,
                    h = f[g],
                    i = a[g];
                b[i] = c, f[c] = h, f.pop(), e[c] = e[g], e.pop(), d[c] = d[g], d.pop()
            }
        }
    },
    // File:src/animation/AnimationUtils.js
    /**
     * @author tschw
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     */
    THREE.AnimationUtils = {
        // same as Array.prototype.slice, but also works on typed arrays
        arraySlice: function(a, b, c) {
            return THREE.AnimationUtils.isTypedArray(a) ? new a.constructor(a.subarray(b, c)) : a.slice(b, c)
        },
        // converts an array to a specific type
        convertArray: function(a, b, c) { // let 'undefined' and 'null' pass
            return !a || !c && a.constructor === b ? a : "number" == typeof b.BYTES_PER_ELEMENT ? new b(a) : Array.prototype.slice.call(a)
        },
        isTypedArray: function(a) {
            return ArrayBuffer.isView(a) && !(a instanceof DataView)
        },
        // returns an array by which times and values can be sorted
        getKeyframeOrder: function(a) {
            function b(b, c) {
                return a[b] - a[c]
            }
            for (var c = a.length, d = new Array(c), e = 0; e !== c; ++e) d[e] = e;
            return d.sort(b), d
        },
        // uses the array previously returned by 'getKeyframeOrder' to sort data
        sortedArray: function(a, b, c) {
            for (var d = a.length, e = new a.constructor(d), f = 0, g = 0; g !== d; ++f)
                for (var h = c[f] * b, i = 0; i !== b; ++i) e[g++] = a[h + i];
            return e
        },
        // function for parsing AOS keyframe formats
        flattenJSON: function(a, b, c, d) {
            for (var e = 1, f = a[0]; void 0 !== f && void 0 === f[d];) f = a[e++];
            if (void 0 !== f) { // no data
                var g = f[d];
                if (void 0 !== g) // no data
                    if (Array.isArray(g)) {
                    do g = f[d], void 0 !== g && (b.push(f.time), c.push.apply(c, g)), f = a[e++]; while (void 0 !== f)
                } else if (void 0 !== g.toArray) {
                    // ...assume THREE.Math-ish
                    do g = f[d], void 0 !== g && (b.push(f.time), g.toArray(c, c.length)), f = a[e++]; while (void 0 !== f)
                } else
                // otherwise push as-is
                    do g = f[d], void 0 !== g && (b.push(f.time), c.push(g)), f = a[e++]; while (void 0 !== f)
            }
        }
    },
    // File:src/animation/KeyframeTrack.js
    /**
     *
     * A timed sequence of keyframes for a specific property.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */
    THREE.KeyframeTrack = function(a, b, c, d) {
        if (void 0 === a) throw new Error("track name is undefined");
        if (void 0 === b || 0 === b.length) throw new Error("no keyframes in track named " + a);
        this.name = a, this.times = THREE.AnimationUtils.convertArray(b, this.TimeBufferType), this.values = THREE.AnimationUtils.convertArray(c, this.ValueBufferType), this.setInterpolation(d || this.DefaultInterpolation), this.validate(), this.optimize()
    }, THREE.KeyframeTrack.prototype = {
        constructor: THREE.KeyframeTrack,
        TimeBufferType: Float32Array,
        ValueBufferType: Float32Array,
        DefaultInterpolation: THREE.InterpolateLinear,
        InterpolantFactoryMethodDiscrete: function(a) {
            return new THREE.DiscreteInterpolant(this.times, this.values, this.getValueSize(), a)
        },
        InterpolantFactoryMethodLinear: function(a) {
            return new THREE.LinearInterpolant(this.times, this.values, this.getValueSize(), a)
        },
        InterpolantFactoryMethodSmooth: function(a) {
            return new THREE.CubicInterpolant(this.times, this.values, this.getValueSize(), a)
        },
        setInterpolation: function(a) {
            var b = void 0;
            switch (a) {
                case THREE.InterpolateDiscrete:
                    b = this.InterpolantFactoryMethodDiscrete;
                    break;
                case THREE.InterpolateLinear:
                    b = this.InterpolantFactoryMethodLinear;
                    break;
                case THREE.InterpolateSmooth:
                    b = this.InterpolantFactoryMethodSmooth
            }
            if (void 0 === b) {
                var c = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                if (void 0 === this.createInterpolant) {
                    // fall back to default, unless the default itself is messed up
                    if (a === this.DefaultInterpolation) throw new Error(c);
                    this.setInterpolation(this.DefaultInterpolation)
                }
                return void console.warn(c)
            }
            this.createInterpolant = b
        },
        getInterpolation: function() {
            switch (this.createInterpolant) {
                case this.InterpolantFactoryMethodDiscrete:
                    return THREE.InterpolateDiscrete;
                case this.InterpolantFactoryMethodLinear:
                    return THREE.InterpolateLinear;
                case this.InterpolantFactoryMethodSmooth:
                    return THREE.InterpolateSmooth
            }
        },
        getValueSize: function() {
            return this.values.length / this.times.length
        },
        // move all keyframes either forwards or backwards in time
        shift: function(a) {
            if (0 !== a)
                for (var b = this.times, c = 0, d = b.length; c !== d; ++c) b[c] += a;
            return this
        },
        // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
        scale: function(a) {
            if (1 !== a)
                for (var b = this.times, c = 0, d = b.length; c !== d; ++c) b[c] *= a;
            return this
        },
        // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
        // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
        trim: function(a, b) {
            for (var c = this.times, d = c.length, e = 0, f = d - 1; e !== d && c[e] < a;) ++e;
            for (; - 1 !== f && c[f] > b;) --f; // inclusive -> exclusive bound
            if (++f, 0 !== e || f !== d) {
                // empty tracks are forbidden, so keep at least one keyframe
                e >= f && (f = Math.max(f, 1), e = f - 1);
                var g = this.getValueSize();
                this.times = THREE.AnimationUtils.arraySlice(c, e, f), this.values = THREE.AnimationUtils.arraySlice(this.values, e * g, f * g)
            }
            return this
        },
        // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
        validate: function() {
            var a = !0,
                b = this.getValueSize();
            b - Math.floor(b) !== 0 && (console.error("invalid value size in track", this), a = !1);
            var c = this.times,
                d = this.values,
                e = c.length;
            0 === e && (console.error("track is empty", this), a = !1);
            for (var f = null, g = 0; g !== e; g++) {
                var h = c[g];
                if ("number" == typeof h && isNaN(h)) {
                    console.error("time is not a valid number", this, g, h), a = !1;
                    break
                }
                if (null !== f && f > h) {
                    console.error("out of order keys", this, g, h, f), a = !1;
                    break
                }
                f = h
            }
            if (void 0 !== d && THREE.AnimationUtils.isTypedArray(d))
                for (var g = 0, i = d.length; g !== i; ++g) {
                    var j = d[g];
                    if (isNaN(j)) {
                        console.error("value is not a valid number", this, g, j), a = !1;
                        break
                    }
                }
            return a
        },
        // removes equivalent sequential keys as common in morph target sequences
        // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
        optimize: function() {
            for (var a = this.times, b = this.values, c = this.getValueSize(), d = 1, e = 1, f = a.length - 1; f >= e; ++e) {
                var g = !1,
                    h = a[e],
                    i = a[e + 1];
                // remove adjacent keyframes scheduled at the same time
                if (h !== i && (1 !== e || h !== h[0]))
                    for (var j = e * c, k = j - c, l = j + c, m = 0; m !== c; ++m) {
                        var n = b[j + m];
                        if (n !== b[k + m] || n !== b[l + m]) {
                            g = !0;
                            break
                        }
                    }
                    // in-place compaction
                if (g) {
                    if (e !== d) {
                        a[d] = a[e];
                        for (var o = e * c, p = d * c, m = 0; m !== c; ++m) b[p + m] = b[o + m]
                    }++d
                }
            }
            return d !== a.length && (this.times = THREE.AnimationUtils.arraySlice(a, 0, d), this.values = THREE.AnimationUtils.arraySlice(b, 0, d * c)), this
        }
    },
    // Static methods:
    Object.assign(THREE.KeyframeTrack, {
        // Serialization (in static context, because of constructor invocation
        // and automatic invocation of .toJSON):
        parse: function(a) {
            if (void 0 === a.type) throw new Error("track type undefined, can not parse");
            var b = THREE.KeyframeTrack._getTrackTypeForValueTypeName(a.type);
            if (void 0 === a.times) {
                console.warn("legacy JSON format detected, converting");
                var c = [],
                    d = [];
                THREE.AnimationUtils.flattenJSON(a.keys, c, d, "value"), a.times = c, a.values = d
            }
            // derived classes can define a static parse method
            // derived classes can define a static parse method
            return void 0 !== b.parse ? b.parse(a) : new b(a.name, a.times, a.values, a.interpolation)
        },
        toJSON: function(a) {
            var b, c = a.constructor;
            // derived classes can define a static toJSON method
            if (void 0 !== c.toJSON) b = c.toJSON(a);
            else {
                // by default, we assume the data can be serialized as-is
                b = {
                    name: a.name,
                    times: THREE.AnimationUtils.convertArray(a.times, Array),
                    values: THREE.AnimationUtils.convertArray(a.values, Array)
                };
                var d = a.getInterpolation();
                d !== a.DefaultInterpolation && (b.interpolation = d)
            } // mandatory
            return b.type = a.ValueTypeName, b
        },
        _getTrackTypeForValueTypeName: function(a) {
            switch (a.toLowerCase()) {
                case "scalar":
                case "double":
                case "float":
                case "number":
                case "integer":
                    return THREE.NumberKeyframeTrack;
                case "vector":
                case "vector2":
                case "vector3":
                case "vector4":
                    return THREE.VectorKeyframeTrack;
                case "color":
                    return THREE.ColorKeyframeTrack;
                case "quaternion":
                    return THREE.QuaternionKeyframeTrack;
                case "bool":
                case "boolean":
                    return THREE.BooleanKeyframeTrack;
                case "string":
                    return THREE.StringKeyframeTrack
            }
            throw new Error("Unsupported typeName: " + a)
        }
    }),
    // File:src/animation/PropertyBinding.js
    /**
     *
     * A reference to a real property in the scene graph.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */
    THREE.PropertyBinding = function(a, b, c) {
        this.path = b, this.parsedPath = c || THREE.PropertyBinding.parseTrackName(b), this.node = THREE.PropertyBinding.findNode(a, this.parsedPath.nodeName) || a, this.rootNode = a
    }, THREE.PropertyBinding.prototype = {
        constructor: THREE.PropertyBinding,
        getValue: function(a, b) {
            this.bind(), this.getValue(a, b)
        },
        setValue: function(a, b) {
            this.bind(), this.setValue(a, b)
        },
        // create getter / setter pair for a property in the scene graph
        bind: function() {
            var a = this.node,
                b = this.parsedPath,
                c = b.objectName,
                d = b.propertyName,
                e = b.propertyIndex;
            // ensure there is a value node
            if (a || (a = THREE.PropertyBinding.findNode(this.rootNode, b.nodeName) || this.rootNode, this.node = a),
                // set fail state so we can just 'return' on error
                this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !a) return void console.error("  trying to update node for track: " + this.path + " but it wasn't found.");
            if (c) {
                var f = b.objectIndex;
                // special cases were we need to reach deeper into the hierarchy to get the face materials....
                switch (c) {
                    case "materials":
                        if (!a.material) return void console.error("  can not bind to material as node does not have a material", this);
                        if (!a.material.materials) return void console.error("  can not bind to material.materials as node.material does not have a materials array", this);
                        a = a.material.materials;
                        break;
                    case "bones":
                        if (!a.skeleton) return void console.error("  can not bind to bones as node does not have a skeleton", this);
                        // potential future optimization: skip this if propertyIndex is already an integer
                        // and convert the integer string to a true integer.
                        a = a.skeleton.bones;
                        // support resolving morphTarget names into indices.
                        for (var g = 0; g < a.length; g++)
                            if (a[g].name === f) {
                                f = g;
                                break
                            }
                        break;
                    default:
                        if (void 0 === a[c]) return void console.error("  can not bind to objectName of node, undefined", this);
                        a = a[c]
                }
                if (void 0 !== f) {
                    if (void 0 === a[f]) return void console.error("  trying to bind to objectIndex of objectName, but is undefined:", this, a);
                    a = a[f]
                }
            }
            // resolve property
            var h = a[d];
            if (!h) {
                var i = b.nodeName;
                return void console.error("  trying to update property for track: " + i + "." + d + " but it wasn't found.", a)
            }
            // determine versioning scheme
            var j = this.Versioning.None;
            void 0 !== a.needsUpdate ? (j = this.Versioning.NeedsUpdate, this.targetObject = a) : void 0 !== a.matrixWorldNeedsUpdate && (j = this.Versioning.MatrixWorldNeedsUpdate, this.targetObject = a);
            // determine how the property gets bound
            var k = this.BindingType.Direct;
            if (void 0 !== e) {
                // access a sub element of the property array (only primitives are supported right now)
                if ("morphTargetInfluences" === d) {
                    // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
                    // support resolving morphTarget names into indices.
                    if (!a.geometry) return void console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry", this);
                    if (!a.geometry.morphTargets) return void console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets", this);
                    for (var g = 0; g < this.node.geometry.morphTargets.length; g++)
                        if (a.geometry.morphTargets[g].name === e) {
                            e = g;
                            break
                        }
                }
                k = this.BindingType.ArrayElement, this.resolvedProperty = h, this.propertyIndex = e
            } else void 0 !== h.fromArray && void 0 !== h.toArray ? (k = this.BindingType.HasFromToArray, this.resolvedProperty = h) : void 0 !== h.length ? (k = this.BindingType.EntireArray, this.resolvedProperty = h) : this.propertyName = d;
            // select getter / setter
            this.getValue = this.GetterByBindingType[k], this.setValue = this.SetterByBindingTypeAndVersioning[k][j]
        },
        unbind: function() {
            this.node = null,
                // back to the prototype version of getValue / setValue
                // note: avoiding to mutate the shape of 'this' via 'delete'
                this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
        }
    }, Object.assign(THREE.PropertyBinding.prototype, { // prototype, continued
        // these are used to "bind" a nonexistent property
        _getValue_unavailable: function() {},
        _setValue_unavailable: function() {},
        // initial state of these methods that calls 'bind'
        _getValue_unbound: THREE.PropertyBinding.prototype.getValue,
        _setValue_unbound: THREE.PropertyBinding.prototype.setValue,
        BindingType: {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        },
        Versioning: {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        },
        GetterByBindingType: [function(a, b) {
            a[b] = this.node[this.propertyName]
        }, function(a, b) {
            for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) a[b++] = c[d]
        }, function(a, b) {
            a[b] = this.resolvedProperty[this.propertyIndex]
        }, function(a, b) {
            this.resolvedProperty.toArray(a, b)
        }],
        SetterByBindingTypeAndVersioning: [
            [
                // Direct
                function(a, b) {
                    this.node[this.propertyName] = a[b]
                },
                function(a, b) {
                    this.node[this.propertyName] = a[b], this.targetObject.needsUpdate = !0
                },
                function(a, b) {
                    this.node[this.propertyName] = a[b], this.targetObject.matrixWorldNeedsUpdate = !0
                }
            ],
            [
                // EntireArray
                function(a, b) {
                    for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) c[d] = a[b++]
                },
                function(a, b) {
                    for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) c[d] = a[b++];
                    this.targetObject.needsUpdate = !0
                },
                function(a, b) {
                    for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) c[d] = a[b++];
                    this.targetObject.matrixWorldNeedsUpdate = !0
                }
            ],
            [
                // ArrayElement
                function(a, b) {
                    this.resolvedProperty[this.propertyIndex] = a[b]
                },
                function(a, b) {
                    this.resolvedProperty[this.propertyIndex] = a[b], this.targetObject.needsUpdate = !0
                },
                function(a, b) {
                    this.resolvedProperty[this.propertyIndex] = a[b], this.targetObject.matrixWorldNeedsUpdate = !0
                }
            ],
            [
                // HasToFromArray
                function(a, b) {
                    this.resolvedProperty.fromArray(a, b)
                },
                function(a, b) {
                    this.resolvedProperty.fromArray(a, b), this.targetObject.needsUpdate = !0
                },
                function(a, b) {
                    this.resolvedProperty.fromArray(a, b), this.targetObject.matrixWorldNeedsUpdate = !0
                }
            ]
        ]
    }), THREE.PropertyBinding.Composite = function(a, b, c) {
        var d = c || THREE.PropertyBinding.parseTrackName(b);
        this._targetGroup = a, this._bindings = a.subscribe_(b, d)
    }, THREE.PropertyBinding.Composite.prototype = {
        constructor: THREE.PropertyBinding.Composite,
        getValue: function(a, b) {
            this.bind(); // bind all binding
            var c = this._targetGroup.nCachedObjects_,
                d = this._bindings[c];
            // and only call .getValue on the first
            void 0 !== d && d.getValue(a, b)
        },
        setValue: function(a, b) {
            for (var c = this._bindings, d = this._targetGroup.nCachedObjects_, e = c.length; d !== e; ++d) c[d].setValue(a, b)
        },
        bind: function() {
            for (var a = this._bindings, b = this._targetGroup.nCachedObjects_, c = a.length; b !== c; ++b) a[b].bind()
        },
        unbind: function() {
            for (var a = this._bindings, b = this._targetGroup.nCachedObjects_, c = a.length; b !== c; ++b) a[b].unbind()
        }
    }, THREE.PropertyBinding.create = function(a, b, c) {
        return a instanceof THREE.AnimationObjectGroup ? new THREE.PropertyBinding.Composite(a, b, c) : new THREE.PropertyBinding(a, b, c)
    }, THREE.PropertyBinding.parseTrackName = function(a) {
        // matches strings in the form of:
        //    nodeName.property
        //    nodeName.property[accessor]
        //    nodeName.material.property[accessor]
        //    uuid.property[accessor]
        //    uuid.objectName[objectIndex].propertyName[propertyIndex]
        //    parentName/nodeName.property
        //    parentName/parentName/nodeName.property[index]
        //	  .bone[Armature.DEF_cog].position
        // created and tested via https://regex101.com/#javascript
        var b = /^(([\w]+\/)*)([\w-\d]+)?(\.([\w]+)(\[([\w\d\[\]\_. ]+)\])?)?(\.([\w.]+)(\[([\w\d\[\]\_. ]+)\])?)$/,
            c = b.exec(a);
        if (!c) throw new Error("cannot parse trackName at all: " + a);
        c.index === b.lastIndex && b.lastIndex++;
        var d = {
            // directoryName: matches[1], // (tschw) currently unused
            nodeName: c[3], // allowed to be null, specified root node.
            objectName: c[5],
            objectIndex: c[7],
            propertyName: c[9],
            propertyIndex: c[11]
        };
        if (null === d.propertyName || 0 === d.propertyName.length) throw new Error("can not parse propertyName from trackName: " + a);
        return d
    }, THREE.PropertyBinding.findNode = function(a, b) {
        if (!b || "" === b || "root" === b || "." === b || -1 === b || b === a.name || b === a.uuid) return a;
        // search into skeleton bones.
        if (a.skeleton) {
            var c = function(a) {
                    for (var c = 0; c < a.bones.length; c++) {
                        var d = a.bones[c];
                        if (d.name === b) return d
                    }
                    return null
                },
                d = c(a.skeleton);
            if (d) return d
        }
        // search into node subtree.
        if (a.children) {
            var e = function(a) {
                    for (var c = 0; c < a.length; c++) {
                        var d = a[c];
                        if (d.name === b || d.uuid === b) return d;
                        var f = e(d.children);
                        if (f) return f
                    }
                    return null
                },
                f = e(a.children);
            if (f) return f
        }
        return null
    },
    // File:src/animation/PropertyMixer.js
    /**
     *
     * Buffered scene graph property that allows weighted accumulation.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */
    THREE.PropertyMixer = function(a, b, c) {
        this.binding = a, this.valueSize = c;
        var d, e = Float64Array;
        switch (b) {
            case "quaternion":
                d = this._slerp;
                break;
            case "string":
            case "bool":
                e = Array, d = this._select;
                break;
            default:
                d = this._lerp
        }
        this.buffer = new e(4 * c),
            // layout: [ incoming | accu0 | accu1 | orig ]
            //
            // interpolators can use .buffer as their .result
            // the data then goes to 'incoming'
            //
            // 'accu0' and 'accu1' are used frame-interleaved for
            // the cumulative result and are compared to detect
            // changes
            //
            // 'orig' stores the original state of the property
            this._mixBufferRegion = d, this.cumulativeWeight = 0, this.useCount = 0, this.referenceCount = 0
    }, THREE.PropertyMixer.prototype = {
        constructor: THREE.PropertyMixer,
        // accumulate data in the 'incoming' region into 'accu<i>'
        accumulate: function(a, b) {
            // note: happily accumulating nothing when weight = 0, the caller knows
            // the weight and shouldn't have made the call in the first place
            var c = this.buffer,
                d = this.valueSize,
                e = a * d + d,
                f = this.cumulativeWeight;
            if (0 === f) {
                // accuN := incoming * weight
                for (var g = 0; g !== d; ++g) c[e + g] = c[g];
                f = b
            } else {
                // accuN := accuN + incoming * weight
                f += b;
                var h = b / f;
                this._mixBufferRegion(c, e, 0, h, d)
            }
            this.cumulativeWeight = f
        },
        // apply the state of 'accu<i>' to the binding when accus differ
        apply: function(a) {
            var b = this.valueSize,
                c = this.buffer,
                d = a * b + b,
                e = this.cumulativeWeight,
                f = this.binding;
            if (this.cumulativeWeight = 0, 1 > e) {
                // accuN := accuN + original * ( 1 - cumulativeWeight )
                var g = 3 * b;
                this._mixBufferRegion(c, d, g, 1 - e, b)
            }
            for (var h = b, i = b + b; h !== i; ++h)
                if (c[h] !== c[h + b]) {
                    // value has changed -> update scene graph
                    f.setValue(c, d);
                    break
                }
        },
        // remember the state of the bound property and copy it to both accus
        saveOriginalState: function() {
            var a = this.binding,
                b = this.buffer,
                c = this.valueSize,
                d = 3 * c;
            a.getValue(b, d);
            // accu[0..1] := orig -- initially detect changes against the original
            for (var e = c, f = d; e !== f; ++e) b[e] = b[d + e % c];
            this.cumulativeWeight = 0
        },
        // apply the state previously taken via 'saveOriginalState' to the binding
        restoreOriginalState: function() {
            var a = 3 * this.valueSize;
            this.binding.setValue(this.buffer, a)
        },
        // mix functions
        _select: function(a, b, c, d, e) {
            if (d >= .5)
                for (var f = 0; f !== e; ++f) a[b + f] = a[c + f]
        },
        _slerp: function(a, b, c, d, e) {
            THREE.Quaternion.slerpFlat(a, b, a, b, a, c, d)
        },
        _lerp: function(a, b, c, d, e) {
            for (var f = 1 - d, g = 0; g !== e; ++g) {
                var h = b + g;
                a[h] = a[h] * f + a[c + g] * d
            }
        }
    },
    // File:src/animation/tracks/BooleanKeyframeTrack.js
    /**
     *
     * A Track of Boolean keyframe values.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */
    THREE.BooleanKeyframeTrack = function(a, b, c) {
        THREE.KeyframeTrack.call(this, a, b, c)
    }, THREE.BooleanKeyframeTrack.prototype = Object.assign(Object.create(THREE.KeyframeTrack.prototype), {
        constructor: THREE.BooleanKeyframeTrack,
        ValueTypeName: "bool",
        ValueBufferType: Array,
        DefaultInterpolation: THREE.IntepolateDiscrete,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }),
    // File:src/animation/tracks/NumberKeyframeTrack.js
    /**
     *
     * A Track of numeric keyframe values.
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */
    THREE.NumberKeyframeTrack = function(a, b, c, d) {
        THREE.KeyframeTrack.call(this, a, b, c, d)
    }, THREE.NumberKeyframeTrack.prototype = Object.assign(Object.create(THREE.KeyframeTrack.prototype), {
        constructor: THREE.NumberKeyframeTrack,
        ValueTypeName: "number"
    }),
    // File:src/animation/tracks/QuaternionKeyframeTrack.js
    /**
     *
     * A Track of quaternion keyframe values.
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */
    THREE.QuaternionKeyframeTrack = function(a, b, c, d) {
        THREE.KeyframeTrack.call(this, a, b, c, d)
    }, THREE.QuaternionKeyframeTrack.prototype = Object.assign(Object.create(THREE.KeyframeTrack.prototype), {
        constructor: THREE.QuaternionKeyframeTrack,
        ValueTypeName: "quaternion",
        // ValueBufferType is inherited
        DefaultInterpolation: THREE.InterpolateLinear,
        InterpolantFactoryMethodLinear: function(a) {
            return new THREE.QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), a)
        },
        InterpolantFactoryMethodSmooth: void 0
    }),
    // File:src/animation/tracks/StringKeyframeTrack.js
    /**
     *
     * A Track that interpolates Strings
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */
    THREE.StringKeyframeTrack = function(a, b, c, d) {
        THREE.KeyframeTrack.call(this, a, b, c, d)
    }, THREE.StringKeyframeTrack.prototype = Object.assign(Object.create(THREE.KeyframeTrack.prototype), {
        constructor: THREE.StringKeyframeTrack,
        ValueTypeName: "string",
        ValueBufferType: Array,
        DefaultInterpolation: THREE.IntepolateDiscrete,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }),
    // File:src/animation/tracks/VectorKeyframeTrack.js
    /**
     *
     * A Track of vectored keyframe values.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */
    THREE.VectorKeyframeTrack = function(a, b, c, d) {
        THREE.KeyframeTrack.call(this, a, b, c, d)
    }, THREE.VectorKeyframeTrack.prototype = Object.assign(Object.create(THREE.KeyframeTrack.prototype), {
        constructor: THREE.VectorKeyframeTrack,
        ValueTypeName: "vector"
    }),
    // File:src/audio/Audio.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.Audio = function(a) {
        THREE.Object3D.call(this), this.type = "Audio", this.context = a.context, this.source = this.context.createBufferSource(), this.source.onended = this.onEnded.bind(this), this.gain = this.context.createGain(), this.gain.connect(a.getInput()), this.autoplay = !1, this.startTime = 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filter = null
    }, THREE.Audio.prototype = Object.create(THREE.Object3D.prototype), THREE.Audio.prototype.constructor = THREE.Audio, THREE.Audio.prototype.getOutput = function() {
        return this.gain
    }, THREE.Audio.prototype.load = function(a) {
        var b = new THREE.AudioBuffer(this.context);
        return b.load(a), this.setBuffer(b), this
    }, THREE.Audio.prototype.setNodeSource = function(a) {
        return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = a, this.connect(), this
    }, THREE.Audio.prototype.setBuffer = function(a) {
        var b = this;
        return a.onReady(function(a) {
            b.source.buffer = a, b.sourceType = "buffer", b.autoplay && b.play()
        }), this
    }, THREE.Audio.prototype.play = function() {
        if (this.isPlaying === !0) return void console.warn("THREE.Audio: Audio is already playing.");
        if (this.hasPlaybackControl === !1) return void console.warn("THREE.Audio: this Audio has no playback control.");
        var a = this.context.createBufferSource();
        a.buffer = this.source.buffer, a.loop = this.source.loop, a.onended = this.source.onended, a.start(0, this.startTime), a.playbackRate.value = this.playbackRate, this.isPlaying = !0, this.source = a, this.connect()
    }, THREE.Audio.prototype.pause = function() {
        return this.hasPlaybackControl === !1 ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.source.stop(), void(this.startTime = this.context.currentTime))
    }, THREE.Audio.prototype.stop = function() {
        return this.hasPlaybackControl === !1 ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.source.stop(), void(this.startTime = 0))
    }, THREE.Audio.prototype.connect = function() {
        null !== this.filter ? (this.source.connect(this.filter), this.filter.connect(this.getOutput())) : this.source.connect(this.getOutput())
    }, THREE.Audio.prototype.disconnect = function() {
        null !== this.filter ? (this.source.disconnect(this.filter), this.filter.disconnect(this.getOutput())) : this.source.disconnect(this.getOutput())
    }, THREE.Audio.prototype.getFilter = function() {
        return this.filter
    }, THREE.Audio.prototype.setFilter = function(a) {
        void 0 === a && (a = null), this.isPlaying === !0 ? (this.disconnect(), this.filter = a, this.connect()) : this.filter = a
    }, THREE.Audio.prototype.setPlaybackRate = function(a) {
        return this.hasPlaybackControl === !1 ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.playbackRate = a, void(this.isPlaying === !0 && (this.source.playbackRate.value = this.playbackRate)))
    }, THREE.Audio.prototype.getPlaybackRate = function() {
        return this.playbackRate
    }, THREE.Audio.prototype.onEnded = function() {
        this.isPlaying = !1
    }, THREE.Audio.prototype.setLoop = function(a) {
        return this.hasPlaybackControl === !1 ? void console.warn("THREE.Audio: this Audio has no playback control.") : void(this.source.loop = a)
    }, THREE.Audio.prototype.getLoop = function() {
        return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.source.loop
    }, THREE.Audio.prototype.setVolume = function(a) {
        this.gain.gain.value = a
    }, THREE.Audio.prototype.getVolume = function() {
        return this.gain.gain.value
    },
    // File:src/audio/AudioAnalyser.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.AudioAnalyser = function(a, b) {
        this.analyser = a.context.createAnalyser(), this.analyser.fftSize = void 0 !== b ? b : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), a.getOutput().connect(this.analyser)
    }, THREE.AudioAnalyser.prototype = {
        constructor: THREE.AudioAnalyser,
        getData: function() {
            return this.analyser.getByteFrequencyData(this.data), this.data
        }
    },
    // File:src/audio/AudioBuffer.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.AudioBuffer = function(a) {
        this.context = a, this.ready = !1, this.readyCallbacks = []
    }, THREE.AudioBuffer.prototype.load = function(a) {
        var b = this,
            c = new XMLHttpRequest;
        return c.open("GET", a, !0), c.responseType = "arraybuffer", c.onload = function(a) {
            b.context.decodeAudioData(this.response, function(a) {
                b.buffer = a, b.ready = !0;
                for (var c = 0; c < b.readyCallbacks.length; c++) b.readyCallbacks[c](b.buffer);
                b.readyCallbacks = []
            })
        }, c.send(), this
    }, THREE.AudioBuffer.prototype.onReady = function(a) {
        this.ready ? a(this.buffer) : this.readyCallbacks.push(a)
    },
    // File:src/audio/PositionalAudio.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.PositionalAudio = function(a) {
        THREE.Audio.call(this, a), this.panner = this.context.createPanner(), this.panner.connect(this.gain)
    }, THREE.PositionalAudio.prototype = Object.create(THREE.Audio.prototype), THREE.PositionalAudio.prototype.constructor = THREE.PositionalAudio, THREE.PositionalAudio.prototype.getOutput = function() {
        return this.panner
    }, THREE.PositionalAudio.prototype.setRefDistance = function(a) {
        this.panner.refDistance = a
    }, THREE.PositionalAudio.prototype.getRefDistance = function() {
        return this.panner.refDistance
    }, THREE.PositionalAudio.prototype.setRolloffFactor = function(a) {
        this.panner.rolloffFactor = a
    }, THREE.PositionalAudio.prototype.getRolloffFactor = function() {
        return this.panner.rolloffFactor
    }, THREE.PositionalAudio.prototype.setDistanceModel = function(a) {
        this.panner.distanceModel = a
    }, THREE.PositionalAudio.prototype.getDistanceModel = function() {
        return this.panner.distanceModel
    }, THREE.PositionalAudio.prototype.setMaxDistance = function(a) {
        this.panner.maxDistance = a
    }, THREE.PositionalAudio.prototype.getMaxDistance = function() {
        return this.panner.maxDistance
    }, THREE.PositionalAudio.prototype.updateMatrixWorld = function() {
        var a = new THREE.Vector3;
        return function(b) {
            THREE.Object3D.prototype.updateMatrixWorld.call(this, b), a.setFromMatrixPosition(this.matrixWorld), this.panner.setPosition(a.x, a.y, a.z)
        }
    }(),
    // File:src/audio/AudioListener.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.AudioListener = function() {
        THREE.Object3D.call(this), this.type = "AudioListener", this.context = new(window.AudioContext || window.webkitAudioContext), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null
    }, THREE.AudioListener.prototype = Object.create(THREE.Object3D.prototype), THREE.AudioListener.prototype.constructor = THREE.AudioListener, THREE.AudioListener.prototype.getInput = function() {
        return this.gain
    }, THREE.AudioListener.prototype.removeFilter = function() {
        null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null)
    }, THREE.AudioListener.prototype.setFilter = function(a) {
        null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = a, this.gain.connect(this.filter), this.filter.connect(this.context.destination)
    }, THREE.AudioListener.prototype.getFilter = function() {
        return this.filter
    }, THREE.AudioListener.prototype.setMasterVolume = function(a) {
        this.gain.gain.value = a
    }, THREE.AudioListener.prototype.getMasterVolume = function() {
        return this.gain.gain.value
    }, THREE.AudioListener.prototype.updateMatrixWorld = function() {
        var a = new THREE.Vector3,
            b = new THREE.Quaternion,
            c = new THREE.Vector3,
            d = new THREE.Vector3;
        return function(e) {
            THREE.Object3D.prototype.updateMatrixWorld.call(this, e);
            var f = this.context.listener,
                g = this.up;
            this.matrixWorld.decompose(a, b, c), d.set(0, 0, -1).applyQuaternion(b), f.setPosition(a.x, a.y, a.z), f.setOrientation(d.x, d.y, d.z, g.x, g.y, g.z)
        }
    }(),
    // File:src/cameras/Camera.js
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author mikael emtinger / http://gomo.se/
     * @author WestLangley / http://github.com/WestLangley
     */
    THREE.Camera = function() {
        THREE.Object3D.call(this), this.type = "Camera", this.matrixWorldInverse = new THREE.Matrix4, this.projectionMatrix = new THREE.Matrix4
    }, THREE.Camera.prototype = Object.create(THREE.Object3D.prototype), THREE.Camera.prototype.constructor = THREE.Camera, THREE.Camera.prototype.getWorldDirection = function() {
        var a = new THREE.Quaternion;
        return function(b) {
            var c = b || new THREE.Vector3;
            return this.getWorldQuaternion(a), c.set(0, 0, -1).applyQuaternion(a)
        }
    }(), THREE.Camera.prototype.lookAt = function() {
        // This routine does not support cameras with rotated and/or translated parent(s)
        var a = new THREE.Matrix4;
        return function(b) {
            a.lookAt(this.position, b, this.up), this.quaternion.setFromRotationMatrix(a)
        }
    }(), THREE.Camera.prototype.clone = function() {
        return (new this.constructor).copy(this)
    }, THREE.Camera.prototype.copy = function(a) {
        return THREE.Object3D.prototype.copy.call(this, a), this.matrixWorldInverse.copy(a.matrixWorldInverse), this.projectionMatrix.copy(a.projectionMatrix), this
    },
    // File:src/cameras/CubeCamera.js
    /**
     * Camera for rendering cube maps
     *	- renders scene into axis-aligned cube
     *
     * @author alteredq / http://alteredqualia.com/
     */
    THREE.CubeCamera = function(a, b, c) {
        THREE.Object3D.call(this), this.type = "CubeCamera";
        var d = 90,
            e = 1,
            f = new THREE.PerspectiveCamera(d, e, a, b);
        f.up.set(0, -1, 0), f.lookAt(new THREE.Vector3(1, 0, 0)), this.add(f);
        var g = new THREE.PerspectiveCamera(d, e, a, b);
        g.up.set(0, -1, 0), g.lookAt(new THREE.Vector3(-1, 0, 0)), this.add(g);
        var h = new THREE.PerspectiveCamera(d, e, a, b);
        h.up.set(0, 0, 1), h.lookAt(new THREE.Vector3(0, 1, 0)), this.add(h);
        var i = new THREE.PerspectiveCamera(d, e, a, b);
        i.up.set(0, 0, -1), i.lookAt(new THREE.Vector3(0, -1, 0)), this.add(i);
        var j = new THREE.PerspectiveCamera(d, e, a, b);
        j.up.set(0, -1, 0), j.lookAt(new THREE.Vector3(0, 0, 1)), this.add(j);
        var k = new THREE.PerspectiveCamera(d, e, a, b);
        k.up.set(0, -1, 0), k.lookAt(new THREE.Vector3(0, 0, -1)), this.add(k);
        var l = {
            format: THREE.RGBFormat,
            magFilter: THREE.LinearFilter,
            minFilter: THREE.LinearFilter
        };
        this.renderTarget = new THREE.WebGLRenderTargetCube(c, c, l), this.updateCubeMap = function(a, b) {
            null === this.parent && this.updateMatrixWorld();
            var c = this.renderTarget,
                d = c.texture.generateMipmaps;
            c.texture.generateMipmaps = !1, c.activeCubeFace = 0, a.render(b, f, c), c.activeCubeFace = 1, a.render(b, g, c), c.activeCubeFace = 2, a.render(b, h, c), c.activeCubeFace = 3, a.render(b, i, c), c.activeCubeFace = 4, a.render(b, j, c), c.texture.generateMipmaps = d, c.activeCubeFace = 5, a.render(b, k, c), a.setRenderTarget(null)
        }
    }, THREE.CubeCamera.prototype = Object.create(THREE.Object3D.prototype), THREE.CubeCamera.prototype.constructor = THREE.CubeCamera,
    // File:src/cameras/OrthographicCamera.js
    /**
     * @author alteredq / http://alteredqualia.com/
     */
    THREE.OrthographicCamera = function(a, b, c, d, e, f) {
        THREE.Camera.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.left = a, this.right = b, this.top = c, this.bottom = d, this.near = void 0 !== e ? e : .1, this.far = void 0 !== f ? f : 2e3, this.updateProjectionMatrix()
    }, THREE.OrthographicCamera.prototype = Object.create(THREE.Camera.prototype), THREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera, THREE.OrthographicCamera.prototype.updateProjectionMatrix = function() {
        var a = (this.right - this.left) / (2 * this.zoom),
            b = (this.top - this.bottom) / (2 * this.zoom),
            c = (this.right + this.left) / 2,
            d = (this.top + this.bottom) / 2;
        this.projectionMatrix.makeOrthographic(c - a, c + a, d + b, d - b, this.near, this.far)
    }, THREE.OrthographicCamera.prototype.copy = function(a) {
        return THREE.Camera.prototype.copy.call(this, a), this.left = a.left, this.right = a.right, this.top = a.top, this.bottom = a.bottom, this.near = a.near, this.far = a.far, this.zoom = a.zoom, this
    }, THREE.OrthographicCamera.prototype.toJSON = function(a) {
        var b = THREE.Object3D.prototype.toJSON.call(this, a);
        return b.object.zoom = this.zoom, b.object.left = this.left, b.object.right = this.right, b.object.top = this.top, b.object.bottom = this.bottom, b.object.near = this.near, b.object.far = this.far, b
    },
    // File:src/cameras/PerspectiveCamera.js
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author greggman / http://games.greggman.com/
     * @author zz85 / http://www.lab4games.net/zz85/blog
     */
    THREE.PerspectiveCamera = function(a, b, c, d) {
        THREE.Camera.call(this), this.type = "PerspectiveCamera", this.focalLength = 10, this.zoom = 1, this.fov = void 0 !== a ? a : 50, this.aspect = void 0 !== b ? b : 1, this.near = void 0 !== c ? c : .1, this.far = void 0 !== d ? d : 2e3, this.updateProjectionMatrix()
    }, THREE.PerspectiveCamera.prototype = Object.create(THREE.Camera.prototype), THREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera,
    /**
     * Uses Focal Length (in mm) to estimate and set FOV
     * 35mm (full-frame) camera is used if frame size is not specified;
     * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
     */
    THREE.PerspectiveCamera.prototype.setLens = function(a, b) {
        void 0 === b && (b = 24), this.fov = 2 * THREE.Math.radToDeg(Math.atan(b / (2 * a))), this.updateProjectionMatrix()
    },
    /**
     * Sets an offset in a larger frustum. This is useful for multi-window or
     * multi-monitor/multi-machine setups.
     *
     * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
     * the monitors are in grid like this
     *
     *   +---+---+---+
     *   | A | B | C |
     *   +---+---+---+
     *   | D | E | F |
     *   +---+---+---+
     *
     * then for each monitor you would call it like this
     *
     *   var w = 1920;
     *   var h = 1080;
     *   var fullWidth = w * 3;
     *   var fullHeight = h * 2;
     *
     *   --A--
     *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
     *   --B--
     *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
     *   --C--
     *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
     *   --D--
     *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
     *   --E--
     *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
     *   --F--
     *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
     *
     *   Note there is no reason monitors have to be the same size or in a grid.
     */
    THREE.PerspectiveCamera.prototype.setViewOffset = function(a, b, c, d, e, f) {
        this.fullWidth = a, this.fullHeight = b, this.x = c, this.y = d, this.width = e, this.height = f, this.updateProjectionMatrix()
    }, THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function() {
        var a = THREE.Math.radToDeg(2 * Math.atan(Math.tan(.5 * THREE.Math.degToRad(this.fov)) / this.zoom));
        if (this.fullWidth) {
            var b = this.fullWidth / this.fullHeight,
                c = Math.tan(THREE.Math.degToRad(.5 * a)) * this.near,
                d = -c,
                e = b * d,
                f = b * c,
                g = Math.abs(f - e),
                h = Math.abs(c - d);
            this.projectionMatrix.makeFrustum(e + this.x * g / this.fullWidth, e + (this.x + this.width) * g / this.fullWidth, c - (this.y + this.height) * h / this.fullHeight, c - this.y * h / this.fullHeight, this.near, this.far)
        } else this.projectionMatrix.makePerspective(a, this.aspect, this.near, this.far)
    }, THREE.PerspectiveCamera.prototype.copy = function(a) {
        return THREE.Camera.prototype.copy.call(this, a), this.focalLength = a.focalLength, this.zoom = a.zoom, this.fov = a.fov, this.aspect = a.aspect, this.near = a.near, this.far = a.far, this
    }, THREE.PerspectiveCamera.prototype.toJSON = function(a) {
        var b = THREE.Object3D.prototype.toJSON.call(this, a);
        return b.object.focalLength = this.focalLength, b.object.zoom = this.zoom, b.object.fov = this.fov, b.object.aspect = this.aspect, b.object.near = this.near, b.object.far = this.far, b
    },
    // File:src/cameras/StereoCamera.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.StereoCamera = function() {
        this.type = "StereoCamera", this.aspect = 1, this.cameraL = new THREE.PerspectiveCamera, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new THREE.PerspectiveCamera, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1
    }, THREE.StereoCamera.prototype = {
        constructor: THREE.StereoCamera,
        update: function() {
            var a, b, c, d, e, f = new THREE.Matrix4,
                g = new THREE.Matrix4;
            return function(h) {
                var i = a !== h.focalLength || b !== h.fov || c !== h.aspect * this.aspect || d !== h.near || e !== h.far;
                if (i) {
                    a = h.focalLength, b = h.fov, c = h.aspect * this.aspect, d = h.near, e = h.far;
                    // Off-axis stereoscopic effect based on
                    // http://paulbourke.net/stereographics/stereorender/
                    var j, k, l = h.projectionMatrix.clone(),
                        m = .032,
                        n = m * d / a,
                        o = d * Math.tan(THREE.Math.degToRad(.5 * b));
                    // translate xOffset
                    g.elements[12] = -m, f.elements[12] = m,
                        // for left eye
                        j = -o * c + n, k = o * c + n, l.elements[0] = 2 * d / (k - j), l.elements[8] = (k + j) / (k - j), this.cameraL.projectionMatrix.copy(l),
                        // for right eye
                        j = -o * c - n, k = o * c - n, l.elements[0] = 2 * d / (k - j), l.elements[8] = (k + j) / (k - j), this.cameraR.projectionMatrix.copy(l)
                }
                this.cameraL.matrixWorld.copy(h.matrixWorld).multiply(g), this.cameraR.matrixWorld.copy(h.matrixWorld).multiply(f)
            }
        }()
    },
    // File:src/lights/Light.js
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */
    THREE.Light = function(a, b) {
        THREE.Object3D.call(this), this.type = "Light", this.color = new THREE.Color(a), this.intensity = void 0 !== b ? b : 1, this.receiveShadow = void 0
    }, THREE.Light.prototype = Object.create(THREE.Object3D.prototype), THREE.Light.prototype.constructor = THREE.Light, THREE.Light.prototype.copy = function(a) {
        return THREE.Object3D.prototype.copy.call(this, a), this.color.copy(a.color), this.intensity = a.intensity, this
    }, THREE.Light.prototype.toJSON = function(a) {
        var b = THREE.Object3D.prototype.toJSON.call(this, a);
        return b.object.color = this.color.getHex(), b.object.intensity = this.intensity, void 0 !== this.groundColor && (b.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (b.object.distance = this.distance), void 0 !== this.angle && (b.object.angle = this.angle), void 0 !== this.decay && (b.object.decay = this.decay), void 0 !== this.exponent && (b.object.exponent = this.exponent), b
    },
    // File:src/lights/LightShadow.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.LightShadow = function(a) {
        this.camera = a, this.bias = 0, this.radius = 1, this.mapSize = new THREE.Vector2(512, 512), this.map = null, this.matrix = new THREE.Matrix4
    }, THREE.LightShadow.prototype = {
        constructor: THREE.LightShadow,
        copy: function(a) {
            return this.camera = a.camera.clone(), this.bias = a.bias, this.radius = a.radius, this.mapSize.copy(a.mapSize), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    },
    // File:src/lights/AmbientLight.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.AmbientLight = function(a, b) {
        THREE.Light.call(this, a, b), this.type = "AmbientLight", this.castShadow = void 0
    }, THREE.AmbientLight.prototype = Object.create(THREE.Light.prototype), THREE.AmbientLight.prototype.constructor = THREE.AmbientLight,
    // File:src/lights/DirectionalLight.js
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */
    THREE.DirectionalLight = function(a, b) {
        THREE.Light.call(this, a, b), this.type = "DirectionalLight", this.position.set(0, 1, 0), this.updateMatrix(), this.target = new THREE.Object3D, this.shadow = new THREE.LightShadow(new THREE.OrthographicCamera(-5, 5, 5, -5, .5, 500))
    }, THREE.DirectionalLight.prototype = Object.create(THREE.Light.prototype), THREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight, THREE.DirectionalLight.prototype.copy = function(a) {
        return THREE.Light.prototype.copy.call(this, a), this.target = a.target.clone(), this.shadow = a.shadow.clone(), this
    },
    // File:src/lights/HemisphereLight.js
    /**
     * @author alteredq / http://alteredqualia.com/
     */
    THREE.HemisphereLight = function(a, b, c) {
        THREE.Light.call(this, a, c), this.type = "HemisphereLight", this.castShadow = void 0, this.position.set(0, 1, 0), this.updateMatrix(), this.groundColor = new THREE.Color(b)
    }, THREE.HemisphereLight.prototype = Object.create(THREE.Light.prototype), THREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight, THREE.HemisphereLight.prototype.copy = function(a) {
        return THREE.Light.prototype.copy.call(this, a), this.groundColor.copy(a.groundColor), this
    },
    // File:src/lights/PointLight.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.PointLight = function(a, b, c, d) {
        THREE.Light.call(this, a, b), this.type = "PointLight", this.distance = void 0 !== c ? c : 0, this.decay = void 0 !== d ? d : 1, // for physically correct lights, should be 2.
            this.shadow = new THREE.LightShadow(new THREE.PerspectiveCamera(90, 1, .5, 500))
    }, THREE.PointLight.prototype = Object.create(THREE.Light.prototype), THREE.PointLight.prototype.constructor = THREE.PointLight, THREE.PointLight.prototype.copy = function(a) {
        return THREE.Light.prototype.copy.call(this, a), this.distance = a.distance, this.decay = a.decay, this.shadow = a.shadow.clone(), this
    },
    // File:src/lights/SpotLight.js
    /**
     * @author alteredq / http://alteredqualia.com/
     */
    THREE.SpotLight = function(a, b, c, d, e, f) {
        THREE.Light.call(this, a, b), this.type = "SpotLight", this.position.set(0, 1, 0), this.updateMatrix(), this.target = new THREE.Object3D, this.distance = void 0 !== c ? c : 0, this.angle = void 0 !== d ? d : Math.PI / 3, this.exponent = void 0 !== e ? e : 10, this.decay = void 0 !== f ? f : 1, // for physically correct lights, should be 2.
            this.shadow = new THREE.LightShadow(new THREE.PerspectiveCamera(50, 1, .5, 500))
    }, THREE.SpotLight.prototype = Object.create(THREE.Light.prototype), THREE.SpotLight.prototype.constructor = THREE.SpotLight, THREE.SpotLight.prototype.copy = function(a) {
        return THREE.Light.prototype.copy.call(this, a), this.distance = a.distance, this.angle = a.angle, this.exponent = a.exponent, this.decay = a.decay, this.target = a.target.clone(), this.shadow = a.shadow.clone(), this
    },
    // File:src/loaders/Cache.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.Cache = {
        enabled: !1,
        files: {},
        add: function(a, b) {
            this.enabled !== !1 && (
                // console.log( 'THREE.Cache', 'Adding key:', key );
                this.files[a] = b)
        },
        get: function(a) {
            return this.enabled !== !1 ? this.files[a] : void 0
        },
        remove: function(a) {
            delete this.files[a]
        },
        clear: function() {
            this.files = {}
        }
    },
    // File:src/loaders/Loader.js
    /**
     * @author alteredq / http://alteredqualia.com/
     */
    THREE.Loader = function() {
        this.onLoadStart = function() {}, this.onLoadProgress = function() {}, this.onLoadComplete = function() {}
    }, THREE.Loader.prototype = {
        constructor: THREE.Loader,
        crossOrigin: void 0,
        extractUrlBase: function(a) {
            var b = a.split("/");
            return 1 === b.length ? "./" : (b.pop(), b.join("/") + "/")
        },
        initMaterials: function(a, b, c) {
            for (var d = [], e = 0; e < a.length; ++e) d[e] = this.createMaterial(a[e], b, c);
            return d
        },
        createMaterial: function() {
            var a, b, c;
            return function(d, e, f) {
                function g(a, c, d, g, i) {
                    var j, k = e + a,
                        l = THREE.Loader.Handlers.get(k);
                    null !== l ? j = l.load(k) : (b.setCrossOrigin(f), j = b.load(k)), void 0 !== c && (j.repeat.fromArray(c), 1 !== c[0] && (j.wrapS = THREE.RepeatWrapping), 1 !== c[1] && (j.wrapT = THREE.RepeatWrapping)), void 0 !== d && j.offset.fromArray(d), void 0 !== g && ("repeat" === g[0] && (j.wrapS = THREE.RepeatWrapping), "mirror" === g[0] && (j.wrapS = THREE.MirroredRepeatWrapping), "repeat" === g[1] && (j.wrapT = THREE.RepeatWrapping), "mirror" === g[1] && (j.wrapT = THREE.MirroredRepeatWrapping)), void 0 !== i && (j.anisotropy = i);
                    var m = THREE.Math.generateUUID();
                    return h[m] = j, m
                }
                void 0 === a && (a = new THREE.Color), void 0 === b && (b = new THREE.TextureLoader), void 0 === c && (c = new THREE.MaterialLoader);
                // convert from old material format
                var h = {},
                    i = {
                        uuid: THREE.Math.generateUUID(),
                        type: "MeshLambertMaterial"
                    };
                for (var j in d) {
                    var k = d[j];
                    switch (j) {
                        case "DbgColor":
                        case "DbgIndex":
                        case "opticalDensity":
                        case "illumination":
                            break;
                        case "DbgName":
                            i.name = k;
                            break;
                        case "blending":
                            i.blending = THREE[k];
                            break;
                        case "colorAmbient":
                            console.warn("THREE.Loader.createMaterial: colorAmbient is no longer supported");
                            break;
                        case "colorDiffuse":
                            i.color = a.fromArray(k).getHex();
                            break;
                        case "colorSpecular":
                            i.specular = a.fromArray(k).getHex();
                            break;
                        case "colorEmissive":
                            i.emissive = a.fromArray(k).getHex();
                            break;
                        case "specularCoef":
                            i.shininess = k;
                            break;
                        case "shading":
                            "basic" === k.toLowerCase() && (i.type = "MeshBasicMaterial"), "phong" === k.toLowerCase() && (i.type = "MeshPhongMaterial");
                            break;
                        case "mapDiffuse":
                            i.map = g(k, d.mapDiffuseRepeat, d.mapDiffuseOffset, d.mapDiffuseWrap, d.mapDiffuseAnisotropy);
                            break;
                        case "mapDiffuseRepeat":
                        case "mapDiffuseOffset":
                        case "mapDiffuseWrap":
                        case "mapDiffuseAnisotropy":
                            break;
                        case "mapLight":
                            i.lightMap = g(k, d.mapLightRepeat, d.mapLightOffset, d.mapLightWrap, d.mapLightAnisotropy);
                            break;
                        case "mapLightRepeat":
                        case "mapLightOffset":
                        case "mapLightWrap":
                        case "mapLightAnisotropy":
                            break;
                        case "mapAO":
                            i.aoMap = g(k, d.mapAORepeat, d.mapAOOffset, d.mapAOWrap, d.mapAOAnisotropy);
                            break;
                        case "mapAORepeat":
                        case "mapAOOffset":
                        case "mapAOWrap":
                        case "mapAOAnisotropy":
                            break;
                        case "mapBump":
                            i.bumpMap = g(k, d.mapBumpRepeat, d.mapBumpOffset, d.mapBumpWrap, d.mapBumpAnisotropy);
                            break;
                        case "mapBumpScale":
                            i.bumpScale = k;
                            break;
                        case "mapBumpRepeat":
                        case "mapBumpOffset":
                        case "mapBumpWrap":
                        case "mapBumpAnisotropy":
                            break;
                        case "mapNormal":
                            i.normalMap = g(k, d.mapNormalRepeat, d.mapNormalOffset, d.mapNormalWrap, d.mapNormalAnisotropy);
                            break;
                        case "mapNormalFactor":
                            i.normalScale = [k, k];
                            break;
                        case "mapNormalRepeat":
                        case "mapNormalOffset":
                        case "mapNormalWrap":
                        case "mapNormalAnisotropy":
                            break;
                        case "mapSpecular":
                            i.specularMap = g(k, d.mapSpecularRepeat, d.mapSpecularOffset, d.mapSpecularWrap, d.mapSpecularAnisotropy);
                            break;
                        case "mapSpecularRepeat":
                        case "mapSpecularOffset":
                        case "mapSpecularWrap":
                        case "mapSpecularAnisotropy":
                            break;
                        case "mapAlpha":
                            i.alphaMap = g(k, d.mapAlphaRepeat, d.mapAlphaOffset, d.mapAlphaWrap, d.mapAlphaAnisotropy);
                            break;
                        case "mapAlphaRepeat":
                        case "mapAlphaOffset":
                        case "mapAlphaWrap":
                        case "mapAlphaAnisotropy":
                            break;
                        case "flipSided":
                            i.side = THREE.BackSide;
                            break;
                        case "doubleSided":
                            i.side = THREE.DoubleSide;
                            break;
                        case "transparency":
                            console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"), i.opacity = k;
                            break;
                        case "depthTest":
                        case "depthWrite":
                        case "colorWrite":
                        case "opacity":
                        case "reflectivity":
                        case "transparent":
                        case "visible":
                        case "wireframe":
                            i[j] = k;
                            break;
                        case "vertexColors":
                            k === !0 && (i.vertexColors = THREE.VertexColors), "face" === k && (i.vertexColors = THREE.FaceColors);
                            break;
                        default:
                            console.error("THREE.Loader.createMaterial: Unsupported", j, k)
                    }
                }
                return "MeshBasicMaterial" === i.type && delete i.emissive, "MeshPhongMaterial" !== i.type && delete i.specular, i.opacity < 1 && (i.transparent = !0), c.setTextures(h), c.parse(i)
            }
        }()
    }, THREE.Loader.Handlers = {
        handlers: [],
        add: function(a, b) {
            this.handlers.push(a, b)
        },
        get: function(a) {
            for (var b = this.handlers, c = 0, d = b.length; d > c; c += 2) {
                var e = b[c],
                    f = b[c + 1];
                if (e.test(a)) return f
            }
            return null
        }
    },
    // File:src/loaders/XHRLoader.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.XHRLoader = function(a) {
        this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager
    }, THREE.XHRLoader.prototype = {
        constructor: THREE.XHRLoader,
        load: function(a, b, c, d) {
            void 0 !== this.path && (a = this.path + a);
            var e = this,
                f = THREE.Cache.get(a);
            if (void 0 !== f) return b && setTimeout(function() {
                b(f)
            }, 0), f;
            var g = new XMLHttpRequest;
            return g.overrideMimeType("text/plain"), g.open("GET", a, !0), g.addEventListener("load", function(c) {
                var f = c.target.response;
                THREE.Cache.add(a, f), 200 === this.status ? (b && b(f), e.manager.itemEnd(a)) : 0 === this.status ? (
                    // Some browsers return HTTP Status 0 when using non-http protocol
                    // e.g. 'file://' or 'data://'. Handle as success.
                    console.warn("THREE.XHRLoader: HTTP Status 0 received."), b && b(f), e.manager.itemEnd(a)) : (d && d(c), e.manager.itemError(a))
            }, !1), void 0 !== c && g.addEventListener("progress", function(a) {
                c(a)
            }, !1), g.addEventListener("error", function(b) {
                d && d(b), e.manager.itemError(a)
            }, !1), void 0 !== this.responseType && (g.responseType = this.responseType), void 0 !== this.withCredentials && (g.withCredentials = this.withCredentials), g.send(null), e.manager.itemStart(a), g
        },
        setPath: function(a) {
            this.path = a
        },
        setResponseType: function(a) {
            this.responseType = a
        },
        setWithCredentials: function(a) {
            this.withCredentials = a
        }
    },
    // File:src/loaders/FontLoader.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.FontLoader = function(a) {
        this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager
    }, THREE.FontLoader.prototype = {
        constructor: THREE.FontLoader,
        load: function(a, b, c, d) {
            var e = new THREE.XHRLoader(this.manager);
            e.load(a, function(a) {
                b(new THREE.Font(JSON.parse(a.substring(65, a.length - 2))))
            }, c, d)
        }
    },
    // File:src/loaders/ImageLoader.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.ImageLoader = function(a) {
        this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager
    }, THREE.ImageLoader.prototype = {
        constructor: THREE.ImageLoader,
        load: function(a, b, c, d) {
            void 0 !== this.path && (a = this.path + a);
            var e = this,
                f = THREE.Cache.get(a);
            if (void 0 !== f) return e.manager.itemStart(a), b ? setTimeout(function() {
                b(f), e.manager.itemEnd(a)
            }, 0) : e.manager.itemEnd(a), f;
            var g = document.createElement("img");
            return g.addEventListener("load", function(c) {
                THREE.Cache.add(a, this), b && b(this), e.manager.itemEnd(a)
            }, !1), void 0 !== c && g.addEventListener("progress", function(a) {
                c(a)
            }, !1), g.addEventListener("error", function(b) {
                d && d(b), e.manager.itemError(a)
            }, !1), void 0 !== this.crossOrigin && (g.crossOrigin = this.crossOrigin), e.manager.itemStart(a), g.src = a, g
        },
        setCrossOrigin: function(a) {
            this.crossOrigin = a
        },
        setPath: function(a) {
            this.path = a
        }
    },
    // File:src/loaders/JSONLoader.js
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */
    THREE.JSONLoader = function(a) {
        "boolean" == typeof a && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."), a = void 0), this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager, this.withCredentials = !1
    }, THREE.JSONLoader.prototype = {
        constructor: THREE.JSONLoader,
        // Deprecated
        get statusDomElement() {
            return void 0 === this._statusDomElement && (this._statusDomElement = document.createElement("div")), console.warn("THREE.JSONLoader: .statusDomElement has been removed."), this._statusDomElement
        },
        load: function(a, b, c, d) {
            var e = this,
                f = this.texturePath && "string" == typeof this.texturePath ? this.texturePath : THREE.Loader.prototype.extractUrlBase(a),
                g = new THREE.XHRLoader(this.manager);
            g.setWithCredentials(this.withCredentials), g.load(a, function(c) {
                var d = JSON.parse(c),
                    g = d.metadata;
                if (void 0 !== g) {
                    var h = g.type;
                    if (void 0 !== h) {
                        if ("object" === h.toLowerCase()) return void console.error("THREE.JSONLoader: " + a + " should be loaded with THREE.ObjectLoader instead.");
                        if ("scene" === h.toLowerCase()) return void console.error("THREE.JSONLoader: " + a + " should be loaded with THREE.SceneLoader instead.")
                    }
                }
                var i = e.parse(d, f);
                b(i.geometry, i.materials)
            }, c, d)
        },
        setTexturePath: function(a) {
            this.texturePath = a
        },
        parse: function(a, b) {
            function c(b) {
                function c(a, b) {
                    return a & 1 << b
                }
                var d, e, f, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, A, B, C, D, E, F = a.faces,
                    G = a.vertices,
                    H = a.normals,
                    I = a.colors,
                    J = 0;
                if (void 0 !== a.uvs) {
                    // disregard empty arrays
                    for (d = 0; d < a.uvs.length; d++) a.uvs[d].length && J++;
                    for (d = 0; J > d; d++) g.faceVertexUvs[d] = []
                }
                for (h = 0, i = G.length; i > h;) v = new THREE.Vector3, v.x = G[h++] * b, v.y = G[h++] * b, v.z = G[h++] * b, g.vertices.push(v);
                for (h = 0, i = F.length; i > h;)
                // console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);
                    if (n = F[h++], o = c(n, 0), p = c(n, 1), q = c(n, 3), r = c(n, 4), s = c(n, 5), t = c(n, 6), u = c(n, 7), o) {
                    if (x = new THREE.Face3, x.a = F[h], x.b = F[h + 1], x.c = F[h + 3], y = new THREE.Face3, y.a = F[h + 1], y.b = F[h + 2], y.c = F[h + 3], h += 4, p && (m = F[h++], x.materialIndex = m, y.materialIndex = m), f = g.faces.length, q)
                        for (d = 0; J > d; d++)
                            for (B = a.uvs[d], g.faceVertexUvs[d][f] = [], g.faceVertexUvs[d][f + 1] = [], e = 0; 4 > e; e++) l = F[h++], D = B[2 * l], E = B[2 * l + 1], C = new THREE.Vector2(D, E), 2 !== e && g.faceVertexUvs[d][f].push(C), 0 !== e && g.faceVertexUvs[d][f + 1].push(C);
                    if (r && (k = 3 * F[h++], x.normal.set(H[k++], H[k++], H[k]), y.normal.copy(x.normal)), s)
                        for (d = 0; 4 > d; d++) k = 3 * F[h++], A = new THREE.Vector3(H[k++], H[k++], H[k]), 2 !== d && x.vertexNormals.push(A), 0 !== d && y.vertexNormals.push(A);
                    if (t && (j = F[h++], z = I[j], x.color.setHex(z), y.color.setHex(z)), u)
                        for (d = 0; 4 > d; d++) j = F[h++], z = I[j], 2 !== d && x.vertexColors.push(new THREE.Color(z)), 0 !== d && y.vertexColors.push(new THREE.Color(z));
                    g.faces.push(x), g.faces.push(y)
                } else {
                    if (w = new THREE.Face3, w.a = F[h++], w.b = F[h++], w.c = F[h++], p && (m = F[h++], w.materialIndex = m), f = g.faces.length, q)
                        for (d = 0; J > d; d++)
                            for (B = a.uvs[d], g.faceVertexUvs[d][f] = [], e = 0; 3 > e; e++) l = F[h++], D = B[2 * l], E = B[2 * l + 1], C = new THREE.Vector2(D, E), g.faceVertexUvs[d][f].push(C);
                    if (r && (k = 3 * F[h++], w.normal.set(H[k++], H[k++], H[k])), s)
                        for (d = 0; 3 > d; d++) k = 3 * F[h++], A = new THREE.Vector3(H[k++], H[k++], H[k]), w.vertexNormals.push(A);
                    if (t && (j = F[h++], w.color.setHex(I[j])), u)
                        for (d = 0; 3 > d; d++) j = F[h++], w.vertexColors.push(new THREE.Color(I[j]));
                    g.faces.push(w)
                }
            }

            function d() {
                var b = void 0 !== a.influencesPerVertex ? a.influencesPerVertex : 2;
                if (a.skinWeights)
                    for (var c = 0, d = a.skinWeights.length; d > c; c += b) {
                        var e = a.skinWeights[c],
                            f = b > 1 ? a.skinWeights[c + 1] : 0,
                            h = b > 2 ? a.skinWeights[c + 2] : 0,
                            i = b > 3 ? a.skinWeights[c + 3] : 0;
                        g.skinWeights.push(new THREE.Vector4(e, f, h, i))
                    }
                if (a.skinIndices)
                    for (var c = 0, d = a.skinIndices.length; d > c; c += b) {
                        var j = a.skinIndices[c],
                            k = b > 1 ? a.skinIndices[c + 1] : 0,
                            l = b > 2 ? a.skinIndices[c + 2] : 0,
                            m = b > 3 ? a.skinIndices[c + 3] : 0;
                        g.skinIndices.push(new THREE.Vector4(j, k, l, m))
                    }
                g.bones = a.bones, g.bones && g.bones.length > 0 && (g.skinWeights.length !== g.skinIndices.length || g.skinIndices.length !== g.vertices.length) && console.warn("When skinning, number of vertices (" + g.vertices.length + "), skinIndices (" + g.skinIndices.length + "), and skinWeights (" + g.skinWeights.length + ") should match.")
            }

            function e(b) {
                if (void 0 !== a.morphTargets)
                    for (var c = 0, d = a.morphTargets.length; d > c; c++) {
                        g.morphTargets[c] = {}, g.morphTargets[c].name = a.morphTargets[c].name, g.morphTargets[c].vertices = [];
                        for (var e = g.morphTargets[c].vertices, f = a.morphTargets[c].vertices, h = 0, i = f.length; i > h; h += 3) {
                            var j = new THREE.Vector3;
                            j.x = f[h] * b, j.y = f[h + 1] * b, j.z = f[h + 2] * b, e.push(j)
                        }
                    }
                if (void 0 !== a.morphColors && a.morphColors.length > 0) {
                    console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
                    for (var k = g.faces, l = a.morphColors[0].colors, c = 0, d = k.length; d > c; c++) k[c].color.fromArray(l, 3 * c)
                }
            }

            function f() {
                var b = [],
                    c = [];
                void 0 !== a.animation && c.push(a.animation), void 0 !== a.animations && (a.animations.length ? c = c.concat(a.animations) : c.push(a.animations));
                for (var d = 0; d < c.length; d++) {
                    var e = THREE.AnimationClip.parseAnimation(c[d], g.bones);
                    e && b.push(e)
                }
                // parse implicit morph animations
                if (g.morphTargets) {
                    // TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
                    var f = THREE.AnimationClip.CreateClipsFromMorphTargetSequences(g.morphTargets, 10);
                    b = b.concat(f)
                }
                b.length > 0 && (g.animations = b)
            }
            var g = new THREE.Geometry,
                h = void 0 !== a.scale ? 1 / a.scale : 1;
            if (c(h), d(), e(h), f(), g.computeFaceNormals(), g.computeBoundingSphere(), void 0 === a.materials || 0 === a.materials.length) return {
                geometry: g
            };
            var i = THREE.Loader.prototype.initMaterials(a.materials, b, this.crossOrigin);
            return {
                geometry: g,
                materials: i
            }
        }
    },
    // File:src/loaders/LoadingManager.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.LoadingManager = function(a, b, c) {
        var d = this,
            e = !1,
            f = 0,
            g = 0;
        this.onStart = void 0, this.onLoad = a, this.onProgress = b, this.onError = c, this.itemStart = function(a) {
            g++, e === !1 && void 0 !== d.onStart && d.onStart(a, f, g), e = !0
        }, this.itemEnd = function(a) {
            f++, void 0 !== d.onProgress && d.onProgress(a, f, g), f === g && (e = !1, void 0 !== d.onLoad && d.onLoad())
        }, this.itemError = function(a) {
            void 0 !== d.onError && d.onError(a)
        }
    }, THREE.DefaultLoadingManager = new THREE.LoadingManager,
    // File:src/loaders/BufferGeometryLoader.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.BufferGeometryLoader = function(a) {
        this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager
    }, THREE.BufferGeometryLoader.prototype = {
        constructor: THREE.BufferGeometryLoader,
        load: function(a, b, c, d) {
            var e = this,
                f = new THREE.XHRLoader(e.manager);
            f.load(a, function(a) {
                b(e.parse(JSON.parse(a)))
            }, c, d)
        },
        parse: function(a) {
            var b = new THREE.BufferGeometry,
                c = a.data.index,
                d = {
                    Int8Array: Int8Array,
                    Uint8Array: Uint8Array,
                    Uint8ClampedArray: Uint8ClampedArray,
                    Int16Array: Int16Array,
                    Uint16Array: Uint16Array,
                    Int32Array: Int32Array,
                    Uint32Array: Uint32Array,
                    Float32Array: Float32Array,
                    Float64Array: Float64Array
                };
            if (void 0 !== c) {
                var e = new d[c.type](c.array);
                b.setIndex(new THREE.BufferAttribute(e, 1))
            }
            var f = a.data.attributes;
            for (var g in f) {
                var h = f[g],
                    e = new d[h.type](h.array);
                b.addAttribute(g, new THREE.BufferAttribute(e, h.itemSize))
            }
            var i = a.data.groups || a.data.drawcalls || a.data.offsets;
            if (void 0 !== i)
                for (var j = 0, k = i.length; j !== k; ++j) {
                    var l = i[j];
                    b.addGroup(l.start, l.count, l.materialIndex)
                }
            var m = a.data.boundingSphere;
            if (void 0 !== m) {
                var n = new THREE.Vector3;
                void 0 !== m.center && n.fromArray(m.center), b.boundingSphere = new THREE.Sphere(n, m.radius)
            }
            return b
        }
    },
    // File:src/loaders/MaterialLoader.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.MaterialLoader = function(a) {
        this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager, this.textures = {}
    }, THREE.MaterialLoader.prototype = {
        constructor: THREE.MaterialLoader,
        load: function(a, b, c, d) {
            var e = this,
                f = new THREE.XHRLoader(e.manager);
            f.load(a, function(a) {
                b(e.parse(JSON.parse(a)))
            }, c, d)
        },
        setTextures: function(a) {
            this.textures = a
        },
        getTexture: function(a) {
            var b = this.textures;
            return void 0 === b[a] && console.warn("THREE.MaterialLoader: Undefined texture", a), b[a]
        },
        parse: function(a) {
            var b = new THREE[a.type];
            if (void 0 !== a.uuid && (b.uuid = a.uuid), void 0 !== a.name && (b.name = a.name), void 0 !== a.color && b.color.setHex(a.color), void 0 !== a.roughness && (b.roughness = a.roughness), void 0 !== a.metalness && (b.metalness = a.metalness), void 0 !== a.emissive && b.emissive.setHex(a.emissive), void 0 !== a.specular && b.specular.setHex(a.specular), void 0 !== a.shininess && (b.shininess = a.shininess), void 0 !== a.uniforms && (b.uniforms = a.uniforms), void 0 !== a.vertexShader && (b.vertexShader = a.vertexShader), void 0 !== a.fragmentShader && (b.fragmentShader = a.fragmentShader), void 0 !== a.vertexColors && (b.vertexColors = a.vertexColors), void 0 !== a.shading && (b.shading = a.shading), void 0 !== a.blending && (b.blending = a.blending), void 0 !== a.side && (b.side = a.side), void 0 !== a.opacity && (b.opacity = a.opacity), void 0 !== a.transparent && (b.transparent = a.transparent), void 0 !== a.alphaTest && (b.alphaTest = a.alphaTest), void 0 !== a.depthTest && (b.depthTest = a.depthTest), void 0 !== a.depthWrite && (b.depthWrite = a.depthWrite), void 0 !== a.colorWrite && (b.colorWrite = a.colorWrite), void 0 !== a.wireframe && (b.wireframe = a.wireframe), void 0 !== a.wireframeLinewidth && (b.wireframeLinewidth = a.wireframeLinewidth),
                // for PointsMaterial
                void 0 !== a.size && (b.size = a.size), void 0 !== a.sizeAttenuation && (b.sizeAttenuation = a.sizeAttenuation),
                // maps
                void 0 !== a.map && (b.map = this.getTexture(a.map)), void 0 !== a.alphaMap && (b.alphaMap = this.getTexture(a.alphaMap), b.transparent = !0), void 0 !== a.bumpMap && (b.bumpMap = this.getTexture(a.bumpMap)), void 0 !== a.bumpScale && (b.bumpScale = a.bumpScale), void 0 !== a.normalMap && (b.normalMap = this.getTexture(a.normalMap)), void 0 !== a.normalScale) {
                var c = a.normalScale;
                Array.isArray(c) === !1 && (
                    // Blender exporter used to export a scalar. See #7459
                    c = [c, c]), b.normalScale = (new THREE.Vector2).fromArray(c)
            }
            // MultiMaterial
            if (void 0 !== a.displacementMap && (b.displacementMap = this.getTexture(a.displacementMap)), void 0 !== a.displacementScale && (b.displacementScale = a.displacementScale), void 0 !== a.displacementBias && (b.displacementBias = a.displacementBias), void 0 !== a.roughnessMap && (b.roughnessMap = this.getTexture(a.roughnessMap)), void 0 !== a.metalnessMap && (b.metalnessMap = this.getTexture(a.metalnessMap)), void 0 !== a.emissiveMap && (b.emissiveMap = this.getTexture(a.emissiveMap)), void 0 !== a.emissiveIntensity && (b.emissiveIntensity = a.emissiveIntensity), void 0 !== a.specularMap && (b.specularMap = this.getTexture(a.specularMap)), void 0 !== a.envMap && (b.envMap = this.getTexture(a.envMap), b.combine = THREE.MultiplyOperation), a.reflectivity && (b.reflectivity = a.reflectivity), void 0 !== a.lightMap && (b.lightMap = this.getTexture(a.lightMap)), void 0 !== a.lightMapIntensity && (b.lightMapIntensity = a.lightMapIntensity), void 0 !== a.aoMap && (b.aoMap = this.getTexture(a.aoMap)), void 0 !== a.aoMapIntensity && (b.aoMapIntensity = a.aoMapIntensity), void 0 !== a.materials)
                for (var d = 0, e = a.materials.length; e > d; d++) b.materials.push(this.parse(a.materials[d]));
            return b
        }
    },
    // File:src/loaders/ObjectLoader.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.ObjectLoader = function(a) {
        this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager, this.texturePath = ""
    }, THREE.ObjectLoader.prototype = {
        constructor: THREE.ObjectLoader,
        load: function(a, b, c, d) {
            "" === this.texturePath && (this.texturePath = a.substring(0, a.lastIndexOf("/") + 1));
            var e = this,
                f = new THREE.XHRLoader(e.manager);
            f.load(a, function(a) {
                e.parse(JSON.parse(a), b)
            }, c, d)
        },
        setTexturePath: function(a) {
            this.texturePath = a
        },
        setCrossOrigin: function(a) {
            this.crossOrigin = a
        },
        parse: function(a, b) {
            var c = this.parseGeometries(a.geometries),
                d = this.parseImages(a.images, function() {
                    void 0 !== b && b(g)
                }),
                e = this.parseTextures(a.textures, d),
                f = this.parseMaterials(a.materials, e),
                g = this.parseObject(a.object, c, f);
            return a.animations && (g.animations = this.parseAnimations(a.animations)), void 0 !== a.images && 0 !== a.images.length || void 0 !== b && b(g), g
        },
        parseGeometries: function(a) {
            var b = {};
            if (void 0 !== a)
                for (var c = new THREE.JSONLoader, d = new THREE.BufferGeometryLoader, e = 0, f = a.length; f > e; e++) {
                    var g, h = a[e];
                    switch (h.type) {
                        case "PlaneGeometry":
                        case "PlaneBufferGeometry":
                            g = new THREE[h.type](h.width, h.height, h.widthSegments, h.heightSegments);
                            break;
                        case "BoxGeometry":
                        case "CubeGeometry": // backwards compatible
                            g = new THREE.BoxGeometry(h.width, h.height, h.depth, h.widthSegments, h.heightSegments, h.depthSegments);
                            break;
                        case "CircleBufferGeometry":
                            g = new THREE.CircleBufferGeometry(h.radius, h.segments, h.thetaStart, h.thetaLength);
                            break;
                        case "CircleGeometry":
                            g = new THREE.CircleGeometry(h.radius, h.segments, h.thetaStart, h.thetaLength);
                            break;
                        case "CylinderGeometry":
                            g = new THREE.CylinderGeometry(h.radiusTop, h.radiusBottom, h.height, h.radialSegments, h.heightSegments, h.openEnded, h.thetaStart, h.thetaLength);
                            break;
                        case "SphereGeometry":
                            g = new THREE.SphereGeometry(h.radius, h.widthSegments, h.heightSegments, h.phiStart, h.phiLength, h.thetaStart, h.thetaLength);
                            break;
                        case "SphereBufferGeometry":
                            g = new THREE.SphereBufferGeometry(h.radius, h.widthSegments, h.heightSegments, h.phiStart, h.phiLength, h.thetaStart, h.thetaLength);
                            break;
                        case "DodecahedronGeometry":
                            g = new THREE.DodecahedronGeometry(h.radius, h.detail);
                            break;
                        case "IcosahedronGeometry":
                            g = new THREE.IcosahedronGeometry(h.radius, h.detail);
                            break;
                        case "OctahedronGeometry":
                            g = new THREE.OctahedronGeometry(h.radius, h.detail);
                            break;
                        case "TetrahedronGeometry":
                            g = new THREE.TetrahedronGeometry(h.radius, h.detail);
                            break;
                        case "RingGeometry":
                            g = new THREE.RingGeometry(h.innerRadius, h.outerRadius, h.thetaSegments, h.phiSegments, h.thetaStart, h.thetaLength);
                            break;
                        case "TorusGeometry":
                            g = new THREE.TorusGeometry(h.radius, h.tube, h.radialSegments, h.tubularSegments, h.arc);
                            break;
                        case "TorusKnotGeometry":
                            g = new THREE.TorusKnotGeometry(h.radius, h.tube, h.radialSegments, h.tubularSegments, h.p, h.q, h.heightScale);
                            break;
                        case "LatheGeometry":
                            g = new THREE.LatheGeometry(h.points, h.segments, h.phiStart, h.phiLength);
                            break;
                        case "BufferGeometry":
                            g = d.parse(h);
                            break;
                        case "Geometry":
                            g = c.parse(h.data, this.texturePath).geometry;
                            break;
                        default:
                            console.warn('THREE.ObjectLoader: Unsupported geometry type "' + h.type + '"');
                            continue
                    }
                    g.uuid = h.uuid, void 0 !== h.name && (g.name = h.name), b[h.uuid] = g
                }
            return b
        },
        parseMaterials: function(a, b) {
            var c = {};
            if (void 0 !== a) {
                var d = new THREE.MaterialLoader;
                d.setTextures(b);
                for (var e = 0, f = a.length; f > e; e++) {
                    var g = d.parse(a[e]);
                    c[g.uuid] = g
                }
            }
            return c
        },
        parseAnimations: function(a) {
            for (var b = [], c = 0; c < a.length; c++) {
                var d = THREE.AnimationClip.parse(a[c]);
                b.push(d)
            }
            return b
        },
        parseImages: function(a, b) {
            function c(a) {
                return d.manager.itemStart(a), g.load(a, function() {
                    d.manager.itemEnd(a)
                })
            }
            var d = this,
                e = {};
            if (void 0 !== a && a.length > 0) {
                var f = new THREE.LoadingManager(b),
                    g = new THREE.ImageLoader(f);
                g.setCrossOrigin(this.crossOrigin);
                for (var h = 0, i = a.length; i > h; h++) {
                    var j = a[h],
                        k = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(j.url) ? j.url : d.texturePath + j.url;
                    e[j.uuid] = c(k)
                }
            }
            return e
        },
        parseTextures: function(a, b) {
            function c(a) {
                return "number" == typeof a ? a : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", a), THREE[a])
            }
            var d = {};
            if (void 0 !== a)
                for (var e = 0, f = a.length; f > e; e++) {
                    var g = a[e];
                    void 0 === g.image && console.warn('THREE.ObjectLoader: No "image" specified for', g.uuid), void 0 === b[g.image] && console.warn("THREE.ObjectLoader: Undefined image", g.image);
                    var h = new THREE.Texture(b[g.image]);
                    h.needsUpdate = !0, h.uuid = g.uuid, void 0 !== g.name && (h.name = g.name), void 0 !== g.mapping && (h.mapping = c(g.mapping)), void 0 !== g.offset && (h.offset = new THREE.Vector2(g.offset[0], g.offset[1])), void 0 !== g.repeat && (h.repeat = new THREE.Vector2(g.repeat[0], g.repeat[1])), void 0 !== g.minFilter && (h.minFilter = c(g.minFilter)), void 0 !== g.magFilter && (h.magFilter = c(g.magFilter)), void 0 !== g.anisotropy && (h.anisotropy = g.anisotropy), Array.isArray(g.wrap) && (h.wrapS = c(g.wrap[0]), h.wrapT = c(g.wrap[1])), d[g.uuid] = h
                }
            return d
        },
        parseObject: function() {
            var a = new THREE.Matrix4;
            return function(b, c, d) {
                function e(a) {
                    return void 0 === c[a] && console.warn("THREE.ObjectLoader: Undefined geometry", a), c[a]
                }

                function f(a) {
                    return void 0 !== a ? (void 0 === d[a] && console.warn("THREE.ObjectLoader: Undefined material", a), d[a]) : void 0
                }
                var g;
                switch (b.type) {
                    case "Scene":
                        g = new THREE.Scene;
                        break;
                    case "PerspectiveCamera":
                        g = new THREE.PerspectiveCamera(b.fov, b.aspect, b.near, b.far);
                        break;
                    case "OrthographicCamera":
                        g = new THREE.OrthographicCamera(b.left, b.right, b.top, b.bottom, b.near, b.far);
                        break;
                    case "AmbientLight":
                        g = new THREE.AmbientLight(b.color, b.intensity);
                        break;
                    case "DirectionalLight":
                        g = new THREE.DirectionalLight(b.color, b.intensity);
                        break;
                    case "PointLight":
                        g = new THREE.PointLight(b.color, b.intensity, b.distance, b.decay);
                        break;
                    case "SpotLight":
                        g = new THREE.SpotLight(b.color, b.intensity, b.distance, b.angle, b.exponent, b.decay);
                        break;
                    case "HemisphereLight":
                        g = new THREE.HemisphereLight(b.color, b.groundColor, b.intensity);
                        break;
                    case "Mesh":
                        var h = e(b.geometry),
                            i = f(b.material);
                        g = h.bones && h.bones.length > 0 ? new THREE.SkinnedMesh(h, i) : new THREE.Mesh(h, i);
                        break;
                    case "LOD":
                        g = new THREE.LOD;
                        break;
                    case "Line":
                        g = new THREE.Line(e(b.geometry), f(b.material), b.mode);
                        break;
                    case "PointCloud":
                    case "Points":
                        g = new THREE.Points(e(b.geometry), f(b.material));
                        break;
                    case "Sprite":
                        g = new THREE.Sprite(f(b.material));
                        break;
                    case "Group":
                        g = new THREE.Group;
                        break;
                    default:
                        g = new THREE.Object3D
                }
                if (g.uuid = b.uuid, void 0 !== b.name && (g.name = b.name), void 0 !== b.matrix ? (a.fromArray(b.matrix), a.decompose(g.position, g.quaternion, g.scale)) : (void 0 !== b.position && g.position.fromArray(b.position), void 0 !== b.rotation && g.rotation.fromArray(b.rotation), void 0 !== b.scale && g.scale.fromArray(b.scale)), void 0 !== b.castShadow && (g.castShadow = b.castShadow), void 0 !== b.receiveShadow && (g.receiveShadow = b.receiveShadow), void 0 !== b.visible && (g.visible = b.visible), void 0 !== b.userData && (g.userData = b.userData), void 0 !== b.children)
                    for (var j in b.children) g.add(this.parseObject(b.children[j], c, d));
                if ("LOD" === b.type)
                    for (var k = b.levels, l = 0; l < k.length; l++) {
                        var m = k[l],
                            j = g.getObjectByProperty("uuid", m.object);
                        void 0 !== j && g.addLevel(j, m.distance)
                    }
                return g
            }
        }()
    },
    // File:src/loaders/TextureLoader.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.TextureLoader = function(a) {
        this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager
    }, THREE.TextureLoader.prototype = {
        constructor: THREE.TextureLoader,
        load: function(a, b, c, d) {
            var e = new THREE.Texture,
                f = new THREE.ImageLoader(this.manager);
            return f.setCrossOrigin(this.crossOrigin), f.setPath(this.path), f.load(a, function(a) {
                e.image = a, e.needsUpdate = !0, void 0 !== b && b(e)
            }, c, d), e
        },
        setCrossOrigin: function(a) {
            this.crossOrigin = a
        },
        setPath: function(a) {
            this.path = a
        }
    },
    // File:src/loaders/CubeTextureLoader.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.CubeTextureLoader = function(a) {
        this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager
    }, THREE.CubeTextureLoader.prototype = {
        constructor: THREE.CubeTextureLoader,
        load: function(a, b, c, d) {
            function e(c) {
                g.load(a[c], function(a) {
                    f.images[c] = a, h++, 6 === h && (f.needsUpdate = !0, b && b(f))
                }, void 0, d)
            }
            var f = new THREE.CubeTexture([]),
                g = new THREE.ImageLoader(this.manager);
            g.setCrossOrigin(this.crossOrigin), g.setPath(this.path);
            for (var h = 0, i = 0; i < a.length; ++i) e(i);
            return f
        },
        setCrossOrigin: function(a) {
            this.crossOrigin = a
        },
        setPath: function(a) {
            this.path = a
        }
    },
    // File:src/loaders/BinaryTextureLoader.js
    /**
     * @author Nikos M. / https://github.com/foo123/
     *
     * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
     */
    THREE.DataTextureLoader = THREE.BinaryTextureLoader = function(a) {
        this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager,
            // override in sub classes
            this._parser = null
    }, THREE.BinaryTextureLoader.prototype = {
        constructor: THREE.BinaryTextureLoader,
        load: function(a, b, c, d) {
            var e = this,
                f = new THREE.DataTexture,
                g = new THREE.XHRLoader(this.manager);
            return g.setResponseType("arraybuffer"), g.load(a, function(a) {
                var c = e._parser(a);
                c && (void 0 !== c.image ? f.image = c.image : void 0 !== c.data && (f.image.width = c.width, f.image.height = c.height, f.image.data = c.data), f.wrapS = void 0 !== c.wrapS ? c.wrapS : THREE.ClampToEdgeWrapping, f.wrapT = void 0 !== c.wrapT ? c.wrapT : THREE.ClampToEdgeWrapping, f.magFilter = void 0 !== c.magFilter ? c.magFilter : THREE.LinearFilter, f.minFilter = void 0 !== c.minFilter ? c.minFilter : THREE.LinearMipMapLinearFilter, f.anisotropy = void 0 !== c.anisotropy ? c.anisotropy : 1, void 0 !== c.format && (f.format = c.format), void 0 !== c.type && (f.type = c.type), void 0 !== c.mipmaps && (f.mipmaps = c.mipmaps), 1 === c.mipmapCount && (f.minFilter = THREE.LinearFilter), f.needsUpdate = !0, b && b(f, c))
            }, c, d), f
        }
    },
    // File:src/loaders/CompressedTextureLoader.js
    /**
     * @author mrdoob / http://mrdoob.com/
     *
     * Abstract Base class to block based textures loader (dds, pvr, ...)
     */
    THREE.CompressedTextureLoader = function(a) {
        this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager,
            // override in sub classes
            this._parser = null
    }, THREE.CompressedTextureLoader.prototype = {
        constructor: THREE.CompressedTextureLoader,
        load: function(a, b, c, d) {
            function e(e) {
                i.load(a[e], function(a) {
                    var c = f._parser(a, !0);
                    g[e] = {
                        width: c.width,
                        height: c.height,
                        format: c.format,
                        mipmaps: c.mipmaps
                    }, j += 1, 6 === j && (1 === c.mipmapCount && (h.minFilter = THREE.LinearFilter), h.format = c.format, h.needsUpdate = !0, b && b(h))
                }, c, d)
            }
            var f = this,
                g = [],
                h = new THREE.CompressedTexture;
            h.image = g;
            var i = new THREE.XHRLoader(this.manager);
            if (i.setPath(this.path), i.setResponseType("arraybuffer"), Array.isArray(a))
                for (var j = 0, k = 0, l = a.length; l > k; ++k) e(k);
            else
            // compressed cubemap texture stored in a single DDS file
                i.load(a, function(a) {
                var c = f._parser(a, !0);
                if (c.isCubemap)
                    for (var d = c.mipmaps.length / c.mipmapCount, e = 0; d > e; e++) {
                        g[e] = {
                            mipmaps: []
                        };
                        for (var i = 0; i < c.mipmapCount; i++) g[e].mipmaps.push(c.mipmaps[e * c.mipmapCount + i]), g[e].format = c.format, g[e].width = c.width, g[e].height = c.height
                    } else h.image.width = c.width, h.image.height = c.height, h.mipmaps = c.mipmaps;
                1 === c.mipmapCount && (h.minFilter = THREE.LinearFilter), h.format = c.format, h.needsUpdate = !0, b && b(h)
            }, c, d);
            return h
        },
        setPath: function(a) {
            this.path = a
        }
    },
    // File:src/materials/Material.js
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */
    THREE.Material = function() {
        Object.defineProperty(this, "id", {
                value: THREE.MaterialIdCount++
            }), this.uuid = THREE.Math.generateUUID(), this.name = "", this.type = "Material", this.side = THREE.FrontSide, this.opacity = 1, this.transparent = !1, this.blending = THREE.NormalBlending, this.blendSrc = THREE.SrcAlphaFactor, this.blendDst = THREE.OneMinusSrcAlphaFactor, this.blendEquation = THREE.AddEquation, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = THREE.LessEqualDepth, this.depthTest = !0, this.depthWrite = !0, this.colorWrite = !0, this.precision = null, // override the renderer's default precision for this material
            this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.alphaTest = 0, this.overdraw = 0, // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer
            this.visible = !0, this._needsUpdate = !0
    }, THREE.Material.prototype = {
        constructor: THREE.Material,
        get needsUpdate() {
            return this._needsUpdate
        },
        set needsUpdate(a) {
            a === !0 && this.update(), this._needsUpdate = a
        },
        setValues: function(a) {
            if (void 0 !== a)
                for (var b in a) {
                    var c = a[b];
                    if (void 0 !== c) {
                        var d = this[b];
                        void 0 !== d ? d instanceof THREE.Color ? d.set(c) : d instanceof THREE.Vector3 && c instanceof THREE.Vector3 ? d.copy(c) : "overdraw" === b ? this[b] = Number(c) : this[b] = c : console.warn("THREE." + this.type + ": '" + b + "' is not a property of this material.")
                    } else console.warn("THREE.Material: '" + b + "' parameter is undefined.")
                }
        },
        toJSON: function(a) {
            // TODO: Copied from Object3D.toJSON
            function b(a) {
                var b = [];
                for (var c in a) {
                    var d = a[c];
                    delete d.metadata, b.push(d)
                }
                return b
            }
            var c = void 0 === a;
            c && (a = {
                textures: {},
                images: {}
            });
            var d = {
                metadata: {
                    version: 4.4,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            };
            if (
                // standard Material serialization
                d.uuid = this.uuid, d.type = this.type, "" !== this.name && (d.name = this.name), this.color instanceof THREE.Color && (d.color = this.color.getHex()), .5 !== this.roughness && (d.roughness = this.roughness), this.metalness > 0 && (d.metalness = this.metalness), this.emissive instanceof THREE.Color && (d.emissive = this.emissive.getHex()), this.specular instanceof THREE.Color && (d.specular = this.specular.getHex()), void 0 !== this.shininess && (d.shininess = this.shininess), this.map instanceof THREE.Texture && (d.map = this.map.toJSON(a).uuid), this.alphaMap instanceof THREE.Texture && (d.alphaMap = this.alphaMap.toJSON(a).uuid), this.lightMap instanceof THREE.Texture && (d.lightMap = this.lightMap.toJSON(a).uuid), this.bumpMap instanceof THREE.Texture && (d.bumpMap = this.bumpMap.toJSON(a).uuid, d.bumpScale = this.bumpScale), this.normalMap instanceof THREE.Texture && (d.normalMap = this.normalMap.toJSON(a).uuid, d.normalScale = this.normalScale.toArray()), this.displacementMap instanceof THREE.Texture && (d.displacementMap = this.displacementMap.toJSON(a).uuid, d.displacementScale = this.displacementScale, d.displacementBias = this.displacementBias), this.roughnessMap instanceof THREE.Texture && (d.roughnessMap = this.roughnessMap.toJSON(a).uuid), this.metalnessMap instanceof THREE.Texture && (d.metalnessMap = this.metalnessMap.toJSON(a).uuid), this.emissiveMap instanceof THREE.Texture && (d.emissiveMap = this.emissiveMap.toJSON(a).uuid), this.specularMap instanceof THREE.Texture && (d.specularMap = this.specularMap.toJSON(a).uuid), this.envMap instanceof THREE.Texture && (d.envMap = this.envMap.toJSON(a).uuid, d.reflectivity = this.reflectivity), void 0 !== this.size && (d.size = this.size), void 0 !== this.sizeAttenuation && (d.sizeAttenuation = this.sizeAttenuation), void 0 !== this.vertexColors && this.vertexColors !== THREE.NoColors && (d.vertexColors = this.vertexColors), void 0 !== this.shading && this.shading !== THREE.SmoothShading && (d.shading = this.shading), void 0 !== this.blending && this.blending !== THREE.NormalBlending && (d.blending = this.blending), void 0 !== this.side && this.side !== THREE.FrontSide && (d.side = this.side), this.opacity < 1 && (d.opacity = this.opacity), this.transparent === !0 && (d.transparent = this.transparent), this.alphaTest > 0 && (d.alphaTest = this.alphaTest), this.wireframe === !0 && (d.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (d.wireframeLinewidth = this.wireframeLinewidth), c) {
                var e = b(a.textures),
                    f = b(a.images);
                e.length > 0 && (d.textures = e), f.length > 0 && (d.images = f)
            }
            return d
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(a) {
            return this.name = a.name, this.side = a.side, this.opacity = a.opacity, this.transparent = a.transparent, this.blending = a.blending, this.blendSrc = a.blendSrc, this.blendDst = a.blendDst, this.blendEquation = a.blendEquation, this.blendSrcAlpha = a.blendSrcAlpha, this.blendDstAlpha = a.blendDstAlpha, this.blendEquationAlpha = a.blendEquationAlpha, this.depthFunc = a.depthFunc, this.depthTest = a.depthTest, this.depthWrite = a.depthWrite, this.colorWrite = a.colorWrite, this.precision = a.precision, this.polygonOffset = a.polygonOffset, this.polygonOffsetFactor = a.polygonOffsetFactor, this.polygonOffsetUnits = a.polygonOffsetUnits, this.alphaTest = a.alphaTest, this.overdraw = a.overdraw, this.visible = a.visible, this
        },
        update: function() {
            this.dispatchEvent({
                type: "update"
            })
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }, THREE.EventDispatcher.prototype.apply(THREE.Material.prototype), THREE.MaterialIdCount = 0,
    // File:src/materials/LineBasicMaterial.js
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *
     *  blending: THREE.NormalBlending,
     *  depthTest: <bool>,
     *  depthWrite: <bool>,
     *
     *  linewidth: <float>,
     *  linecap: "round",
     *  linejoin: "round",
     *
     *  vertexColors: <bool>
     *
     *  fog: <bool>
     * }
     */
    THREE.LineBasicMaterial = function(a) {
        THREE.Material.call(this), this.type = "LineBasicMaterial", this.color = new THREE.Color(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.vertexColors = THREE.NoColors, this.fog = !0, this.setValues(a)
    }, THREE.LineBasicMaterial.prototype = Object.create(THREE.Material.prototype), THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial, THREE.LineBasicMaterial.prototype.copy = function(a) {
        return THREE.Material.prototype.copy.call(this, a), this.color.copy(a.color), this.linewidth = a.linewidth, this.linecap = a.linecap, this.linejoin = a.linejoin, this.vertexColors = a.vertexColors, this.fog = a.fog, this
    },
    // File:src/materials/LineDashedMaterial.js
    /**
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *
     *  blending: THREE.NormalBlending,
     *  depthTest: <bool>,
     *  depthWrite: <bool>,
     *
     *  linewidth: <float>,
     *
     *  scale: <float>,
     *  dashSize: <float>,
     *  gapSize: <float>,
     *
     *  vertexColors: THREE.NoColors / THREE.FaceColors / THREE.VertexColors
     *
     *  fog: <bool>
     * }
     */
    THREE.LineDashedMaterial = function(a) {
        THREE.Material.call(this), this.type = "LineDashedMaterial", this.color = new THREE.Color(16777215), this.linewidth = 1, this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.vertexColors = THREE.NoColors, this.fog = !0, this.setValues(a)
    }, THREE.LineDashedMaterial.prototype = Object.create(THREE.Material.prototype), THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial, THREE.LineDashedMaterial.prototype.copy = function(a) {
        return THREE.Material.prototype.copy.call(this, a), this.color.copy(a.color), this.linewidth = a.linewidth, this.scale = a.scale, this.dashSize = a.dashSize, this.gapSize = a.gapSize, this.vertexColors = a.vertexColors, this.fog = a.fog, this
    },
    // File:src/materials/MeshBasicMaterial.js
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *  map: new THREE.Texture( <Image> ),
     *
     *  aoMap: new THREE.Texture( <Image> ),
     *  aoMapIntensity: <float>
     *
     *  specularMap: new THREE.Texture( <Image> ),
     *
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
     *  combine: THREE.Multiply,
     *  reflectivity: <float>,
     *  refractionRatio: <float>,
     *
     *  shading: THREE.SmoothShading,
     *  blending: THREE.NormalBlending,
     *  depthTest: <bool>,
     *  depthWrite: <bool>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>,
     *
     *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>,
     *
     *  fog: <bool>
     * }
     */
    THREE.MeshBasicMaterial = function(a) {
        THREE.Material.call(this), this.type = "MeshBasicMaterial", this.color = new THREE.Color(16777215), // emissive
            this.map = null, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = THREE.MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, this.fog = !0, this.shading = THREE.SmoothShading, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.vertexColors = THREE.NoColors, this.skinning = !1, this.morphTargets = !1, this.setValues(a)
    }, THREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype), THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial, THREE.MeshBasicMaterial.prototype.copy = function(a) {
        return THREE.Material.prototype.copy.call(this, a), this.color.copy(a.color), this.map = a.map, this.aoMap = a.aoMap, this.aoMapIntensity = a.aoMapIntensity, this.specularMap = a.specularMap, this.alphaMap = a.alphaMap, this.envMap = a.envMap, this.combine = a.combine, this.reflectivity = a.reflectivity, this.refractionRatio = a.refractionRatio, this.fog = a.fog, this.shading = a.shading, this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, this.wireframeLinecap = a.wireframeLinecap, this.wireframeLinejoin = a.wireframeLinejoin, this.vertexColors = a.vertexColors, this.skinning = a.skinning, this.morphTargets = a.morphTargets, this
    },
    // File:src/materials/MeshLambertMaterial.js
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *
     *  map: new THREE.Texture( <Image> ),
     *
     *  lightMap: new THREE.Texture( <Image> ),
     *  lightMapIntensity: <float>
     *
     *  aoMap: new THREE.Texture( <Image> ),
     *  aoMapIntensity: <float>
     *
     *  emissive: <hex>,
     *  emissiveIntensity: <float>
     *  emissiveMap: new THREE.Texture( <Image> ),
     *
     *  specularMap: new THREE.Texture( <Image> ),
     *
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
     *  combine: THREE.Multiply,
     *  reflectivity: <float>,
     *  refractionRatio: <float>,
     *
     *  blending: THREE.NormalBlending,
     *  depthTest: <bool>,
     *  depthWrite: <bool>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>,
     *
     *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>,
     *  morphNormals: <bool>,
     *
     *	fog: <bool>
     * }
     */
    THREE.MeshLambertMaterial = function(a) {
        THREE.Material.call(this), this.type = "MeshLambertMaterial", this.color = new THREE.Color(16777215), // diffuse
            this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new THREE.Color(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = THREE.MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, this.fog = !0, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.vertexColors = THREE.NoColors, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(a)
    }, THREE.MeshLambertMaterial.prototype = Object.create(THREE.Material.prototype), THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial, THREE.MeshLambertMaterial.prototype.copy = function(a) {
        return THREE.Material.prototype.copy.call(this, a), this.color.copy(a.color), this.map = a.map, this.lightMap = a.lightMap, this.lightMapIntensity = a.lightMapIntensity, this.aoMap = a.aoMap, this.aoMapIntensity = a.aoMapIntensity, this.emissive.copy(a.emissive), this.emissiveMap = a.emissiveMap, this.emissiveIntensity = a.emissiveIntensity, this.specularMap = a.specularMap, this.alphaMap = a.alphaMap, this.envMap = a.envMap, this.combine = a.combine, this.reflectivity = a.reflectivity, this.refractionRatio = a.refractionRatio, this.fog = a.fog, this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, this.wireframeLinecap = a.wireframeLinecap, this.wireframeLinejoin = a.wireframeLinejoin, this.vertexColors = a.vertexColors, this.skinning = a.skinning, this.morphTargets = a.morphTargets, this.morphNormals = a.morphNormals, this
    },
    // File:src/materials/MeshPhongMaterial.js
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  specular: <hex>,
     *  shininess: <float>,
     *  opacity: <float>,
     *
     *  map: new THREE.Texture( <Image> ),
     *
     *  lightMap: new THREE.Texture( <Image> ),
     *  lightMapIntensity: <float>
     *
     *  aoMap: new THREE.Texture( <Image> ),
     *  aoMapIntensity: <float>
     *
     *  emissive: <hex>,
     *  emissiveIntensity: <float>
     *  emissiveMap: new THREE.Texture( <Image> ),
     *
     *  bumpMap: new THREE.Texture( <Image> ),
     *  bumpScale: <float>,
     *
     *  normalMap: new THREE.Texture( <Image> ),
     *  normalScale: <Vector2>,
     *
     *  displacementMap: new THREE.Texture( <Image> ),
     *  displacementScale: <float>,
     *  displacementBias: <float>,
     *
     *  specularMap: new THREE.Texture( <Image> ),
     *
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
     *  combine: THREE.Multiply,
     *  reflectivity: <float>,
     *  refractionRatio: <float>,
     *
     *  shading: THREE.SmoothShading,
     *  blending: THREE.NormalBlending,
     *  depthTest: <bool>,
     *  depthWrite: <bool>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>,
     *
     *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>,
     *  morphNormals: <bool>,
     *
     *	fog: <bool>
     * }
     */
    THREE.MeshPhongMaterial = function(a) {
        THREE.Material.call(this), this.type = "MeshPhongMaterial", this.color = new THREE.Color(16777215), // diffuse
            this.specular = new THREE.Color(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new THREE.Color(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new THREE.Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = THREE.MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, this.fog = !0, this.shading = THREE.SmoothShading, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.vertexColors = THREE.NoColors, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(a)
    }, THREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype), THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial, THREE.MeshPhongMaterial.prototype.copy = function(a) {
        return THREE.Material.prototype.copy.call(this, a), this.color.copy(a.color), this.specular.copy(a.specular), this.shininess = a.shininess, this.map = a.map, this.lightMap = a.lightMap, this.lightMapIntensity = a.lightMapIntensity, this.aoMap = a.aoMap, this.aoMapIntensity = a.aoMapIntensity, this.emissive.copy(a.emissive), this.emissiveMap = a.emissiveMap, this.emissiveIntensity = a.emissiveIntensity, this.bumpMap = a.bumpMap, this.bumpScale = a.bumpScale, this.normalMap = a.normalMap, this.normalScale.copy(a.normalScale), this.displacementMap = a.displacementMap, this.displacementScale = a.displacementScale, this.displacementBias = a.displacementBias, this.specularMap = a.specularMap, this.alphaMap = a.alphaMap, this.envMap = a.envMap, this.combine = a.combine, this.reflectivity = a.reflectivity, this.refractionRatio = a.refractionRatio, this.fog = a.fog, this.shading = a.shading, this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, this.wireframeLinecap = a.wireframeLinecap, this.wireframeLinejoin = a.wireframeLinejoin, this.vertexColors = a.vertexColors, this.skinning = a.skinning, this.morphTargets = a.morphTargets, this.morphNormals = a.morphNormals, this
    },
    // File:src/materials/MeshStandardMaterial.js
    /**
     * @author WestLangley / http://github.com/WestLangley
     *
     * parameters = {
     *  color: <hex>,
     *  roughness: <float>,
     *  metalness: <float>,
     *  opacity: <float>,
     *
     *  map: new THREE.Texture( <Image> ),
     *
     *  lightMap: new THREE.Texture( <Image> ),
     *  lightMapIntensity: <float>
     *
     *  aoMap: new THREE.Texture( <Image> ),
     *  aoMapIntensity: <float>
     *
     *  emissive: <hex>,
     *  emissiveIntensity: <float>
     *  emissiveMap: new THREE.Texture( <Image> ),
     *
     *  bumpMap: new THREE.Texture( <Image> ),
     *  bumpScale: <float>,
     *
     *  normalMap: new THREE.Texture( <Image> ),
     *  normalScale: <Vector2>,
     *
     *  displacementMap: new THREE.Texture( <Image> ),
     *  displacementScale: <float>,
     *  displacementBias: <float>,
     *
     *  roughnessMap: new THREE.Texture( <Image> ),
     *
     *  metalnessMap: new THREE.Texture( <Image> ),
     *
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
     *  envMapIntensity: <float>
     *
     *  refractionRatio: <float>,
     *
     *  shading: THREE.SmoothShading,
     *  blending: THREE.NormalBlending,
     *  depthTest: <bool>,
     *  depthWrite: <bool>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>,
     *
     *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>,
     *  morphNormals: <bool>,
     *
     *	fog: <bool>
     * }
     */
    THREE.MeshStandardMaterial = function(a) {
        THREE.Material.call(this), this.type = "MeshStandardMaterial", this.color = new THREE.Color(16777215), // diffuse
            this.roughness = .5, this.metalness = .5, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new THREE.Color(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new THREE.Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.fog = !0, this.shading = THREE.SmoothShading, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.vertexColors = THREE.NoColors, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(a)
    }, THREE.MeshStandardMaterial.prototype = Object.create(THREE.Material.prototype), THREE.MeshStandardMaterial.prototype.constructor = THREE.MeshStandardMaterial, THREE.MeshStandardMaterial.prototype.copy = function(a) {
        return THREE.Material.prototype.copy.call(this, a), this.color.copy(a.color), this.roughness = a.roughness, this.metalness = a.metalness, this.map = a.map, this.lightMap = a.lightMap, this.lightMapIntensity = a.lightMapIntensity, this.aoMap = a.aoMap, this.aoMapIntensity = a.aoMapIntensity, this.emissive.copy(a.emissive), this.emissiveMap = a.emissiveMap, this.emissiveIntensity = a.emissiveIntensity, this.bumpMap = a.bumpMap, this.bumpScale = a.bumpScale, this.normalMap = a.normalMap, this.normalScale.copy(a.normalScale), this.displacementMap = a.displacementMap, this.displacementScale = a.displacementScale, this.displacementBias = a.displacementBias, this.roughnessMap = a.roughnessMap, this.metalnessMap = a.metalnessMap, this.alphaMap = a.alphaMap, this.envMap = a.envMap, this.envMapIntensity = a.envMapIntensity, this.refractionRatio = a.refractionRatio, this.fog = a.fog, this.shading = a.shading, this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, this.wireframeLinecap = a.wireframeLinecap, this.wireframeLinejoin = a.wireframeLinejoin, this.vertexColors = a.vertexColors, this.skinning = a.skinning, this.morphTargets = a.morphTargets, this.morphNormals = a.morphNormals, this
    },
    // File:src/materials/MeshDepthMaterial.js
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  opacity: <float>,
     *
     *  blending: THREE.NormalBlending,
     *  depthTest: <bool>,
     *  depthWrite: <bool>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>
     * }
     */
    THREE.MeshDepthMaterial = function(a) {
        THREE.Material.call(this), this.type = "MeshDepthMaterial", this.morphTargets = !1, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(a)
    }, THREE.MeshDepthMaterial.prototype = Object.create(THREE.Material.prototype), THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial, THREE.MeshDepthMaterial.prototype.copy = function(a) {
        return THREE.Material.prototype.copy.call(this, a), this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, this
    },
    // File:src/materials/MeshNormalMaterial.js
    /**
     * @author mrdoob / http://mrdoob.com/
     *
     * parameters = {
     *  opacity: <float>,
     *
     *  shading: THREE.FlatShading,
     *  blending: THREE.NormalBlending,
     *  depthTest: <bool>,
     *  depthWrite: <bool>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>
     * }
     */
    THREE.MeshNormalMaterial = function(a) {
        THREE.Material.call(this, a), this.type = "MeshNormalMaterial", this.wireframe = !1, this.wireframeLinewidth = 1, this.morphTargets = !1, this.setValues(a)
    }, THREE.MeshNormalMaterial.prototype = Object.create(THREE.Material.prototype), THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial, THREE.MeshNormalMaterial.prototype.copy = function(a) {
        return THREE.Material.prototype.copy.call(this, a), this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, this
    },
    // File:src/materials/MultiMaterial.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.MultiMaterial = function(a) {
        this.uuid = THREE.Math.generateUUID(), this.type = "MultiMaterial", this.materials = a instanceof Array ? a : [], this.visible = !0
    }, THREE.MultiMaterial.prototype = {
        constructor: THREE.MultiMaterial,
        toJSON: function(a) {
            for (var b = {
                    metadata: {
                        version: 4.2,
                        type: "material",
                        generator: "MaterialExporter"
                    },
                    uuid: this.uuid,
                    type: this.type,
                    materials: []
                }, c = this.materials, d = 0, e = c.length; e > d; d++) {
                var f = c[d].toJSON(a);
                delete f.metadata, b.materials.push(f)
            }
            return b.visible = this.visible, b
        },
        clone: function() {
            for (var a = new this.constructor, b = 0; b < this.materials.length; b++) a.materials.push(this.materials[b].clone());
            return a.visible = this.visible, a
        }
    },
    // File:src/materials/PointsMaterial.js
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *  map: new THREE.Texture( <Image> ),
     *
     *  size: <float>,
     *  sizeAttenuation: <bool>,
     *
     *  blending: THREE.NormalBlending,
     *  depthTest: <bool>,
     *  depthWrite: <bool>,
     *
     *  vertexColors: <bool>,
     *
     *  fog: <bool>
     * }
     */
    THREE.PointsMaterial = function(a) {
        THREE.Material.call(this), this.type = "PointsMaterial", this.color = new THREE.Color(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.vertexColors = THREE.NoColors, this.fog = !0, this.setValues(a)
    }, THREE.PointsMaterial.prototype = Object.create(THREE.Material.prototype), THREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial, THREE.PointsMaterial.prototype.copy = function(a) {
        return THREE.Material.prototype.copy.call(this, a), this.color.copy(a.color), this.map = a.map, this.size = a.size, this.sizeAttenuation = a.sizeAttenuation, this.vertexColors = a.vertexColors, this.fog = a.fog, this
    },
    // File:src/materials/ShaderMaterial.js
    /**
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  defines: { "label" : "value" },
     *  uniforms: { "parameter1": { type: "f", value: 1.0 }, "parameter2": { type: "i" value2: 2 } },
     *
     *  fragmentShader: <string>,
     *  vertexShader: <string>,
     *
     *  shading: THREE.SmoothShading,
     *  blending: THREE.NormalBlending,
     *  depthTest: <bool>,
     *  depthWrite: <bool>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>,
     *
     *  lights: <bool>,
     *
     *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>,
     *  morphNormals: <bool>,
     *
     *	fog: <bool>
     * }
     */
    THREE.ShaderMaterial = function(a) {
        THREE.Material.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.shading = THREE.SmoothShading, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, // set to use scene fog
            this.lights = !1, // set to use scene lights
            this.vertexColors = THREE.NoColors, // set to use "color" attribute stream
            this.skinning = !1, // set to use skinning attribute streams
            this.morphTargets = !1, // set to use morph targets
            this.morphNormals = !1, // set to use morph normals
            this.extensions = {
                derivatives: !1, // set to use derivatives
                fragDepth: !1, // set to use fragment depth values
                drawBuffers: !1, // set to use draw buffers
                shaderTextureLOD: !1
            },
            // When rendered geometry doesn't include these attributes but the material does,
            // use these default values in WebGL. This avoids errors when buffer data is missing.
            this.defaultAttributeValues = {
                color: [1, 1, 1],
                uv: [0, 0],
                uv2: [0, 0]
            }, this.index0AttributeName = void 0, void 0 !== a && (void 0 !== a.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(a))
    }, THREE.ShaderMaterial.prototype = Object.create(THREE.Material.prototype), THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial, THREE.ShaderMaterial.prototype.copy = function(a) {
        return THREE.Material.prototype.copy.call(this, a), this.fragmentShader = a.fragmentShader, this.vertexShader = a.vertexShader, this.uniforms = THREE.UniformsUtils.clone(a.uniforms), this.defines = a.defines, this.shading = a.shading, this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, this.fog = a.fog, this.lights = a.lights, this.vertexColors = a.vertexColors, this.skinning = a.skinning, this.morphTargets = a.morphTargets, this.morphNormals = a.morphNormals, this.extensions = a.extensions, this
    }, THREE.ShaderMaterial.prototype.toJSON = function(a) {
        var b = THREE.Material.prototype.toJSON.call(this, a);
        return b.uniforms = this.uniforms, b.vertexShader = this.vertexShader, b.fragmentShader = this.fragmentShader, b
    },
    // File:src/materials/RawShaderMaterial.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.RawShaderMaterial = function(a) {
        THREE.ShaderMaterial.call(this, a), this.type = "RawShaderMaterial"
    }, THREE.RawShaderMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype), THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial,
    // File:src/materials/SpriteMaterial.js
    /**
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *  map: new THREE.Texture( <Image> ),
     *
     *  blending: THREE.NormalBlending,
     *  depthTest: <bool>,
     *  depthWrite: <bool>,
     *
     *	uvOffset: new THREE.Vector2(),
     *	uvScale: new THREE.Vector2(),
     *
     *  fog: <bool>
     * }
     */
    THREE.SpriteMaterial = function(a) {
        THREE.Material.call(this), this.type = "SpriteMaterial", this.color = new THREE.Color(16777215), this.map = null, this.rotation = 0, this.fog = !1,
            // set parameters
            this.setValues(a)
    }, THREE.SpriteMaterial.prototype = Object.create(THREE.Material.prototype), THREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial, THREE.SpriteMaterial.prototype.copy = function(a) {
        return THREE.Material.prototype.copy.call(this, a), this.color.copy(a.color), this.map = a.map, this.rotation = a.rotation, this.fog = a.fog, this
    },
    // File:src/textures/Texture.js
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     * @author szimek / https://github.com/szimek/
     */
    THREE.Texture = function(a, b, c, d, e, f, g, h, i) {
        Object.defineProperty(this, "id", {
                value: THREE.TextureIdCount++
            }), this.uuid = THREE.Math.generateUUID(), this.name = "", this.sourceFile = "", this.image = void 0 !== a ? a : THREE.Texture.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== b ? b : THREE.Texture.DEFAULT_MAPPING, this.wrapS = void 0 !== c ? c : THREE.ClampToEdgeWrapping, this.wrapT = void 0 !== d ? d : THREE.ClampToEdgeWrapping, this.magFilter = void 0 !== e ? e : THREE.LinearFilter, this.minFilter = void 0 !== f ? f : THREE.LinearMipMapLinearFilter, this.anisotropy = void 0 !== i ? i : 1, this.format = void 0 !== g ? g : THREE.RGBAFormat, this.type = void 0 !== h ? h : THREE.UnsignedByteType, this.offset = new THREE.Vector2(0, 0), this.repeat = new THREE.Vector2(1, 1), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
            this.version = 0, this.onUpdate = null
    }, THREE.Texture.DEFAULT_IMAGE = void 0, THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping, THREE.Texture.prototype = {
        constructor: THREE.Texture,
        set needsUpdate(a) {
            a === !0 && this.version++
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(a) {
            return this.image = a.image, this.mipmaps = a.mipmaps.slice(0), this.mapping = a.mapping, this.wrapS = a.wrapS, this.wrapT = a.wrapT, this.magFilter = a.magFilter, this.minFilter = a.minFilter, this.anisotropy = a.anisotropy, this.format = a.format, this.type = a.type, this.offset.copy(a.offset), this.repeat.copy(a.repeat), this.generateMipmaps = a.generateMipmaps, this.premultiplyAlpha = a.premultiplyAlpha, this.flipY = a.flipY, this.unpackAlignment = a.unpackAlignment, this
        },
        toJSON: function(a) {
            function b(a) {
                var b;
                return void 0 !== a.toDataURL ? b = a : (b = document.createElement("canvas"), b.width = a.width, b.height = a.height, b.getContext("2d").drawImage(a, 0, 0, a.width, a.height)), b.width > 2048 || b.height > 2048 ? b.toDataURL("image/jpeg", .6) : b.toDataURL("image/png")
            }
            if (void 0 !== a.textures[this.uuid]) return a.textures[this.uuid];
            var c = {
                metadata: {
                    version: 4.4,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                wrap: [this.wrapS, this.wrapT],
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy
            };
            if (void 0 !== this.image) {
                // TODO: Move to THREE.Image
                var d = this.image;
                void 0 === d.uuid && (d.uuid = THREE.Math.generateUUID()), void 0 === a.images[d.uuid] && (a.images[d.uuid] = {
                    uuid: d.uuid,
                    url: b(d)
                }), c.image = d.uuid
            }
            return a.textures[this.uuid] = c, c
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        },
        transformUv: function(a) {
            if (this.mapping === THREE.UVMapping) {
                if (a.multiply(this.repeat), a.add(this.offset), a.x < 0 || a.x > 1) switch (this.wrapS) {
                    case THREE.RepeatWrapping:
                        a.x = a.x - Math.floor(a.x);
                        break;
                    case THREE.ClampToEdgeWrapping:
                        a.x = a.x < 0 ? 0 : 1;
                        break;
                    case THREE.MirroredRepeatWrapping:
                        1 === Math.abs(Math.floor(a.x) % 2) ? a.x = Math.ceil(a.x) - a.x : a.x = a.x - Math.floor(a.x)
                }
                if (a.y < 0 || a.y > 1) switch (this.wrapT) {
                    case THREE.RepeatWrapping:
                        a.y = a.y - Math.floor(a.y);
                        break;
                    case THREE.ClampToEdgeWrapping:
                        a.y = a.y < 0 ? 0 : 1;
                        break;
                    case THREE.MirroredRepeatWrapping:
                        1 === Math.abs(Math.floor(a.y) % 2) ? a.y = Math.ceil(a.y) - a.y : a.y = a.y - Math.floor(a.y)
                }
                this.flipY && (a.y = 1 - a.y)
            }
        }
    }, THREE.EventDispatcher.prototype.apply(THREE.Texture.prototype), THREE.TextureIdCount = 0,
    // File:src/textures/CanvasTexture.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.CanvasTexture = function(a, b, c, d, e, f, g, h, i) {
        THREE.Texture.call(this, a, b, c, d, e, f, g, h, i), this.needsUpdate = !0
    }, THREE.CanvasTexture.prototype = Object.create(THREE.Texture.prototype), THREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture,
    // File:src/textures/CubeTexture.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.CubeTexture = function(a, b, c, d, e, f, g, h, i) {
        b = void 0 !== b ? b : THREE.CubeReflectionMapping, THREE.Texture.call(this, a, b, c, d, e, f, g, h, i), this.images = a, this.flipY = !1
    }, THREE.CubeTexture.prototype = Object.create(THREE.Texture.prototype), THREE.CubeTexture.prototype.constructor = THREE.CubeTexture, THREE.CubeTexture.prototype.copy = function(a) {
        return THREE.Texture.prototype.copy.call(this, a), this.images = a.images, this
    },
    // File:src/textures/CompressedTexture.js
    /**
     * @author alteredq / http://alteredqualia.com/
     */
    THREE.CompressedTexture = function(a, b, c, d, e, f, g, h, i, j, k) {
        THREE.Texture.call(this, null, f, g, h, i, j, d, e, k), this.image = {
                width: b,
                height: c
            }, this.mipmaps = a,
            // no flipping for cube textures
            // (also flipping doesn't work for compressed textures )
            this.flipY = !1,
            // can't generate mipmaps for compressed textures
            // mips must be embedded in DDS files
            this.generateMipmaps = !1
    }, THREE.CompressedTexture.prototype = Object.create(THREE.Texture.prototype), THREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture,
    // File:src/textures/DataTexture.js
    /**
     * @author alteredq / http://alteredqualia.com/
     */
    THREE.DataTexture = function(a, b, c, d, e, f, g, h, i, j, k) {
        THREE.Texture.call(this, null, f, g, h, i, j, d, e, k), this.image = {
            data: a,
            width: b,
            height: c
        }, this.magFilter = void 0 !== i ? i : THREE.NearestFilter, this.minFilter = void 0 !== j ? j : THREE.NearestFilter, this.flipY = !1, this.generateMipmaps = !1
    }, THREE.DataTexture.prototype = Object.create(THREE.Texture.prototype), THREE.DataTexture.prototype.constructor = THREE.DataTexture,
    // File:src/textures/VideoTexture.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.VideoTexture = function(a, b, c, d, e, f, g, h, i) {
        function j() {
            requestAnimationFrame(j), a.readyState === a.HAVE_ENOUGH_DATA && (k.needsUpdate = !0)
        }
        THREE.Texture.call(this, a, b, c, d, e, f, g, h, i), this.generateMipmaps = !1;
        var k = this;
        j()
    }, THREE.VideoTexture.prototype = Object.create(THREE.Texture.prototype), THREE.VideoTexture.prototype.constructor = THREE.VideoTexture,
    // File:src/objects/Group.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.Group = function() {
        THREE.Object3D.call(this), this.type = "Group"
    }, THREE.Group.prototype = Object.create(THREE.Object3D.prototype), THREE.Group.prototype.constructor = THREE.Group,
    // File:src/objects/Points.js
    /**
     * @author alteredq / http://alteredqualia.com/
     */
    THREE.Points = function(a, b) {
        THREE.Object3D.call(this), this.type = "Points", this.geometry = void 0 !== a ? a : new THREE.Geometry, this.material = void 0 !== b ? b : new THREE.PointsMaterial({
            color: 16777215 * Math.random()
        })
    }, THREE.Points.prototype = Object.create(THREE.Object3D.prototype), THREE.Points.prototype.constructor = THREE.Points, THREE.Points.prototype.raycast = function() {
        var a = new THREE.Matrix4,
            b = new THREE.Ray,
            c = new THREE.Sphere;
        return function(d, e) {
            function f(a, c) {
                var f = b.distanceSqToPoint(a);
                if (l > f) {
                    var h = b.closestPointToPoint(a);
                    h.applyMatrix4(i);
                    var j = d.ray.origin.distanceTo(h);
                    if (j < d.near || j > d.far) return;
                    e.push({
                        distance: j,
                        distanceToRay: Math.sqrt(f),
                        point: h.clone(),
                        index: c,
                        face: null,
                        object: g
                    })
                }
            }
            var g = this,
                h = this.geometry,
                i = this.matrixWorld,
                j = d.params.Points.threshold;
            if (
                // Checking boundingSphere distance to ray
                null === h.boundingSphere && h.computeBoundingSphere(), c.copy(h.boundingSphere), c.applyMatrix4(i), d.ray.intersectsSphere(c) !== !1) {
                //
                a.getInverse(i), b.copy(d.ray).applyMatrix4(a);
                var k = j / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                    l = k * k,
                    m = new THREE.Vector3;
                if (h instanceof THREE.BufferGeometry) {
                    var n = h.index,
                        o = h.attributes,
                        p = o.position.array;
                    if (null !== n)
                        for (var q = n.array, r = 0, s = q.length; s > r; r++) {
                            var t = q[r];
                            m.fromArray(p, 3 * t), f(m, t)
                        } else
                            for (var r = 0, u = p.length / 3; u > r; r++) m.fromArray(p, 3 * r), f(m, r)
                } else
                    for (var v = h.vertices, r = 0, u = v.length; u > r; r++) f(v[r], r)
            }
        }
    }(), THREE.Points.prototype.clone = function() {
        return new this.constructor(this.geometry, this.material).copy(this)
    },
    // File:src/objects/Line.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.Line = function(a, b, c) {
        return 1 === c ? (console.warn("THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead."), new THREE.LineSegments(a, b)) : (THREE.Object3D.call(this), this.type = "Line", this.geometry = void 0 !== a ? a : new THREE.Geometry, void(this.material = void 0 !== b ? b : new THREE.LineBasicMaterial({
            color: 16777215 * Math.random()
        })))
    }, THREE.Line.prototype = Object.create(THREE.Object3D.prototype), THREE.Line.prototype.constructor = THREE.Line, THREE.Line.prototype.raycast = function() {
        var a = new THREE.Matrix4,
            b = new THREE.Ray,
            c = new THREE.Sphere;
        return function(d, e) {
            var f = d.linePrecision,
                g = f * f,
                h = this.geometry,
                i = this.matrixWorld;
            if (
                // Checking boundingSphere distance to ray
                null === h.boundingSphere && h.computeBoundingSphere(), c.copy(h.boundingSphere), c.applyMatrix4(i), d.ray.intersectsSphere(c) !== !1) {
                //
                a.getInverse(i), b.copy(d.ray).applyMatrix4(a);
                var j = new THREE.Vector3,
                    k = new THREE.Vector3,
                    l = new THREE.Vector3,
                    m = new THREE.Vector3,
                    n = this instanceof THREE.LineSegments ? 2 : 1;
                if (h instanceof THREE.BufferGeometry) {
                    var o = h.index,
                        p = h.attributes,
                        q = p.position.array;
                    if (null !== o)
                        for (var r = o.array, s = 0, t = r.length - 1; t > s; s += n) {
                            var u = r[s],
                                v = r[s + 1];
                            j.fromArray(q, 3 * u), k.fromArray(q, 3 * v);
                            var w = b.distanceSqToSegment(j, k, m, l);
                            if (!(w > g)) {
                                m.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation
                                var x = d.ray.origin.distanceTo(m);
                                x < d.near || x > d.far || e.push({
                                    distance: x,
                                    // What do we want? intersection point on the ray or on the segment??
                                    // point: raycaster.ray.at( distance ),
                                    point: l.clone().applyMatrix4(this.matrixWorld),
                                    index: s,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                            }
                        } else
                            for (var s = 0, t = q.length / 3 - 1; t > s; s += n) {
                                j.fromArray(q, 3 * s), k.fromArray(q, 3 * s + 3);
                                var w = b.distanceSqToSegment(j, k, m, l);
                                if (!(w > g)) {
                                    m.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation
                                    var x = d.ray.origin.distanceTo(m);
                                    x < d.near || x > d.far || e.push({
                                        distance: x,
                                        // What do we want? intersection point on the ray or on the segment??
                                        // point: raycaster.ray.at( distance ),
                                        point: l.clone().applyMatrix4(this.matrixWorld),
                                        index: s,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    })
                                }
                            }
                } else if (h instanceof THREE.Geometry)
                    for (var y = h.vertices, z = y.length, s = 0; z - 1 > s; s += n) {
                        var w = b.distanceSqToSegment(y[s], y[s + 1], m, l);
                        if (!(w > g)) {
                            m.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation
                            var x = d.ray.origin.distanceTo(m);
                            x < d.near || x > d.far || e.push({
                                distance: x,
                                // What do we want? intersection point on the ray or on the segment??
                                // point: raycaster.ray.at( distance ),
                                point: l.clone().applyMatrix4(this.matrixWorld),
                                index: s,
                                face: null,
                                faceIndex: null,
                                object: this
                            })
                        }
                    }
            }
        }
    }(), THREE.Line.prototype.clone = function() {
        return new this.constructor(this.geometry, this.material).copy(this)
    },
    // DEPRECATED
    THREE.LineStrip = 0, THREE.LinePieces = 1,
    // File:src/objects/LineSegments.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.LineSegments = function(a, b) {
        THREE.Line.call(this, a, b), this.type = "LineSegments"
    }, THREE.LineSegments.prototype = Object.create(THREE.Line.prototype), THREE.LineSegments.prototype.constructor = THREE.LineSegments,
    // File:src/objects/Mesh.js
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     * @author mikael emtinger / http://gomo.se/
     * @author jonobr1 / http://jonobr1.com/
     */
    THREE.Mesh = function(a, b) {
        THREE.Object3D.call(this), this.type = "Mesh", this.geometry = void 0 !== a ? a : new THREE.Geometry, this.material = void 0 !== b ? b : new THREE.MeshBasicMaterial({
            color: 16777215 * Math.random()
        }), this.drawMode = THREE.TrianglesDrawMode, this.updateMorphTargets()
    }, THREE.Mesh.prototype = Object.create(THREE.Object3D.prototype), THREE.Mesh.prototype.constructor = THREE.Mesh, THREE.Mesh.prototype.setDrawMode = function(a) {
        this.drawMode = a
    }, THREE.Mesh.prototype.updateMorphTargets = function() {
        if (void 0 !== this.geometry.morphTargets && this.geometry.morphTargets.length > 0) {
            this.morphTargetBase = -1, this.morphTargetInfluences = [], this.morphTargetDictionary = {};
            for (var a = 0, b = this.geometry.morphTargets.length; b > a; a++) this.morphTargetInfluences.push(0), this.morphTargetDictionary[this.geometry.morphTargets[a].name] = a
        }
    }, THREE.Mesh.prototype.getMorphTargetIndexByName = function(a) {
        return void 0 !== this.morphTargetDictionary[a] ? this.morphTargetDictionary[a] : (console.warn("THREE.Mesh.getMorphTargetIndexByName: morph target " + a + " does not exist. Returning 0."), 0)
    }, THREE.Mesh.prototype.raycast = function() {
        function a(a, b, c, d, e, f, g) {
            return THREE.Triangle.barycoordFromPoint(a, b, c, d, p), e.multiplyScalar(p.x), f.multiplyScalar(p.y), g.multiplyScalar(p.z), e.add(f).add(g), e.clone()
        }

        function b(a, b, c, d, e, f, g) {
            var h, i = a.material;
            if (h = i.side === THREE.BackSide ? c.intersectTriangle(f, e, d, !0, g) : c.intersectTriangle(d, e, f, i.side !== THREE.DoubleSide, g), null === h) return null;
            r.copy(g), r.applyMatrix4(a.matrixWorld);
            var j = b.ray.origin.distanceTo(r);
            return j < b.near || j > b.far ? null : {
                distance: j,
                point: r.clone(),
                object: a
            }
        }

        function c(c, d, e, f, j, k, l, p) {
            g.fromArray(f, 3 * k), h.fromArray(f, 3 * l), i.fromArray(f, 3 * p);
            var r = b(c, d, e, g, h, i, q);
            return r && (j && (m.fromArray(j, 2 * k), n.fromArray(j, 2 * l), o.fromArray(j, 2 * p), r.uv = a(q, g, h, i, m, n, o)), r.face = new THREE.Face3(k, l, p, THREE.Triangle.normal(g, h, i)), r.faceIndex = k), r
        }
        var d = new THREE.Matrix4,
            e = new THREE.Ray,
            f = new THREE.Sphere,
            g = new THREE.Vector3,
            h = new THREE.Vector3,
            i = new THREE.Vector3,
            j = new THREE.Vector3,
            k = new THREE.Vector3,
            l = new THREE.Vector3,
            m = new THREE.Vector2,
            n = new THREE.Vector2,
            o = new THREE.Vector2,
            p = new THREE.Vector3,
            q = new THREE.Vector3,
            r = new THREE.Vector3;
        return function(p, r) {
            var s = this.geometry,
                t = this.material,
                u = this.matrixWorld;
            if (void 0 !== t && (null === s.boundingSphere && s.computeBoundingSphere(), f.copy(s.boundingSphere), f.applyMatrix4(u), p.ray.intersectsSphere(f) !== !1 && (d.getInverse(u), e.copy(p.ray).applyMatrix4(d), null === s.boundingBox || e.intersectsBox(s.boundingBox) !== !1)))
            // Check boundingBox before continuing
            {
                var v, w;
                if (s instanceof THREE.BufferGeometry) {
                    var x, y, z, A = s.index,
                        B = s.attributes,
                        C = B.position.array;
                    if (void 0 !== B.uv && (v = B.uv.array), null !== A)
                        for (var D = A.array, E = 0, F = D.length; F > E; E += 3) x = D[E], y = D[E + 1], z = D[E + 2], w = c(this, p, e, C, v, x, y, z), w && (w.faceIndex = Math.floor(E / 3), r.push(w));
                    else
                        for (var E = 0, F = C.length; F > E; E += 9) x = E / 3, y = x + 1, z = x + 2, w = c(this, p, e, C, v, x, y, z), w && (w.index = x, r.push(w))
                } else if (s instanceof THREE.Geometry) {
                    var G, H, I, J = t instanceof THREE.MultiMaterial,
                        K = J === !0 ? t.materials : null,
                        L = s.vertices,
                        M = s.faces,
                        N = s.faceVertexUvs[0];
                    N.length > 0 && (v = N);
                    for (var O = 0, P = M.length; P > O; O++) {
                        var Q = M[O],
                            R = J === !0 ? K[Q.materialIndex] : t;
                        if (void 0 !== R) {
                            if (G = L[Q.a], H = L[Q.b], I = L[Q.c], R.morphTargets === !0) {
                                var S = s.morphTargets,
                                    T = this.morphTargetInfluences;
                                g.set(0, 0, 0), h.set(0, 0, 0), i.set(0, 0, 0);
                                for (var U = 0, V = S.length; V > U; U++) {
                                    var W = T[U];
                                    if (0 !== W) {
                                        var X = S[U].vertices;
                                        g.addScaledVector(j.subVectors(X[Q.a], G), W), h.addScaledVector(k.subVectors(X[Q.b], H), W), i.addScaledVector(l.subVectors(X[Q.c], I), W)
                                    }
                                }
                                g.add(G), h.add(H), i.add(I), G = g, H = h, I = i
                            }
                            if (w = b(this, p, e, G, H, I, q)) {
                                if (v) {
                                    var Y = v[O];
                                    m.copy(Y[0]), n.copy(Y[1]), o.copy(Y[2]), w.uv = a(q, G, H, I, m, n, o)
                                }
                                w.face = Q, w.faceIndex = O, r.push(w)
                            }
                        }
                    }
                }
            }
        }
    }(), THREE.Mesh.prototype.clone = function() {
        return new this.constructor(this.geometry, this.material).copy(this)
    },
    // File:src/objects/Bone.js
    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author ikerr / http://verold.com
     */
    THREE.Bone = function(a) {
        THREE.Object3D.call(this), this.type = "Bone", this.skin = a
    }, THREE.Bone.prototype = Object.create(THREE.Object3D.prototype), THREE.Bone.prototype.constructor = THREE.Bone, THREE.Bone.prototype.copy = function(a) {
        return THREE.Object3D.prototype.copy.call(this, a), this.skin = a.skin, this
    },
    // File:src/objects/Skeleton.js
    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author michael guerrero / http://realitymeltdown.com
     * @author ikerr / http://verold.com
     */
    THREE.Skeleton = function(a, b, c) {
        // create a bone texture or an array of floats
        if (this.useVertexTexture = void 0 !== c ? c : !0, this.identityMatrix = new THREE.Matrix4, a = a || [], this.bones = a.slice(0), this.useVertexTexture) {
            // layout (1 matrix = 4 pixels)
            //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
            //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
            //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
            //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
            //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
            var d = Math.sqrt(4 * this.bones.length); // 4 pixels needed for 1 matrix
            d = THREE.Math.nextPowerOfTwo(Math.ceil(d)), d = Math.max(d, 4), this.boneTextureWidth = d, this.boneTextureHeight = d, this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4), // 4 floats per RGBA pixel
                this.boneTexture = new THREE.DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType)
        } else this.boneMatrices = new Float32Array(16 * this.bones.length);
        // use the supplied bone inverses or calculate the inverses
        if (void 0 === b) this.calculateInverses();
        else if (this.bones.length === b.length) this.boneInverses = b.slice(0);
        else {
            console.warn("THREE.Skeleton bonInverses is the wrong length."), this.boneInverses = [];
            for (var e = 0, f = this.bones.length; f > e; e++) this.boneInverses.push(new THREE.Matrix4)
        }
    }, THREE.Skeleton.prototype.calculateInverses = function() {
        this.boneInverses = [];
        for (var a = 0, b = this.bones.length; b > a; a++) {
            var c = new THREE.Matrix4;
            this.bones[a] && c.getInverse(this.bones[a].matrixWorld), this.boneInverses.push(c)
        }
    }, THREE.Skeleton.prototype.pose = function() {
        // recover the bind-time world matrices
        for (var a, b = 0, c = this.bones.length; c > b; b++) a = this.bones[b], a && a.matrixWorld.getInverse(this.boneInverses[b]);
        // compute the local matrices, positions, rotations and scales
        for (var b = 0, c = this.bones.length; c > b; b++) a = this.bones[b], a && (a.parent ? (a.matrix.getInverse(a.parent.matrixWorld), a.matrix.multiply(a.matrixWorld)) : a.matrix.copy(a.matrixWorld), a.matrix.decompose(a.position, a.quaternion, a.scale))
    }, THREE.Skeleton.prototype.update = function() {
        var a = new THREE.Matrix4;
        return function() {
            // flatten bone matrices to array
            for (var b = 0, c = this.bones.length; c > b; b++) {
                // compute the offset between the current and the original transform
                var d = this.bones[b] ? this.bones[b].matrixWorld : this.identityMatrix;
                a.multiplyMatrices(d, this.boneInverses[b]), a.flattenToArrayOffset(this.boneMatrices, 16 * b)
            }
            this.useVertexTexture && (this.boneTexture.needsUpdate = !0)
        }
    }(), THREE.Skeleton.prototype.clone = function() {
        return new THREE.Skeleton(this.bones, this.boneInverses, this.useVertexTexture)
    },
    // File:src/objects/SkinnedMesh.js
    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author ikerr / http://verold.com
     */
    THREE.SkinnedMesh = function(a, b, c) {
        THREE.Mesh.call(this, a, b), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new THREE.Matrix4, this.bindMatrixInverse = new THREE.Matrix4;
        // init bones
        // TODO: remove bone creation as there is no reason (other than
        // convenience) for THREE.SkinnedMesh to do this.
        var d = [];
        if (this.geometry && void 0 !== this.geometry.bones) {
            for (var e, f, g = 0, h = this.geometry.bones.length; h > g; ++g) f = this.geometry.bones[g], e = new THREE.Bone(this), d.push(e), e.name = f.name, e.position.fromArray(f.pos), e.quaternion.fromArray(f.rotq), void 0 !== f.scl && e.scale.fromArray(f.scl);
            for (var g = 0, h = this.geometry.bones.length; h > g; ++g) f = this.geometry.bones[g], -1 !== f.parent && null !== f.parent ? d[f.parent].add(d[g]) : this.add(d[g])
        }
        this.normalizeSkinWeights(), this.updateMatrixWorld(!0), this.bind(new THREE.Skeleton(d, void 0, c), this.matrixWorld)
    }, THREE.SkinnedMesh.prototype = Object.create(THREE.Mesh.prototype), THREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh, THREE.SkinnedMesh.prototype.bind = function(a, b) {
        this.skeleton = a, void 0 === b && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), b = this.matrixWorld), this.bindMatrix.copy(b), this.bindMatrixInverse.getInverse(b)
    }, THREE.SkinnedMesh.prototype.pose = function() {
        this.skeleton.pose()
    }, THREE.SkinnedMesh.prototype.normalizeSkinWeights = function() {
        if (this.geometry instanceof THREE.Geometry)
            for (var a = 0; a < this.geometry.skinWeights.length; a++) {
                var b = this.geometry.skinWeights[a],
                    c = 1 / b.lengthManhattan();
                c !== 1 / 0 ? b.multiplyScalar(c) : b.set(1, 0, 0, 0)
            } else if (this.geometry instanceof THREE.BufferGeometry)
                for (var d = new THREE.Vector4, e = this.geometry.attributes.skinWeight, a = 0; a < e.count; a++) {
                    d.x = e.getX(a), d.y = e.getY(a), d.z = e.getZ(a), d.w = e.getW(a);
                    var c = 1 / d.lengthManhattan();
                    c !== 1 / 0 ? d.multiplyScalar(c) : d.set(1, 0, 0, 0), e.setXYZW(a, d.x, d.y, d.z, d.w)
                }
    }, THREE.SkinnedMesh.prototype.updateMatrixWorld = function(a) {
        THREE.Mesh.prototype.updateMatrixWorld.call(this, !0), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh unrecognized bindMode: " + this.bindMode)
    }, THREE.SkinnedMesh.prototype.clone = function() {
        return new this.constructor(this.geometry, this.material, this.useVertexTexture).copy(this)
    },
    // File:src/objects/LOD.js
    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.LOD = function() {
        THREE.Object3D.call(this), this.type = "LOD", Object.defineProperties(this, {
            levels: {
                enumerable: !0,
                value: []
            },
            objects: {
                get: function() {
                    return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels
                }
            }
        })
    }, THREE.LOD.prototype = Object.create(THREE.Object3D.prototype), THREE.LOD.prototype.constructor = THREE.LOD, THREE.LOD.prototype.addLevel = function(a, b) {
        void 0 === b && (b = 0), b = Math.abs(b);
        for (var c = this.levels, d = 0; d < c.length && !(b < c[d].distance); d++);
        c.splice(d, 0, {
            distance: b,
            object: a
        }), this.add(a)
    }, THREE.LOD.prototype.getObjectForDistance = function(a) {
        for (var b = this.levels, c = 1, d = b.length; d > c && !(a < b[c].distance); c++);
        return b[c - 1].object
    }, THREE.LOD.prototype.raycast = function() {
        var a = new THREE.Vector3;
        return function(b, c) {
            a.setFromMatrixPosition(this.matrixWorld);
            var d = b.ray.origin.distanceTo(a);
            this.getObjectForDistance(d).raycast(b, c)
        }
    }(), THREE.LOD.prototype.update = function() {
        var a = new THREE.Vector3,
            b = new THREE.Vector3;
        return function(c) {
            var d = this.levels;
            if (d.length > 1) {
                a.setFromMatrixPosition(c.matrixWorld), b.setFromMatrixPosition(this.matrixWorld);
                var e = a.distanceTo(b);
                d[0].object.visible = !0;
                for (var f = 1, g = d.length; g > f && e >= d[f].distance; f++) d[f - 1].object.visible = !1, d[f].object.visible = !0;
                for (; g > f; f++) d[f].object.visible = !1
            }
        }
    }(), THREE.LOD.prototype.copy = function(a) {
        THREE.Object3D.prototype.copy.call(this, a, !1);
        for (var b = a.levels, c = 0, d = b.length; d > c; c++) {
            var e = b[c];
            this.addLevel(e.object.clone(), e.distance)
        }
        return this
    }, THREE.LOD.prototype.toJSON = function(a) {
        var b = THREE.Object3D.prototype.toJSON.call(this, a);
        b.object.levels = [];
        for (var c = this.levels, d = 0, e = c.length; e > d; d++) {
            var f = c[d];
            b.object.levels.push({
                object: f.object.uuid,
                distance: f.distance
            })
        }
        return b
    },
    // File:src/objects/Sprite.js
    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     */
    THREE.Sprite = function() {
        var a = new Uint16Array([0, 1, 2, 0, 2, 3]),
            b = new Float32Array([-.5, -.5, 0, .5, -.5, 0, .5, .5, 0, -.5, .5, 0]),
            c = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
            d = new THREE.BufferGeometry;
        return d.setIndex(new THREE.BufferAttribute(a, 1)), d.addAttribute("position", new THREE.BufferAttribute(b, 3)), d.addAttribute("uv", new THREE.BufferAttribute(c, 2)),
            function(a) {
                THREE.Object3D.call(this), this.type = "Sprite", this.geometry = d, this.material = void 0 !== a ? a : new THREE.SpriteMaterial
            }
    }(), THREE.Sprite.prototype = Object.create(THREE.Object3D.prototype), THREE.Sprite.prototype.constructor = THREE.Sprite, THREE.Sprite.prototype.raycast = function() {
        var a = new THREE.Vector3;
        return function(b, c) {
            a.setFromMatrixPosition(this.matrixWorld);
            var d = b.ray.distanceSqToPoint(a),
                e = this.scale.x * this.scale.y;
            d > e || c.push({
                distance: Math.sqrt(d),
                point: this.position,
                face: null,
                object: this
            })
        }
    }(), THREE.Sprite.prototype.clone = function() {
        return new this.constructor(this.material).copy(this)
    },
    // Backwards compatibility
    THREE.Particle = THREE.Sprite,
    // File:src/objects/LensFlare.js
    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     */
    THREE.LensFlare = function(a, b, c, d, e) {
        THREE.Object3D.call(this), this.lensFlares = [], this.positionScreen = new THREE.Vector3, this.customUpdateCallback = void 0, void 0 !== a && this.add(a, b, c, d, e)
    }, THREE.LensFlare.prototype = Object.create(THREE.Object3D.prototype), THREE.LensFlare.prototype.constructor = THREE.LensFlare,
    /*
     * Add: adds another flare
     */
    THREE.LensFlare.prototype.add = function(a, b, c, d, e, f) {
        void 0 === b && (b = -1), void 0 === c && (c = 0), void 0 === f && (f = 1), void 0 === e && (e = new THREE.Color(16777215)), void 0 === d && (d = THREE.NormalBlending), c = Math.min(c, Math.max(0, c)), this.lensFlares.push({
            texture: a,
            size: b,
            distance: c,
            x: 0,
            y: 0,
            z: 0,
            scale: 1,
            rotation: 0,
            opacity: f,
            color: e,
            blending: d
        })
    },
    /*
     * Update lens flares update positions on all flares based on the screen position
     * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
     */
    THREE.LensFlare.prototype.updateLensFlares = function() {
        var a, b, c = this.lensFlares.length,
            d = 2 * -this.positionScreen.x,
            e = 2 * -this.positionScreen.y;
        for (a = 0; c > a; a++) b = this.lensFlares[a], b.x = this.positionScreen.x + d * b.distance, b.y = this.positionScreen.y + e * b.distance, b.wantedRotation = b.x * Math.PI * .25, b.rotation += .25 * (b.wantedRotation - b.rotation)
    }, THREE.LensFlare.prototype.copy = function(a) {
        THREE.Object3D.prototype.copy.call(this, a), this.positionScreen.copy(a.positionScreen), this.customUpdateCallback = a.customUpdateCallback;
        for (var b = 0, c = a.lensFlares.length; c > b; b++) this.lensFlares.push(a.lensFlares[b]);
        return this
    },
    // File:src/scenes/Scene.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.Scene = function() {
        THREE.Object3D.call(this), this.type = "Scene", this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0
    }, THREE.Scene.prototype = Object.create(THREE.Object3D.prototype), THREE.Scene.prototype.constructor = THREE.Scene, THREE.Scene.prototype.copy = function(a) {
        return THREE.Object3D.prototype.copy.call(this, a), null !== a.fog && (this.fog = a.fog.clone()), null !== a.overrideMaterial && (this.overrideMaterial = a.overrideMaterial.clone()), this.autoUpdate = a.autoUpdate, this.matrixAutoUpdate = a.matrixAutoUpdate, this
    },
    // File:src/scenes/Fog.js
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */
    THREE.Fog = function(a, b, c) {
        this.name = "", this.color = new THREE.Color(a), this.near = void 0 !== b ? b : 1, this.far = void 0 !== c ? c : 1e3
    }, THREE.Fog.prototype.clone = function() {
        return new THREE.Fog(this.color.getHex(), this.near, this.far)
    },
    // File:src/scenes/FogExp2.js
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */
    THREE.FogExp2 = function(a, b) {
        this.name = "", this.color = new THREE.Color(a), this.density = void 0 !== b ? b : 25e-5
    }, THREE.FogExp2.prototype.clone = function() {
        return new THREE.FogExp2(this.color.getHex(), this.density)
    },
    // File:src/renderers/shaders/ShaderChunk.js
    THREE.ShaderChunk = {},
    // File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl
    THREE.ShaderChunk.alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n",
    // File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl
    THREE.ShaderChunk.alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif\n",
    // File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl
    THREE.ShaderChunk.alphatest_fragment = "#ifdef ALPHATEST\n	if ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n",
    // File:src/renderers/shaders/ShaderChunk/ambient_pars.glsl
    THREE.ShaderChunk.ambient_pars = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	return PI * ambientLightColor;\n}\n",
    // File:src/renderers/shaders/ShaderChunk/aomap_fragment.glsl
    THREE.ShaderChunk.aomap_fragment = "#ifdef USE_AOMAP\n	reflectedLight.indirectDiffuse *= ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n#endif\n",
    // File:src/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl
    THREE.ShaderChunk.aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif",
    // File:src/renderers/shaders/ShaderChunk/begin_vertex.glsl
    THREE.ShaderChunk.begin_vertex = "\nvec3 transformed = vec3( position );\n",
    // File:src/renderers/shaders/ShaderChunk/beginnormal_vertex.glsl
    THREE.ShaderChunk.beginnormal_vertex = "\nvec3 objectNormal = vec3( normal );\n",
    // File:src/renderers/shaders/ShaderChunk/bsdfs.glsl
    THREE.ShaderChunk.bsdfs = "float calcLightAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	if ( decayExponent > 0.0 ) {\n	  return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n	}\n	return 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = alpha * alpha;\n	float gl = dotNL + pow( a2 + ( 1.0 - a2 ) * dotNL * dotNL, 0.5 );\n	float gv = dotNV + pow( a2 + ( 1.0 - a2 ) * dotNV * dotNV, 0.5 );\n	return 1.0 / ( gl * gv );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = alpha * alpha;\n	float denom = dotNH * dotNH * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / ( denom * denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n	float alpha = roughness * roughness;\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_GGX_Smith( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( G * D );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n	return specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n	return ( 2.0 / square( ggxRoughness + 0.0001 ) - 2.0 );\n}",
    // File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl
    THREE.ShaderChunk.bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n		vec3 vSigmaX = dFdx( surf_pos );\n		vec3 vSigmaY = dFdy( surf_pos );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 );\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif\n",
    // File:src/renderers/shaders/ShaderChunk/color_fragment.glsl
    THREE.ShaderChunk.color_fragment = "#ifdef USE_COLOR\n	diffuseColor.rgb *= vColor;\n#endif",
    // File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl
    THREE.ShaderChunk.color_pars_fragment = "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif\n",
    // File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl
    THREE.ShaderChunk.color_pars_vertex = "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif",
    // File:src/renderers/shaders/ShaderChunk/color_vertex.glsl
    THREE.ShaderChunk.color_vertex = "#ifdef USE_COLOR\n	vColor.xyz = color.xyz;\n#endif",
    // File:src/renderers/shaders/ShaderChunk/common.glsl
    THREE.ShaderChunk.common = "#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat square( const in float x ) { return x*x; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	float distance = dot( planeNormal, point - pointOnPlane );\n	return - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nvec3 inputToLinear( in vec3 a ) {\n	#ifdef GAMMA_INPUT\n		return pow( a, vec3( float( GAMMA_FACTOR ) ) );\n	#else\n		return a;\n	#endif\n}\nvec3 linearToOutput( in vec3 a ) {\n	#ifdef GAMMA_OUTPUT\n		return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n	#else\n		return a;\n	#endif\n}\n",
    // File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl
    THREE.ShaderChunk.defaultnormal_vertex = "#ifdef FLIP_SIDED\n	objectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n",
    // File:src/renderers/shaders/ShaderChunk/displacementmap_vertex.glsl
    THREE.ShaderChunk.displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n",
    // File:src/renderers/shaders/ShaderChunk/displacementmap_pars_vertex.glsl
    THREE.ShaderChunk.displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif\n",
    // File:src/renderers/shaders/ShaderChunk/emissivemap_fragment.glsl
    THREE.ShaderChunk.emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = inputToLinear( emissiveColor.rgb );\n	totalEmissiveLight *= emissiveColor.rgb;\n#endif\n",
    // File:src/renderers/shaders/ShaderChunk/emissivemap_pars_fragment.glsl
    THREE.ShaderChunk.emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif\n",
    // File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl
    THREE.ShaderChunk.envmap_fragment = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef DOUBLE_SIDED\n		float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n	#else\n		float flipNormal = 1.0;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_EQUIREC )\n		vec2 sampleUV;\n		sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n		sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n		vec4 envColor = texture2D( envMap, sampleUV );\n	#elif defined( ENVMAP_TYPE_SPHERE )\n		vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n	#endif\n	envColor.xyz = inputToLinear( envColor.xyz );\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif\n",
    // File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl
    THREE.ShaderChunk.envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( STANDARD )\n	uniform float reflectivity;\n	uniform float envMapIntenstiy;\n#endif\n#ifdef USE_ENVMAP\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	uniform float flipEnvMap;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( STANDARD )\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif\n",
    // File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl
    THREE.ShaderChunk.envmap_pars_vertex = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG ) && ! defined( STANDARD )\n	varying vec3 vReflect;\n	uniform float refractionRatio;\n#endif\n",
    // File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl
    THREE.ShaderChunk.envmap_vertex = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG ) && ! defined( STANDARD )\n	vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n	vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n	#ifdef ENVMAP_MODE_REFLECTION\n		vReflect = reflect( cameraToVertex, worldNormal );\n	#else\n		vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n	#endif\n#endif\n",
    // File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl
    THREE.ShaderChunk.fog_fragment = "#ifdef USE_FOG\n	#ifdef USE_LOGDEPTHBUF_EXT\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n	#else\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n	#endif\n	#ifdef FOG_EXP2\n		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, depth );\n	#endif\n	\n	outgoingLight = mix( outgoingLight, fogColor, fogFactor );\n#endif",
    // File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl
    THREE.ShaderChunk.fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif",
    // File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl
    THREE.ShaderChunk.lightmap_fragment = "#ifdef USE_LIGHTMAP\n	reflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n",
    // File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl
    THREE.ShaderChunk.lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif",
    // File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl
    THREE.ShaderChunk.lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		directLight = getPointDirectLight( pointLights[ i ], geometry );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		directLight = getSpotDirectLight( spotLights[ i ], geometry );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_DIR_LIGHTS > 0\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directLight = getDirectionalDirectLight( directionalLights[ i ], geometry );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		#ifdef DOUBLE_SIDED\n			vLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n		#endif\n	}\n#endif\n",
    // File:src/renderers/shaders/ShaderChunk/lights_pars.glsl
    THREE.ShaderChunk.lights_pars = "#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	IncidentLight getDirectionalDirectLight( const in DirectionalLight directionalLight, const in GeometricContext geometry ) {\n		IncidentLight directLight;\n		directLight.color = directionalLight.color;\n		directLight.direction = directionalLight.direction;\n		return directLight;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	IncidentLight getPointDirectLight( const in PointLight pointLight, const in GeometricContext geometry ) {\n		IncidentLight directLight;\n		vec3 lVector = pointLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		directLight.color = pointLight.color;\n		directLight.color *= calcLightAttenuation( length( lVector ), pointLight.distance, pointLight.decay );\n		return directLight;\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float angleCos;\n		float exponent;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	IncidentLight getSpotDirectLight( const in SpotLight spotLight, const in GeometricContext geometry ) {\n		IncidentLight directLight;\n		vec3 lVector = spotLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float spotEffect = dot( directLight.direction, spotLight.direction );\n		if ( spotEffect > spotLight.angleCos ) {\n			float spotEffect = dot( spotLight.direction, directLight.direction );\n			spotEffect = saturate( pow( saturate( spotEffect ), spotLight.exponent ) );\n			directLight.color = spotLight.color;\n			directLight.color *= ( spotEffect * calcLightAttenuation( length( lVector ), spotLight.distance, spotLight.decay ) );\n		} else {\n			directLight.color = vec3( 0.0 );\n		}\n		return directLight;\n	}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		return PI * mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n	}\n#endif\n#if defined( USE_ENVMAP ) && defined( STANDARD )\n	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n		#ifdef DOUBLE_SIDED\n			float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		#else\n			float flipNormal = 1.0;\n		#endif\n		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n			#endif\n		#else\n			vec3 envMapColor = vec3( 0.0 );\n		#endif\n		envMapColor.rgb = inputToLinear( envMapColor.rgb );\n		return PI * envMapColor.rgb * envMapIntensity;\n	}\n	float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n		float maxMIPLevelScalar = float( maxMIPLevel );\n		float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( square( blinnShininessExponent ) + 1.0 );\n		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n	}\n	vec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n		#else\n			vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n		#endif\n		#ifdef DOUBLE_SIDED\n			float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		#else\n			float flipNormal = 1.0;\n		#endif\n		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n		float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n			#endif\n		#elif defined( ENVMAP_TYPE_EQUIREC )\n			vec2 sampleUV;\n			sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n			sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n			#else\n				vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n			#endif\n		#elif defined( ENVMAP_TYPE_SPHERE )\n			vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n			#else\n				vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n			#endif\n		#endif\n		envMapColor.rgb = inputToLinear( envMapColor.rgb );\n		return envMapColor.rgb * envMapIntensity;\n	}\n#endif\n",
    // File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl
    THREE.ShaderChunk.lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n",
    // File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl
    THREE.ShaderChunk.lights_phong_pars_fragment = "#ifdef USE_ENVMAP\n	varying vec3 vWorldPosition;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n	vec3	diffuseColor;\n	vec3	specularColor;\n	float	specularShininess;\n	float	specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * PI * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)\n",
    // File:src/renderers/shaders/ShaderChunk/lights_phong_pars_vertex.glsl
    THREE.ShaderChunk.lights_phong_pars_vertex = "#ifdef USE_ENVMAP\n	varying vec3 vWorldPosition;\n#endif\n",
    // File:src/renderers/shaders/ShaderChunk/lights_phong_vertex.glsl
    THREE.ShaderChunk.lights_phong_vertex = "#ifdef USE_ENVMAP\n	vWorldPosition = worldPosition.xyz;\n#endif\n",
    // File:src/renderers/shaders/ShaderChunk/lights_standard_fragment.glsl
    THREE.ShaderChunk.lights_standard_fragment = "StandardMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\nmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n",
    // File:src/renderers/shaders/ShaderChunk/lights_standard_pars_fragment.glsl
    THREE.ShaderChunk.lights_standard_pars_fragment = "struct StandardMaterial {\n	vec3	diffuseColor;\n	float	specularRoughness;\n	vec3	specularColor;\n};\nvoid RE_Direct_Standard( const in IncidentLight directLight, const in GeometricContext geometry, const in StandardMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * PI * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n}\nvoid RE_IndirectDiffuse_Standard( const in vec3 irradiance, const in GeometricContext geometry, const in StandardMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Standard( const in vec3 radiance, const in GeometricContext geometry, const in StandardMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectSpecular += radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n}\n#define RE_Direct				RE_Direct_Standard\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Standard\n#define RE_IndirectSpecular		RE_IndirectSpecular_Standard\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n",
    // File:src/renderers/shaders/ShaderChunk/lights_template.glsl
    THREE.ShaderChunk.lights_template = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		directLight = getPointDirectLight( pointLight, geometry );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		directLight = getSpotDirectLight( spotLight, geometry );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		directLight = getDirectionalDirectLight( directionalLight, geometry );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	#ifdef USE_LIGHTMAP\n		irradiance += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n	#endif\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		}\n	#endif\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	vec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n	RE_IndirectSpecular( radiance, geometry, material, reflectedLight );\n#endif\n",
    // File:src/renderers/shaders/ShaderChunk/linear_to_gamma_fragment.glsl
    THREE.ShaderChunk.linear_to_gamma_fragment = "\n	outgoingLight = linearToOutput( outgoingLight );\n",
    // File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl
    THREE.ShaderChunk.logdepthbuf_fragment = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif",
    // File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl
    THREE.ShaderChunk.logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n	uniform float logDepthBufFC;\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n	#endif\n#endif\n",
    // File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl
    THREE.ShaderChunk.logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n	#endif\n	uniform float logDepthBufFC;\n#endif",
    // File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl
    THREE.ShaderChunk.logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n	#else\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n	#endif\n#endif\n",
    // File:src/renderers/shaders/ShaderChunk/map_fragment.glsl
    THREE.ShaderChunk.map_fragment = "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor.xyz = inputToLinear( texelColor.xyz );\n	diffuseColor *= texelColor;\n#endif\n",
    // File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl
    THREE.ShaderChunk.map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif",
    // File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl
    THREE.ShaderChunk.map_particle_fragment = "#ifdef USE_MAP\n	diffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n#endif\n",
    // File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl
    THREE.ShaderChunk.map_particle_pars_fragment = "#ifdef USE_MAP\n	uniform vec4 offsetRepeat;\n	uniform sampler2D map;\n#endif\n",
    // File:src/renderers/shaders/ShaderChunk/metalnessmap_fragment.glsl
    THREE.ShaderChunk.metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.r;\n#endif\n",
    // File:src/renderers/shaders/ShaderChunk/metalnessmap_pars_fragment.glsl
    THREE.ShaderChunk.metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif",
    // File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl
    THREE.ShaderChunk.morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n",
    // File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl
    THREE.ShaderChunk.morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	#ifndef USE_MORPHNORMALS\n	uniform float morphTargetInfluences[ 8 ];\n	#else\n	uniform float morphTargetInfluences[ 4 ];\n	#endif\n#endif",
    // File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl
    THREE.ShaderChunk.morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n	#ifndef USE_MORPHNORMALS\n	transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n	#endif\n#endif\n",
    // File:src/renderers/shaders/ShaderChunk/normal_fragment.glsl
    THREE.ShaderChunk.normal_fragment = "#ifdef FLAT_SHADED\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n	#endif\n#endif\n#ifdef USE_NORMALMAP\n	normal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n",
    // File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl
    THREE.ShaderChunk.normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n		vec3 N = normalize( surf_norm );\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = normalScale * mapN.xy;\n		mat3 tsn = mat3( S, T, N );\n		return normalize( tsn * mapN );\n	}\n#endif\n",
    // File:src/renderers/shaders/ShaderChunk/project_vertex.glsl
    THREE.ShaderChunk.project_vertex = "#ifdef USE_SKINNING\n	vec4 mvPosition = modelViewMatrix * skinned;\n#else\n	vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n",
    // File:src/renderers/shaders/ShaderChunk/roughnessmap_fragment.glsl
    THREE.ShaderChunk.roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.r;\n#endif\n",
    // File:src/renderers/shaders/ShaderChunk/roughnessmap_pars_fragment.glsl
    THREE.ShaderChunk.roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif",
    // File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl
    THREE.ShaderChunk.shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n	#endif\n	float unpackDepth( const in vec4 rgba_depth ) {\n		const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n		return dot( rgba_depth, bit_shift );\n	}\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackDepth( texture2D( depths, uv ) ) );\n	}\n	float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n		const vec2 offset = vec2( 0.0, 1.0 );\n		vec2 texelSize = vec2( 1.0 ) / size;\n		vec2 centroidUV = floor( uv * size + 0.5 ) / size;\n		float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n		float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n		float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n		float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n		vec2 f = fract( uv * size + 0.5 );\n		float a = mix( lb, lt, f.y );\n		float b = mix( rb, rt, f.y );\n		float c = mix( a, b, f.x );\n		return c;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			return (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			return (\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return 1.0;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n		vec3 lightToPosition = shadowCoord.xyz;\n		vec3 bd3D = normalize( lightToPosition );\n		float dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec3 offset = vec3( - 1, 0, 1 ) * shadowRadius * 2.0 * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.zzz, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.zxz, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxz, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xzz, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.zzx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.zxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xzx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.zzy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.zxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xzy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.zyz, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyz, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.zyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yzz, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxz, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yzx, texelSize.y ), dp )\n			) * ( 1.0 / 21.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif\n",
    // File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl
    THREE.ShaderChunk.shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n	#endif\n#endif\n",
    // File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl
    THREE.ShaderChunk.shadowmap_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n#endif\n",
    // File:src/renderers/shaders/ShaderChunk/shadowmask_pars_fragment.glsl
    THREE.ShaderChunk.shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n	DirectionalLight directionalLight;\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		shadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n	SpotLight spotLight;\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		shadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n	PointLight pointLight;\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		shadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#endif\n	return shadow;\n}\n",
    // File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl
    THREE.ShaderChunk.skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
    // File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl
    THREE.ShaderChunk.skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform sampler2D boneTexture;\n		uniform int boneTextureWidth;\n		uniform int boneTextureHeight;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureWidth ) );\n			float y = floor( j / float( boneTextureWidth ) );\n			float dx = 1.0 / float( boneTextureWidth );\n			float dy = 1.0 / float( boneTextureHeight );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneGlobalMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif\n",
    // File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl
    THREE.ShaderChunk.skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	skinned  = bindMatrixInverse * skinned;\n#endif\n",
    // File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl
    THREE.ShaderChunk.skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n",
    // File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl
    THREE.ShaderChunk.specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif",
    // File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl
    THREE.ShaderChunk.specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif",
    // File:src/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl
    THREE.ShaderChunk.uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif",
    // File:src/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl
    THREE.ShaderChunk.uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n#endif",
    // File:src/renderers/shaders/ShaderChunk/uv2_vertex.glsl
    THREE.ShaderChunk.uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = uv2;\n#endif",
    // File:src/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl
    THREE.ShaderChunk.uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	varying vec2 vUv;\n#endif",
    // File:src/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl
    THREE.ShaderChunk.uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	varying vec2 vUv;\n	uniform vec4 offsetRepeat;\n#endif\n",
    // File:src/renderers/shaders/ShaderChunk/uv_vertex.glsl
    THREE.ShaderChunk.uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif",
    // File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl
    THREE.ShaderChunk.worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( STANDARD ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n	#ifdef USE_SKINNING\n		vec4 worldPosition = modelMatrix * skinned;\n	#else\n		vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n	#endif\n#endif\n",
    // File:src/renderers/shaders/UniformsUtils.js
    /**
     * Uniform Utilities
     */
    THREE.UniformsUtils = {
        merge: function(a) {
            for (var b = {}, c = 0; c < a.length; c++) {
                var d = this.clone(a[c]);
                for (var e in d) b[e] = d[e]
            }
            return b
        },
        clone: function(a) {
            var b = {};
            for (var c in a) {
                b[c] = {};
                for (var d in a[c]) {
                    var e = a[c][d];
                    e instanceof THREE.Color || e instanceof THREE.Vector2 || e instanceof THREE.Vector3 || e instanceof THREE.Vector4 || e instanceof THREE.Matrix3 || e instanceof THREE.Matrix4 || e instanceof THREE.Texture ? b[c][d] = e.clone() : Array.isArray(e) ? b[c][d] = e.slice() : b[c][d] = e
                }
            }
            return b
        }
    },
    // File:src/renderers/shaders/UniformsLib.js
    /**
     * Uniforms library for shared webgl shaders
     */
    THREE.UniformsLib = {
        common: {
            diffuse: {
                type: "c",
                value: new THREE.Color(15658734)
            },
            opacity: {
                type: "f",
                value: 1
            },
            map: {
                type: "t",
                value: null
            },
            offsetRepeat: {
                type: "v4",
                value: new THREE.Vector4(0, 0, 1, 1)
            },
            specularMap: {
                type: "t",
                value: null
            },
            alphaMap: {
                type: "t",
                value: null
            },
            envMap: {
                type: "t",
                value: null
            },
            flipEnvMap: {
                type: "f",
                value: -1
            },
            reflectivity: {
                type: "f",
                value: 1
            },
            refractionRatio: {
                type: "f",
                value: .98
            }
        },
        aomap: {
            aoMap: {
                type: "t",
                value: null
            },
            aoMapIntensity: {
                type: "f",
                value: 1
            }
        },
        lightmap: {
            lightMap: {
                type: "t",
                value: null
            },
            lightMapIntensity: {
                type: "f",
                value: 1
            }
        },
        emissivemap: {
            emissiveMap: {
                type: "t",
                value: null
            }
        },
        bumpmap: {
            bumpMap: {
                type: "t",
                value: null
            },
            bumpScale: {
                type: "f",
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                type: "t",
                value: null
            },
            normalScale: {
                type: "v2",
                value: new THREE.Vector2(1, 1)
            }
        },
        displacementmap: {
            displacementMap: {
                type: "t",
                value: null
            },
            displacementScale: {
                type: "f",
                value: 1
            },
            displacementBias: {
                type: "f",
                value: 0
            }
        },
        roughnessmap: {
            roughnessMap: {
                type: "t",
                value: null
            }
        },
        metalnessmap: {
            metalnessMap: {
                type: "t",
                value: null
            }
        },
        fog: {
            fogDensity: {
                type: "f",
                value: 25e-5
            },
            fogNear: {
                type: "f",
                value: 1
            },
            fogFar: {
                type: "f",
                value: 2e3
            },
            fogColor: {
                type: "c",
                value: new THREE.Color(16777215)
            }
        },
        ambient: {
            ambientLightColor: {
                type: "fv",
                value: []
            }
        },
        lights: {
            directionalLights: {
                type: "sa",
                value: [],
                properties: {
                    direction: {
                        type: "v3"
                    },
                    color: {
                        type: "c"
                    },
                    shadow: {
                        type: "i"
                    },
                    shadowBias: {
                        type: "f"
                    },
                    shadowRadius: {
                        type: "f"
                    },
                    shadowMapSize: {
                        type: "v2"
                    }
                }
            },
            directionalShadowMap: {
                type: "tv",
                value: []
            },
            directionalShadowMatrix: {
                type: "m4v",
                value: []
            },
            spotLights: {
                type: "sa",
                value: [],
                properties: {
                    color: {
                        type: "c"
                    },
                    position: {
                        type: "v3"
                    },
                    direction: {
                        type: "v3"
                    },
                    distance: {
                        type: "f"
                    },
                    angleCos: {
                        type: "f"
                    },
                    exponent: {
                        type: "f"
                    },
                    decay: {
                        type: "f"
                    },
                    shadow: {
                        type: "i"
                    },
                    shadowBias: {
                        type: "f"
                    },
                    shadowRadius: {
                        type: "f"
                    },
                    shadowMapSize: {
                        type: "v2"
                    }
                }
            },
            spotShadowMap: {
                type: "tv",
                value: []
            },
            spotShadowMatrix: {
                type: "m4v",
                value: []
            },
            pointLights: {
                type: "sa",
                value: [],
                properties: {
                    color: {
                        type: "c"
                    },
                    position: {
                        type: "v3"
                    },
                    decay: {
                        type: "f"
                    },
                    distance: {
                        type: "f"
                    },
                    shadow: {
                        type: "i"
                    },
                    shadowBias: {
                        type: "f"
                    },
                    shadowRadius: {
                        type: "f"
                    },
                    shadowMapSize: {
                        type: "v2"
                    }
                }
            },
            pointShadowMap: {
                type: "tv",
                value: []
            },
            pointShadowMatrix: {
                type: "m4v",
                value: []
            },
            hemisphereLights: {
                type: "sa",
                value: [],
                properties: {
                    direction: {
                        type: "v3"
                    },
                    skyColor: {
                        type: "c"
                    },
                    groundColor: {
                        type: "c"
                    }
                }
            }
        },
        points: {
            diffuse: {
                type: "c",
                value: new THREE.Color(15658734)
            },
            opacity: {
                type: "f",
                value: 1
            },
            size: {
                type: "f",
                value: 1
            },
            scale: {
                type: "f",
                value: 1
            },
            map: {
                type: "t",
                value: null
            },
            offsetRepeat: {
                type: "v4",
                value: new THREE.Vector4(0, 0, 1, 1)
            }
        }
    },
    // File:src/renderers/shaders/ShaderLib.js
    /**
     * Webgl Shader Library for three.js
     *
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     * @author mikael emtinger / http://gomo.se/
     */
    THREE.ShaderLib = {
        basic: {
            uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.aomap, THREE.UniformsLib.fog]),
            vertexShader: [THREE.ShaderChunk.common, THREE.ShaderChunk.uv_pars_vertex, THREE.ShaderChunk.uv2_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.uv_vertex, THREE.ShaderChunk.uv2_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.skinbase_vertex, "	#ifdef USE_ENVMAP", THREE.ShaderChunk.beginnormal_vertex, THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, "	#endif", THREE.ShaderChunk.begin_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.project_vertex, THREE.ShaderChunk.logdepthbuf_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
            fragmentShader: ["uniform vec3 diffuse;", "uniform float opacity;", "#ifndef FLAT_SHADED", "	varying vec3 vNormal;", "#endif", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.uv_pars_fragment, THREE.ShaderChunk.uv2_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.alphamap_pars_fragment, THREE.ShaderChunk.aomap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", "	vec4 diffuseColor = vec4( diffuse, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.alphamap_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, "	ReflectedLight reflectedLight;", "	reflectedLight.directDiffuse = vec3( 0.0 );", "	reflectedLight.directSpecular = vec3( 0.0 );", "	reflectedLight.indirectDiffuse = diffuseColor.rgb;", "	reflectedLight.indirectSpecular = vec3( 0.0 );", THREE.ShaderChunk.aomap_fragment, "	vec3 outgoingLight = reflectedLight.indirectDiffuse;", THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"].join("\n")
        },
        lambert: {
            uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.aomap, THREE.UniformsLib.lightmap, THREE.UniformsLib.emissivemap, THREE.UniformsLib.fog, THREE.UniformsLib.ambient, THREE.UniformsLib.lights, {
                emissive: {
                    type: "c",
                    value: new THREE.Color(0)
                }
            }]),
            vertexShader: ["#define LAMBERT", "varying vec3 vLightFront;", "#ifdef DOUBLE_SIDED", "	varying vec3 vLightBack;", "#endif", THREE.ShaderChunk.common, THREE.ShaderChunk.uv_pars_vertex, THREE.ShaderChunk.uv2_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.bsdfs, THREE.ShaderChunk.lights_pars, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.uv_vertex, THREE.ShaderChunk.uv2_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.beginnormal_vertex, THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, THREE.ShaderChunk.begin_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.project_vertex, THREE.ShaderChunk.logdepthbuf_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.lights_lambert_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
            fragmentShader: ["uniform vec3 diffuse;", "uniform vec3 emissive;", "uniform float opacity;", "varying vec3 vLightFront;", "#ifdef DOUBLE_SIDED", "	varying vec3 vLightBack;", "#endif", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.uv_pars_fragment, THREE.ShaderChunk.uv2_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.alphamap_pars_fragment, THREE.ShaderChunk.aomap_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.emissivemap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.bsdfs, THREE.ShaderChunk.ambient_pars, THREE.ShaderChunk.lights_pars, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.shadowmask_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", "	vec4 diffuseColor = vec4( diffuse, opacity );", "	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );", "	vec3 totalEmissiveLight = emissive;", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.alphamap_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, THREE.ShaderChunk.emissivemap_fragment,
                // accumulation
                "	reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );", THREE.ShaderChunk.lightmap_fragment, "	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );", "	#ifdef DOUBLE_SIDED", "		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;", "	#else", "		reflectedLight.directDiffuse = vLightFront;", "	#endif", "	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();",
                // modulation
                THREE.ShaderChunk.aomap_fragment, "	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveLight;", THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"
            ].join("\n")
        },
        phong: {
            uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.aomap, THREE.UniformsLib.lightmap, THREE.UniformsLib.emissivemap, THREE.UniformsLib.bumpmap, THREE.UniformsLib.normalmap, THREE.UniformsLib.displacementmap, THREE.UniformsLib.fog, THREE.UniformsLib.ambient, THREE.UniformsLib.lights, {
                emissive: {
                    type: "c",
                    value: new THREE.Color(0)
                },
                specular: {
                    type: "c",
                    value: new THREE.Color(1118481)
                },
                shininess: {
                    type: "f",
                    value: 30
                }
            }]),
            vertexShader: ["#define PHONG", "varying vec3 vViewPosition;", "#ifndef FLAT_SHADED", "	varying vec3 vNormal;", "#endif", THREE.ShaderChunk.common, THREE.ShaderChunk.uv_pars_vertex, THREE.ShaderChunk.uv2_pars_vertex, THREE.ShaderChunk.displacementmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.lights_phong_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.uv_vertex, THREE.ShaderChunk.uv2_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.beginnormal_vertex, THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, "#ifndef FLAT_SHADED", // Normal computed with derivatives when FLAT_SHADED
                "	vNormal = normalize( transformedNormal );", "#endif", THREE.ShaderChunk.begin_vertex, THREE.ShaderChunk.displacementmap_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.project_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "	vViewPosition = - mvPosition.xyz;", THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.lights_phong_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"
            ].join("\n"),
            fragmentShader: ["#define PHONG", "uniform vec3 diffuse;", "uniform vec3 emissive;", "uniform vec3 specular;", "uniform float shininess;", "uniform float opacity;", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.uv_pars_fragment, THREE.ShaderChunk.uv2_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.alphamap_pars_fragment, THREE.ShaderChunk.aomap_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.emissivemap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.bsdfs, THREE.ShaderChunk.ambient_pars, THREE.ShaderChunk.lights_pars, THREE.ShaderChunk.lights_phong_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.bumpmap_pars_fragment, THREE.ShaderChunk.normalmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", "	vec4 diffuseColor = vec4( diffuse, opacity );", "	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );", "	vec3 totalEmissiveLight = emissive;", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.alphamap_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, THREE.ShaderChunk.normal_fragment, THREE.ShaderChunk.emissivemap_fragment,
                // accumulation
                THREE.ShaderChunk.lights_phong_fragment, THREE.ShaderChunk.lights_template,
                // modulation
                THREE.ShaderChunk.aomap_fragment, "vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveLight;", THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"
            ].join("\n")
        },
        standard: {
            uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.aomap, THREE.UniformsLib.lightmap, THREE.UniformsLib.emissivemap, THREE.UniformsLib.bumpmap, THREE.UniformsLib.normalmap, THREE.UniformsLib.displacementmap, THREE.UniformsLib.roughnessmap, THREE.UniformsLib.metalnessmap, THREE.UniformsLib.fog, THREE.UniformsLib.ambient, THREE.UniformsLib.lights, {
                emissive: {
                    type: "c",
                    value: new THREE.Color(0)
                },
                roughness: {
                    type: "f",
                    value: .5
                },
                metalness: {
                    type: "f",
                    value: 0
                },
                envMapIntensity: {
                    type: "f",
                    value: 1
                }
            }]),
            vertexShader: ["#define STANDARD", "varying vec3 vViewPosition;", "#ifndef FLAT_SHADED", "	varying vec3 vNormal;", "#endif", THREE.ShaderChunk.common, THREE.ShaderChunk.uv_pars_vertex, THREE.ShaderChunk.uv2_pars_vertex, THREE.ShaderChunk.displacementmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.specularmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", // STANDARD
                THREE.ShaderChunk.uv_vertex, THREE.ShaderChunk.uv2_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.beginnormal_vertex, THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, "#ifndef FLAT_SHADED", // Normal computed with derivatives when FLAT_SHADED
                "	vNormal = normalize( transformedNormal );", "#endif", THREE.ShaderChunk.begin_vertex, THREE.ShaderChunk.displacementmap_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.project_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "	vViewPosition = - mvPosition.xyz;", THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"
            ].join("\n"),
            fragmentShader: ["#define STANDARD", "uniform vec3 diffuse;", "uniform vec3 emissive;", "uniform float roughness;", "uniform float metalness;", "uniform float opacity;", "uniform float envMapIntensity;", // temporary
                "varying vec3 vViewPosition;", "#ifndef FLAT_SHADED", "	varying vec3 vNormal;", "#endif", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.uv_pars_fragment, THREE.ShaderChunk.uv2_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.alphamap_pars_fragment, THREE.ShaderChunk.aomap_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.emissivemap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.bsdfs, THREE.ShaderChunk.ambient_pars, THREE.ShaderChunk.lights_pars, THREE.ShaderChunk.lights_standard_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.bumpmap_pars_fragment, THREE.ShaderChunk.normalmap_pars_fragment, THREE.ShaderChunk.roughnessmap_pars_fragment, THREE.ShaderChunk.metalnessmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", "	vec4 diffuseColor = vec4( diffuse, opacity );", "	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );", "	vec3 totalEmissiveLight = emissive;", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.alphamap_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, THREE.ShaderChunk.roughnessmap_fragment, THREE.ShaderChunk.metalnessmap_fragment, THREE.ShaderChunk.normal_fragment, THREE.ShaderChunk.emissivemap_fragment,
                // accumulation
                THREE.ShaderChunk.lights_standard_fragment, THREE.ShaderChunk.lights_template,
                // modulation
                THREE.ShaderChunk.aomap_fragment, "vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveLight;", THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"
            ].join("\n")
        },
        points: {
            uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.points, THREE.UniformsLib.fog]),
            vertexShader: ["uniform float size;", "uniform float scale;", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.begin_vertex, THREE.ShaderChunk.project_vertex, "	#ifdef USE_SIZEATTENUATION", "		gl_PointSize = size * ( scale / - mvPosition.z );", "	#else", "		gl_PointSize = size;", "	#endif", THREE.ShaderChunk.logdepthbuf_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
            fragmentShader: ["uniform vec3 diffuse;", "uniform float opacity;", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_particle_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", "	vec3 outgoingLight = vec3( 0.0 );", "	vec4 diffuseColor = vec4( diffuse, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_particle_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.alphatest_fragment, "	outgoingLight = diffuseColor.rgb;", THREE.ShaderChunk.fog_fragment, "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"].join("\n")
        },
        dashed: {
            uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, {
                scale: {
                    type: "f",
                    value: 1
                },
                dashSize: {
                    type: "f",
                    value: 1
                },
                totalSize: {
                    type: "f",
                    value: 2
                }
            }]),
            vertexShader: ["uniform float scale;", "attribute float lineDistance;", "varying float vLineDistance;", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.color_vertex, "	vLineDistance = scale * lineDistance;", "	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "	gl_Position = projectionMatrix * mvPosition;", THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
            fragmentShader: ["uniform vec3 diffuse;", "uniform float opacity;", "uniform float dashSize;", "uniform float totalSize;", "varying float vLineDistance;", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", "	if ( mod( vLineDistance, totalSize ) > dashSize ) {", "		discard;", "	}", "	vec3 outgoingLight = vec3( 0.0 );", "	vec4 diffuseColor = vec4( diffuse, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.color_fragment, "	outgoingLight = diffuseColor.rgb;", // simple shader
                THREE.ShaderChunk.fog_fragment, "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"
            ].join("\n")
        },
        depth: {
            uniforms: {
                mNear: {
                    type: "f",
                    value: 1
                },
                mFar: {
                    type: "f",
                    value: 2e3
                },
                opacity: {
                    type: "f",
                    value: 1
                }
            },
            vertexShader: [THREE.ShaderChunk.common, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.begin_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.project_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
            fragmentShader: ["uniform float mNear;", "uniform float mFar;", "uniform float opacity;", THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", THREE.ShaderChunk.logdepthbuf_fragment, "	#ifdef USE_LOGDEPTHBUF_EXT", "		float depth = gl_FragDepthEXT / gl_FragCoord.w;", "	#else", "		float depth = gl_FragCoord.z / gl_FragCoord.w;", "	#endif", "	float color = 1.0 - smoothstep( mNear, mFar, depth );", "	gl_FragColor = vec4( vec3( color ), opacity );", "}"].join("\n")
        },
        normal: {
            uniforms: {
                opacity: {
                    type: "f",
                    value: 1
                }
            },
            vertexShader: ["varying vec3 vNormal;", THREE.ShaderChunk.common, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", "	vNormal = normalize( normalMatrix * normal );", THREE.ShaderChunk.begin_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.project_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
            fragmentShader: ["uniform float opacity;", "varying vec3 vNormal;", THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", "	gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, "}"].join("\n")
        },
        /* -------------------------------------------------------------------------
        	 //	Cube map shader
        	 ------------------------------------------------------------------------- */
        cube: {
            uniforms: {
                tCube: {
                    type: "t",
                    value: null
                },
                tFlip: {
                    type: "f",
                    value: -1
                }
            },
            vertexShader: ["varying vec3 vWorldPosition;", THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", "	vWorldPosition = transformDirection( position, modelMatrix );", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
            fragmentShader: ["uniform samplerCube tCube;", "uniform float tFlip;", "varying vec3 vWorldPosition;", THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", "	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );", THREE.ShaderChunk.logdepthbuf_fragment, "}"].join("\n")
        },
        /* -------------------------------------------------------------------------
        	 //	Cube map shader
        	 ------------------------------------------------------------------------- */
        equirect: {
            uniforms: {
                tEquirect: {
                    type: "t",
                    value: null
                },
                tFlip: {
                    type: "f",
                    value: -1
                }
            },
            vertexShader: ["varying vec3 vWorldPosition;", THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", "	vWorldPosition = transformDirection( position, modelMatrix );", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
            fragmentShader: ["uniform sampler2D tEquirect;", "uniform float tFlip;", "varying vec3 vWorldPosition;", THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {",
                // "	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",
                "vec3 direction = normalize( vWorldPosition );", "vec2 sampleUV;", "sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );", "sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;", "gl_FragColor = texture2D( tEquirect, sampleUV );", THREE.ShaderChunk.logdepthbuf_fragment, "}"
            ].join("\n")
        },
        /* Depth encoding into RGBA texture
         *
         * based on SpiderGL shadow map example
         * http://spidergl.org/example.php?id=6
         *
         * originally from
         * http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD
         *
         * see also
         * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/
         */
        depthRGBA: {
            uniforms: {},
            vertexShader: [THREE.ShaderChunk.common, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.begin_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.project_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
            fragmentShader: [THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_fragment, "vec4 pack_depth( const in float depth ) {", "	const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );", "	const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );", "	vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );", "	res -= res.xxyz * bit_mask;", "	return res;", "}", "void main() {", THREE.ShaderChunk.logdepthbuf_fragment, "	#ifdef USE_LOGDEPTHBUF_EXT", "		gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );", "	#else", "		gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );", "	#endif",
                //"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );",
                //"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );",
                //"gl_FragData[ 0 ] = pack_depth( z );",
                //"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );",
                "}"
            ].join("\n")
        },
        distanceRGBA: {
            uniforms: {
                lightPos: {
                    type: "v3",
                    value: new THREE.Vector3(0, 0, 0)
                }
            },
            vertexShader: ["varying vec4 vWorldPosition;", THREE.ShaderChunk.common, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, "void main() {", THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.begin_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.project_vertex, THREE.ShaderChunk.worldpos_vertex, "vWorldPosition = worldPosition;", "}"].join("\n"),
            fragmentShader: ["uniform vec3 lightPos;", "varying vec4 vWorldPosition;", THREE.ShaderChunk.common, "vec4 pack1K ( float depth ) {", "	depth /= 1000.0;", "	const vec4 bitSh = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );", "	const vec4 bitMsk = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );", "	vec4 res = mod( depth * bitSh * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );", "	res -= res.xxyz * bitMsk;", "	return res; ", "}", "float unpack1K ( vec4 color ) {", "	const vec4 bitSh = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );", "	return dot( color, bitSh ) * 1000.0;", "}", "void main () {", "	gl_FragColor = pack1K( length( vWorldPosition.xyz - lightPos.xyz ) );", "}"].join("\n")
        }
    },
    // File:src/renderers/WebGLRenderer.js
    /**
     * @author supereggbert / http://www.paulbrunt.co.uk/
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     * @author szimek / https://github.com/szimek/
     */
    THREE.WebGLRenderer = function(a) {
        //
        function b() {
            return null === ra ? Ea : 1
        }

        function c(a, b, c, d) {
            fa === !0 && (a *= d, b *= d, c *= d), Ta.clearColor(a, b, c, d)
        }

        function d() {
            Ta.init(), Ta.scissor(wa.copy(Fa).multiplyScalar(Ea)), Ta.viewport(ya.copy(Ha).multiplyScalar(Ea)), c(Aa.r, Aa.g, Aa.b, Ba)
        }

        function e() {
            qa = null, va = null, ua = "", ta = -1, Ta.reset()
        }
        // Events
        function f(a) {
            a.preventDefault(), e(), d(), Ua.clear()
        }

        function g(a) {
            var b = a.target;
            b.removeEventListener("dispose", g), j(b), Ma.textures--
        }

        function h(a) {
            var b = a.target;
            b.removeEventListener("dispose", h), k(b), Ma.textures--
        }

        function i(a) {
            var b = a.target;
            b.removeEventListener("dispose", i), l(b)
        }
        // Buffer deallocation
        function j(a) {
            var b = Ua.get(a);
            if (a.image && b.__image__webglTextureCube)
            // cube texture
                Oa.deleteTexture(b.__image__webglTextureCube);
            else {
                // 2D texture
                if (void 0 === b.__webglInit) return;
                Oa.deleteTexture(b.__webglTexture)
            }
            // remove all webgl properties
            Ua["delete"](a)
        }

        function k(a) {
            var b = Ua.get(a),
                c = Ua.get(a.texture);
            if (a && void 0 !== c.__webglTexture) {
                if (Oa.deleteTexture(c.__webglTexture), a instanceof THREE.WebGLRenderTargetCube)
                    for (var d = 0; 6 > d; d++) Oa.deleteFramebuffer(b.__webglFramebuffer[d]), Oa.deleteRenderbuffer(b.__webglDepthbuffer[d]);
                else Oa.deleteFramebuffer(b.__webglFramebuffer), Oa.deleteRenderbuffer(b.__webglDepthbuffer);
                Ua["delete"](a.texture), Ua["delete"](a)
            }
        }

        function l(a) {
            m(a), Ua["delete"](a)
        }

        function m(a) {
            var b = Ua.get(a).program;
            a.program = void 0, void 0 !== b && Wa.releaseProgram(b)
        }

        function n(a, b, c, d) {
            var e;
            if (c instanceof THREE.InstancedBufferGeometry && (e = Ra.get("ANGLE_instanced_arrays"), null === e)) return void console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            void 0 === d && (d = 0), Ta.initAttributes();
            var f = c.attributes,
                g = b.getAttributes(),
                h = a.defaultAttributeValues;
            for (var i in g) {
                var j = g[i];
                if (j >= 0) {
                    var k = f[i];
                    if (void 0 !== k) {
                        var l = k.itemSize,
                            m = Va.getAttributeBuffer(k);
                        if (k instanceof THREE.InterleavedBufferAttribute) {
                            var n = k.data,
                                o = n.stride,
                                p = k.offset;
                            n instanceof THREE.InstancedInterleavedBuffer ? (Ta.enableAttributeAndDivisor(j, n.meshPerAttribute, e), void 0 === c.maxInstancedCount && (c.maxInstancedCount = n.meshPerAttribute * n.count)) : Ta.enableAttribute(j), Oa.bindBuffer(Oa.ARRAY_BUFFER, m), Oa.vertexAttribPointer(j, l, Oa.FLOAT, !1, o * n.array.BYTES_PER_ELEMENT, (d * o + p) * n.array.BYTES_PER_ELEMENT)
                        } else k instanceof THREE.InstancedBufferAttribute ? (Ta.enableAttributeAndDivisor(j, k.meshPerAttribute, e), void 0 === c.maxInstancedCount && (c.maxInstancedCount = k.meshPerAttribute * k.count)) : Ta.enableAttribute(j), Oa.bindBuffer(Oa.ARRAY_BUFFER, m), Oa.vertexAttribPointer(j, l, Oa.FLOAT, !1, 0, d * l * 4)
                    } else if (void 0 !== h) {
                        var q = h[i];
                        if (void 0 !== q) switch (q.length) {
                            case 2:
                                Oa.vertexAttrib2fv(j, q);
                                break;
                            case 3:
                                Oa.vertexAttrib3fv(j, q);
                                break;
                            case 4:
                                Oa.vertexAttrib4fv(j, q);
                                break;
                            default:
                                Oa.vertexAttrib1fv(j, q)
                        }
                    }
                }
            }
            Ta.disableUnusedAttributes()
        }
        // Sorting
        function o(a, b) {
            return Math.abs(b[0]) - Math.abs(a[0])
        }

        function p(a, b) {
            return a.object.renderOrder !== b.object.renderOrder ? a.object.renderOrder - b.object.renderOrder : a.material.id !== b.material.id ? a.material.id - b.material.id : a.z !== b.z ? a.z - b.z : a.id - b.id
        }

        function q(a, b) {
            return a.object.renderOrder !== b.object.renderOrder ? a.object.renderOrder - b.object.renderOrder : a.z !== b.z ? b.z - a.z : a.id - b.id
        }

        function r(a, b, c, d, e) {
            var f, g;
            // allocate the next position in the appropriate array
            c.transparent ? (f = ka, g = ++la) : (f = ia, g = ++ja);
            // recycle existing render item or grow the array
            var h = f[g];
            void 0 !== h ? (h.id = a.id, h.object = a, h.geometry = b, h.material = c, h.z = Ka.z, h.group = e) : (h = {
                id: a.id,
                object: a,
                geometry: b,
                material: c,
                z: Ka.z,
                group: e
            }, f.push(h))
        }

        function s(a, b) {
            if (a.visible !== !1) {
                if (a.layers.test(b.layers))
                    if (a instanceof THREE.Light) ha.push(a);
                    else if (a instanceof THREE.Sprite) a.frustumCulled !== !1 && Ia.intersectsObject(a) !== !0 || na.push(a);
                else if (a instanceof THREE.LensFlare) oa.push(a);
                else if (a instanceof THREE.ImmediateRenderObject) pa.sortObjects === !0 && (Ka.setFromMatrixPosition(a.matrixWorld), Ka.applyProjection(Ja)), r(a, null, a.material, Ka.z, null);
                else if ((a instanceof THREE.Mesh || a instanceof THREE.Line || a instanceof THREE.Points) && (a instanceof THREE.SkinnedMesh && a.skeleton.update(), a.frustumCulled === !1 || Ia.intersectsObject(a) === !0)) {
                    var c = a.material;
                    if (c.visible === !0) {
                        pa.sortObjects === !0 && (Ka.setFromMatrixPosition(a.matrixWorld), Ka.applyProjection(Ja));
                        var d = Va.update(a);
                        if (c instanceof THREE.MultiMaterial)
                            for (var e = d.groups, f = c.materials, g = 0, h = e.length; h > g; g++) {
                                var i = e[g],
                                    j = f[i.materialIndex];
                                j.visible === !0 && r(a, d, j, Ka.z, i)
                            } else r(a, d, c, Ka.z, null)
                    }
                }
                for (var k = a.children, g = 0, h = k.length; h > g; g++) s(k[g], b)
            }
        }

        function t(a, b, c, d) {
            for (var e = 0, f = a.length; f > e; e++) {
                var g = a[e],
                    h = g.object,
                    i = g.geometry,
                    j = void 0 === d ? g.material : d,
                    k = g.group;
                if (h.modelViewMatrix.multiplyMatrices(b.matrixWorldInverse, h.matrixWorld), h.normalMatrix.getNormalMatrix(h.modelViewMatrix), h instanceof THREE.ImmediateRenderObject) {
                    v(j);
                    var l = x(b, c, j, h);
                    ua = "", h.render(function(a) {
                        pa.renderBufferImmediate(a, l, j)
                    })
                } else pa.renderBufferDirect(b, c, i, j, h, k)
            }
        }

        function u(a, b, c) {
            var d = Ua.get(a),
                e = Wa.getParameters(a, La, b, c),
                f = Wa.getProgramCode(a, e),
                g = d.program,
                h = !0;
            if (void 0 === g)
            // new material
                a.addEventListener("dispose", i);
            else if (g.code !== f)
            // changed glsl or parameters
                m(a);
            else {
                if (void 0 !== e.shaderID)
                // same glsl and uniform list
                    return;
                // only rebuild uniform list
                h = !1
            }
            if (h) {
                if (e.shaderID) {
                    var j = THREE.ShaderLib[e.shaderID];
                    d.__webglShader = {
                        name: a.type,
                        uniforms: THREE.UniformsUtils.clone(j.uniforms),
                        vertexShader: j.vertexShader,
                        fragmentShader: j.fragmentShader
                    }
                } else d.__webglShader = {
                    name: a.type,
                    uniforms: a.uniforms,
                    vertexShader: a.vertexShader,
                    fragmentShader: a.fragmentShader
                };
                a.__webglShader = d.__webglShader, g = Wa.acquireProgram(a, e, f), d.program = g, a.program = g
            }
            var k = g.getAttributes();
            if (a.morphTargets) {
                a.numSupportedMorphTargets = 0;
                for (var l = 0; l < pa.maxMorphTargets; l++) k["morphTarget" + l] >= 0 && a.numSupportedMorphTargets++
            }
            if (a.morphNormals) {
                a.numSupportedMorphNormals = 0;
                for (var l = 0; l < pa.maxMorphNormals; l++) k["morphNormal" + l] >= 0 && a.numSupportedMorphNormals++
            }
            d.uniformsList = [];
            var n = d.__webglShader.uniforms,
                o = d.program.getUniforms();
            for (var p in n) {
                var q = o[p];
                q && d.uniformsList.push([d.__webglShader.uniforms[p], q])
            }(a instanceof THREE.MeshPhongMaterial || a instanceof THREE.MeshLambertMaterial || a instanceof THREE.MeshStandardMaterial || a.lights) && (
                // store the light setup it was created for
                d.lightsHash = La.hash,
                // wire up the material to this renderer's lighting state
                n.ambientLightColor.value = La.ambient, n.directionalLights.value = La.directional, n.spotLights.value = La.spot, n.pointLights.value = La.point, n.hemisphereLights.value = La.hemi, n.directionalShadowMap.value = La.directionalShadowMap, n.directionalShadowMatrix.value = La.directionalShadowMatrix, n.spotShadowMap.value = La.spotShadowMap, n.spotShadowMatrix.value = La.spotShadowMatrix, n.pointShadowMap.value = La.pointShadowMap, n.pointShadowMatrix.value = La.pointShadowMatrix),
            // detect dynamic uniforms
            d.hasDynamicUniforms = !1;
            for (var r = 0, s = d.uniformsList.length; s > r; r++) {
                var t = d.uniformsList[r][0];
                if (t.dynamic === !0) {
                    d.hasDynamicUniforms = !0;
                    break
                }
            }
        }

        function v(a) {
            w(a), a.transparent === !0 ? Ta.setBlending(a.blending, a.blendEquation, a.blendSrc, a.blendDst, a.blendEquationAlpha, a.blendSrcAlpha, a.blendDstAlpha) : Ta.setBlending(THREE.NoBlending), Ta.setDepthFunc(a.depthFunc), Ta.setDepthTest(a.depthTest), Ta.setDepthWrite(a.depthWrite), Ta.setColorWrite(a.colorWrite), Ta.setPolygonOffset(a.polygonOffset, a.polygonOffsetFactor, a.polygonOffsetUnits)
        }

        function w(a) {
            a.side !== THREE.DoubleSide ? Ta.enable(Oa.CULL_FACE) : Ta.disable(Oa.CULL_FACE), Ta.setFlipSided(a.side === THREE.BackSide)
        }

        function x(a, b, c, d) {
            za = 0;
            var e = Ua.get(c);
            void 0 === e.program && (c.needsUpdate = !0), void 0 !== e.lightsHash && e.lightsHash !== La.hash && (c.needsUpdate = !0), c.needsUpdate && (u(c, b, d), c.needsUpdate = !1);
            var f = !1,
                g = !1,
                h = !1,
                i = e.program,
                j = i.getUniforms(),
                k = e.__webglShader.uniforms;
            // skinning uniforms must be set even if material didn't change
            // auto-setting of texture unit for bone texture must go before other textures
            // not sure why, but otherwise weird things happen
            if (i.id !== qa && (Oa.useProgram(i.program), qa = i.id, f = !0, g = !0, h = !0), c.id !== ta && (ta = c.id, g = !0), (f || a !== va) && (Oa.uniformMatrix4fv(j.projectionMatrix, !1, a.projectionMatrix.elements), Sa.logarithmicDepthBuffer && Oa.uniform1f(j.logDepthBufFC, 2 / (Math.log(a.far + 1) / Math.LN2)), a !== va && (va = a, g = !0, h = !0),
                    // load material specific uniforms
                    // (shader material also gets them for the sake of genericity)
                    (c instanceof THREE.ShaderMaterial || c instanceof THREE.MeshPhongMaterial || c instanceof THREE.MeshStandardMaterial || c.envMap) && void 0 !== j.cameraPosition && (Ka.setFromMatrixPosition(a.matrixWorld), Oa.uniform3f(j.cameraPosition, Ka.x, Ka.y, Ka.z)), (c instanceof THREE.MeshPhongMaterial || c instanceof THREE.MeshLambertMaterial || c instanceof THREE.MeshBasicMaterial || c instanceof THREE.MeshStandardMaterial || c instanceof THREE.ShaderMaterial || c.skinning) && void 0 !== j.viewMatrix && Oa.uniformMatrix4fv(j.viewMatrix, !1, a.matrixWorldInverse.elements)), c.skinning)
                if (d.bindMatrix && void 0 !== j.bindMatrix && Oa.uniformMatrix4fv(j.bindMatrix, !1, d.bindMatrix.elements), d.bindMatrixInverse && void 0 !== j.bindMatrixInverse && Oa.uniformMatrix4fv(j.bindMatrixInverse, !1, d.bindMatrixInverse.elements), Sa.floatVertexTextures && d.skeleton && d.skeleton.useVertexTexture) {
                    if (void 0 !== j.boneTexture) {
                        var l = J();
                        Oa.uniform1i(j.boneTexture, l), pa.setTexture(d.skeleton.boneTexture, l)
                    }
                    void 0 !== j.boneTextureWidth && Oa.uniform1i(j.boneTextureWidth, d.skeleton.boneTextureWidth), void 0 !== j.boneTextureHeight && Oa.uniform1i(j.boneTextureHeight, d.skeleton.boneTextureHeight)
                } else d.skeleton && d.skeleton.boneMatrices && void 0 !== j.boneGlobalMatrices && Oa.uniformMatrix4fv(j.boneGlobalMatrices, !1, d.skeleton.boneMatrices);
                // the current material requires lighting info
                // note: all lighting uniforms are always set correctly
                // they simply reference the renderer's state for their
                // values
                //
                // use the current material's .needsUpdate flags to set
                // the GL state when required
                // refresh uniforms common to several materials
                // refresh single material specific uniforms
                // load common uniforms
            return g && ((c instanceof THREE.MeshPhongMaterial || c instanceof THREE.MeshLambertMaterial || c instanceof THREE.MeshStandardMaterial || c.lights) && H(k, h), b && c.fog && D(k, b), (c instanceof THREE.MeshBasicMaterial || c instanceof THREE.MeshLambertMaterial || c instanceof THREE.MeshPhongMaterial || c instanceof THREE.MeshStandardMaterial) && z(k, c), c instanceof THREE.LineBasicMaterial ? A(k, c) : c instanceof THREE.LineDashedMaterial ? (A(k, c), B(k, c)) : c instanceof THREE.PointsMaterial ? C(k, c) : c instanceof THREE.MeshLambertMaterial ? E(k, c) : c instanceof THREE.MeshPhongMaterial ? F(k, c) : c instanceof THREE.MeshStandardMaterial ? G(k, c) : c instanceof THREE.MeshDepthMaterial ? (k.mNear.value = a.near, k.mFar.value = a.far, k.opacity.value = c.opacity) : c instanceof THREE.MeshNormalMaterial && (k.opacity.value = c.opacity), K(e.uniformsList)), I(j, d), void 0 !== j.modelMatrix && Oa.uniformMatrix4fv(j.modelMatrix, !1, d.matrixWorld.elements), e.hasDynamicUniforms === !0 && y(e.uniformsList, d, a), i
        }

        function y(a, b, c) {
            for (var d = [], e = 0, f = a.length; f > e; e++) {
                var g = a[e][0],
                    h = g.onUpdateCallback;
                void 0 !== h && (h.bind(g)(b, c), d.push(a[e]))
            }
            K(d)
        }
        // Uniforms (refresh uniforms objects)
        function z(a, b) {
            a.opacity.value = b.opacity, a.diffuse.value = b.color, b.emissive && a.emissive.value.copy(b.emissive).multiplyScalar(b.emissiveIntensity), a.map.value = b.map, a.specularMap.value = b.specularMap, a.alphaMap.value = b.alphaMap, b.aoMap && (a.aoMap.value = b.aoMap, a.aoMapIntensity.value = b.aoMapIntensity);
            // uv repeat and offset setting priorities
            // 1. color map
            // 2. specular map
            // 3. normal map
            // 4. bump map
            // 5. alpha map
            // 6. emissive map
            var c;
            if (b.map ? c = b.map : b.specularMap ? c = b.specularMap : b.displacementMap ? c = b.displacementMap : b.normalMap ? c = b.normalMap : b.bumpMap ? c = b.bumpMap : b.roughnessMap ? c = b.roughnessMap : b.metalnessMap ? c = b.metalnessMap : b.alphaMap ? c = b.alphaMap : b.emissiveMap && (c = b.emissiveMap), void 0 !== c) {
                c instanceof THREE.WebGLRenderTarget && (c = c.texture);
                var d = c.offset,
                    e = c.repeat;
                a.offsetRepeat.value.set(d.x, d.y, e.x, e.y)
            }
            a.envMap.value = b.envMap, a.flipEnvMap.value = b.envMap instanceof THREE.WebGLRenderTargetCube ? 1 : -1, a.reflectivity.value = b.reflectivity, a.refractionRatio.value = b.refractionRatio
        }

        function A(a, b) {
            a.diffuse.value = b.color, a.opacity.value = b.opacity
        }

        function B(a, b) {
            a.dashSize.value = b.dashSize, a.totalSize.value = b.dashSize + b.gapSize, a.scale.value = b.scale
        }

        function C(a, b) {
            if (a.diffuse.value = b.color, a.opacity.value = b.opacity, a.size.value = b.size * Ea, a.scale.value = _.clientHeight / 2, // TODO: Cache this.
                a.map.value = b.map, null !== b.map) {
                var c = b.map.offset,
                    d = b.map.repeat;
                a.offsetRepeat.value.set(c.x, c.y, d.x, d.y)
            }
        }

        function D(a, b) {
            a.fogColor.value = b.color, b instanceof THREE.Fog ? (a.fogNear.value = b.near, a.fogFar.value = b.far) : b instanceof THREE.FogExp2 && (a.fogDensity.value = b.density)
        }

        function E(a, b) {
            b.lightMap && (a.lightMap.value = b.lightMap, a.lightMapIntensity.value = b.lightMapIntensity), b.emissiveMap && (a.emissiveMap.value = b.emissiveMap)
        }

        function F(a, b) {
            a.specular.value = b.specular, a.shininess.value = Math.max(b.shininess, 1e-4), // to prevent pow( 0.0, 0.0 )
                b.lightMap && (a.lightMap.value = b.lightMap, a.lightMapIntensity.value = b.lightMapIntensity), b.emissiveMap && (a.emissiveMap.value = b.emissiveMap), b.bumpMap && (a.bumpMap.value = b.bumpMap, a.bumpScale.value = b.bumpScale), b.normalMap && (a.normalMap.value = b.normalMap, a.normalScale.value.copy(b.normalScale)), b.displacementMap && (a.displacementMap.value = b.displacementMap, a.displacementScale.value = b.displacementScale, a.displacementBias.value = b.displacementBias)
        }

        function G(a, b) {
            a.roughness.value = b.roughness, a.metalness.value = b.metalness, b.roughnessMap && (a.roughnessMap.value = b.roughnessMap), b.metalnessMap && (a.metalnessMap.value = b.metalnessMap), b.lightMap && (a.lightMap.value = b.lightMap, a.lightMapIntensity.value = b.lightMapIntensity), b.emissiveMap && (a.emissiveMap.value = b.emissiveMap), b.bumpMap && (a.bumpMap.value = b.bumpMap, a.bumpScale.value = b.bumpScale), b.normalMap && (a.normalMap.value = b.normalMap, a.normalScale.value.copy(b.normalScale)), b.displacementMap && (a.displacementMap.value = b.displacementMap, a.displacementScale.value = b.displacementScale, a.displacementBias.value = b.displacementBias), b.envMap && (
                //uniforms.envMap.value = material.envMap; // part of uniforms common
                a.envMapIntensity.value = b.envMapIntensity)
        }
        // If uniforms are marked as clean, they don't need to be loaded to the GPU.
        function H(a, b) {
            a.ambientLightColor.needsUpdate = b, a.directionalLights.needsUpdate = b, a.pointLights.needsUpdate = b, a.spotLights.needsUpdate = b, a.hemisphereLights.needsUpdate = b
        }
        // Uniforms (load to GPU)
        function I(a, b) {
            Oa.uniformMatrix4fv(a.modelViewMatrix, !1, b.modelViewMatrix.elements), a.normalMatrix && Oa.uniformMatrix3fv(a.normalMatrix, !1, b.normalMatrix.elements)
        }

        function J() {
            var a = za;
            return a >= Sa.maxTextures && console.warn("WebGLRenderer: trying to use " + a + " texture units while this GPU supports only " + Sa.maxTextures), za += 1, a
        }

        function K(a) {
            for (var b, c, d = 0, e = a.length; e > d; d++) {
                var f = a[d][0];
                // needsUpdate property is not added to all uniforms.
                if (f.needsUpdate !== !1) {
                    var g = f.type,
                        h = f.value,
                        i = a[d][1];
                    switch (g) {
                        case "1i":
                            Oa.uniform1i(i, h);
                            break;
                        case "1f":
                            Oa.uniform1f(i, h);
                            break;
                        case "2f":
                            Oa.uniform2f(i, h[0], h[1]);
                            break;
                        case "3f":
                            Oa.uniform3f(i, h[0], h[1], h[2]);
                            break;
                        case "4f":
                            Oa.uniform4f(i, h[0], h[1], h[2], h[3]);
                            break;
                        case "1iv":
                            Oa.uniform1iv(i, h);
                            break;
                        case "3iv":
                            Oa.uniform3iv(i, h);
                            break;
                        case "1fv":
                            Oa.uniform1fv(i, h);
                            break;
                        case "2fv":
                            Oa.uniform2fv(i, h);
                            break;
                        case "3fv":
                            Oa.uniform3fv(i, h);
                            break;
                        case "4fv":
                            Oa.uniform4fv(i, h);
                            break;
                        case "Matrix2fv":
                            Oa.uniformMatrix2fv(i, !1, h);
                            break;
                        case "Matrix3fv":
                            Oa.uniformMatrix3fv(i, !1, h);
                            break;
                        case "Matrix4fv":
                            Oa.uniformMatrix4fv(i, !1, h);
                            break;
                            //
                        case "i":
                            // single integer
                            Oa.uniform1i(i, h);
                            break;
                        case "f":
                            // single float
                            Oa.uniform1f(i, h);
                            break;
                        case "v2":
                            // single THREE.Vector2
                            Oa.uniform2f(i, h.x, h.y);
                            break;
                        case "v3":
                            // single THREE.Vector3
                            Oa.uniform3f(i, h.x, h.y, h.z);
                            break;
                        case "v4":
                            // single THREE.Vector4
                            Oa.uniform4f(i, h.x, h.y, h.z, h.w);
                            break;
                        case "c":
                            // single THREE.Color
                            Oa.uniform3f(i, h.r, h.g, h.b);
                            break;
                            /*
                            				 case 's':

                            				 // TODO: Optimize this.
                            				 for( var propertyName in uniform.properties ) {

                            				 var property = uniform.properties[ propertyName ];
                            				 var locationProperty =  location[ propertyName ];
                            				 var valueProperty = value[ propertyName ];

                            				 switch( property.type ) {
                            				 case 'i':
                            				 _gl.uniform1i( locationProperty, valueProperty );
                            				 break;
                            				 case 'f':
                            				 _gl.uniform1f( locationProperty, valueProperty );
                            				 break;
                            				 case 'v2':
                            				 _gl.uniform2f( locationProperty, valueProperty.x, valueProperty.y );
                            				 break;
                            				 case 'v3':
                            				 _gl.uniform3f( locationProperty, valueProperty.x, valueProperty.y, valueProperty.z );
                            				 break;
                            				 case 'v4':
                            				 _gl.uniform4f( locationProperty, valueProperty.x, valueProperty.y, valueProperty.z, valueProperty.w );
                            				 break;
                            				 case 'c':
                            				 _gl.uniform3f( locationProperty, valueProperty.r, valueProperty.g, valueProperty.b );
                            				 break;
                            				 };

                            				 }

                            				 break;
                            				 */
                        case "sa":
                            // TODO: Optimize this.
                            for (var j = 0; j < h.length; j++)
                                for (var k in f.properties) {
                                    var l = f.properties[k],
                                        m = i[j][k],
                                        n = h[j][k];
                                    switch (l.type) {
                                        case "i":
                                            Oa.uniform1i(m, n);
                                            break;
                                        case "f":
                                            Oa.uniform1f(m, n);
                                            break;
                                        case "v2":
                                            Oa.uniform2f(m, n.x, n.y);
                                            break;
                                        case "v3":
                                            Oa.uniform3f(m, n.x, n.y, n.z);
                                            break;
                                        case "v4":
                                            Oa.uniform4f(m, n.x, n.y, n.z, n.w);
                                            break;
                                        case "c":
                                            Oa.uniform3f(m, n.r, n.g, n.b);
                                            break;
                                        case "m4":
                                            Oa.uniformMatrix4fv(m, !1, n.elements)
                                    }
                                }
                            break;
                        case "iv1":
                            // flat array of integers (JS or typed array)
                            Oa.uniform1iv(i, h);
                            break;
                        case "iv":
                            // flat array of integers with 3 x N size (JS or typed array)
                            Oa.uniform3iv(i, h);
                            break;
                        case "fv1":
                            // flat array of floats (JS or typed array)
                            Oa.uniform1fv(i, h);
                            break;
                        case "fv":
                            // flat array of floats with 3 x N size (JS or typed array)
                            Oa.uniform3fv(i, h);
                            break;
                        case "v2v":
                            // array of THREE.Vector2
                            void 0 === f._array && (f._array = new Float32Array(2 * h.length));
                            for (var j = 0, o = 0, p = h.length; p > j; j++, o += 2) f._array[o + 0] = h[j].x, f._array[o + 1] = h[j].y;
                            Oa.uniform2fv(i, f._array);
                            break;
                        case "v3v":
                            // array of THREE.Vector3
                            void 0 === f._array && (f._array = new Float32Array(3 * h.length));
                            for (var j = 0, q = 0, p = h.length; p > j; j++, q += 3) f._array[q + 0] = h[j].x, f._array[q + 1] = h[j].y, f._array[q + 2] = h[j].z;
                            Oa.uniform3fv(i, f._array);
                            break;
                        case "v4v":
                            // array of THREE.Vector4
                            void 0 === f._array && (f._array = new Float32Array(4 * h.length));
                            for (var j = 0, r = 0, p = h.length; p > j; j++, r += 4) f._array[r + 0] = h[j].x, f._array[r + 1] = h[j].y, f._array[r + 2] = h[j].z, f._array[r + 3] = h[j].w;
                            Oa.uniform4fv(i, f._array);
                            break;
                        case "m2":
                            // single THREE.Matrix2
                            Oa.uniformMatrix2fv(i, !1, h.elements);
                            break;
                        case "m3":
                            // single THREE.Matrix3
                            Oa.uniformMatrix3fv(i, !1, h.elements);
                            break;
                        case "m3v":
                            // array of THREE.Matrix3
                            void 0 === f._array && (f._array = new Float32Array(9 * h.length));
                            for (var j = 0, p = h.length; p > j; j++) h[j].flattenToArrayOffset(f._array, 9 * j);
                            Oa.uniformMatrix3fv(i, !1, f._array);
                            break;
                        case "m4":
                            // single THREE.Matrix4
                            Oa.uniformMatrix4fv(i, !1, h.elements);
                            break;
                        case "m4v":
                            // array of THREE.Matrix4
                            void 0 === f._array && (f._array = new Float32Array(16 * h.length));
                            for (var j = 0, p = h.length; p > j; j++) h[j].flattenToArrayOffset(f._array, 16 * j);
                            Oa.uniformMatrix4fv(i, !1, f._array);
                            break;
                        case "t":
                            if (b = h, c = J(), Oa.uniform1i(i, c), !b) continue;
                            b instanceof THREE.CubeTexture || Array.isArray(b.image) && 6 === b.image.length ?
                                // CompressedTexture can have Array in image :/
                                S(b, c) : b instanceof THREE.WebGLRenderTargetCube ? T(b.texture, c) : b instanceof THREE.WebGLRenderTarget ? pa.setTexture(b.texture, c) : pa.setTexture(b, c);
                            break;
                        case "tv":
                            // array of THREE.Texture (2d or cube)
                            void 0 === f._array && (f._array = []);
                            for (var j = 0, p = f.value.length; p > j; j++) f._array[j] = J();
                            Oa.uniform1iv(i, f._array);
                            for (var j = 0, p = f.value.length; p > j; j++) b = f.value[j], c = f._array[j], b && (b instanceof THREE.CubeTexture || b.image instanceof Array && 6 === b.image.length ? S(b, c) : b instanceof THREE.WebGLRenderTarget ? pa.setTexture(b.texture, c) : b instanceof THREE.WebGLRenderTargetCube ? T(b.texture, c) : pa.setTexture(b, c));
                            break;
                        default:
                            console.warn("THREE.WebGLRenderer: Unknown uniform type: " + g)
                    }
                }
            }
        }

        function L(a, b) {
            var c, d, e, f, g, h, i = 0,
                j = 0,
                k = 0,
                l = b.matrixWorldInverse,
                m = 0,
                n = 0,
                o = 0,
                p = 0,
                q = 0;
            for (La.shadowsPointLight = 0, c = 0, d = a.length; d > c; c++)
                if (e = a[c], f = e.color, g = e.intensity, h = e.distance, e instanceof THREE.AmbientLight) i += f.r * g, j += f.g * g, k += f.b * g;
                else if (e instanceof THREE.DirectionalLight) {
                var r = Xa.get(e);
                r.color.copy(e.color).multiplyScalar(e.intensity), r.direction.setFromMatrixPosition(e.matrixWorld), Ka.setFromMatrixPosition(e.target.matrixWorld), r.direction.sub(Ka), r.direction.transformDirection(l), r.shadow = e.castShadow, e.castShadow && (r.shadowBias = e.shadow.bias, r.shadowRadius = e.shadow.radius, r.shadowMapSize = e.shadow.mapSize, La.shadows[q++] = e), La.directionalShadowMap[m] = e.shadow.map, La.directionalShadowMatrix[m] = e.shadow.matrix, La.directional[m++] = r
            } else if (e instanceof THREE.SpotLight) {
                var r = Xa.get(e);
                r.position.setFromMatrixPosition(e.matrixWorld), r.position.applyMatrix4(l), r.color.copy(f).multiplyScalar(g), r.distance = h, r.direction.setFromMatrixPosition(e.matrixWorld), Ka.setFromMatrixPosition(e.target.matrixWorld), r.direction.sub(Ka), r.direction.transformDirection(l), r.angleCos = Math.cos(e.angle), r.exponent = e.exponent, r.decay = 0 === e.distance ? 0 : e.decay, r.shadow = e.castShadow, e.castShadow && (r.shadowBias = e.shadow.bias, r.shadowRadius = e.shadow.radius, r.shadowMapSize = e.shadow.mapSize, La.shadows[q++] = e), La.spotShadowMap[o] = e.shadow.map, La.spotShadowMatrix[o] = e.shadow.matrix, La.spot[o++] = r
            } else if (e instanceof THREE.PointLight) {
                var r = Xa.get(e);
                r.position.setFromMatrixPosition(e.matrixWorld), r.position.applyMatrix4(l), r.color.copy(e.color).multiplyScalar(e.intensity), r.distance = e.distance, r.decay = 0 === e.distance ? 0 : e.decay, r.shadow = e.castShadow, e.castShadow && (r.shadowBias = e.shadow.bias, r.shadowRadius = e.shadow.radius, r.shadowMapSize = e.shadow.mapSize, La.shadows[q++] = e), La.pointShadowMap[n] = e.shadow.map, void 0 === La.pointShadowMatrix[n] && (La.pointShadowMatrix[n] = new THREE.Matrix4),
                    // for point lights we set the shadow matrix to be a translation-only matrix
                    // equal to inverse of the light's position
                    Ka.setFromMatrixPosition(e.matrixWorld).negate(), La.pointShadowMatrix[n].identity().setPosition(Ka), La.point[n++] = r
            } else if (e instanceof THREE.HemisphereLight) {
                var r = Xa.get(e);
                r.direction.setFromMatrixPosition(e.matrixWorld), r.direction.transformDirection(l), r.direction.normalize(), r.skyColor.copy(e.color).multiplyScalar(g), r.groundColor.copy(e.groundColor).multiplyScalar(g), La.hemi[p++] = r
            }
            La.ambient[0] = i, La.ambient[1] = j, La.ambient[2] = k, La.directional.length = m, La.spot.length = o, La.point.length = n, La.hemi.length = p, La.shadows.length = q, La.hash = m + "," + n + "," + o + "," + p + "," + q
        }
        // Textures
        function M(a, b, c) {
            var d;
            if (c ? (Oa.texParameteri(a, Oa.TEXTURE_WRAP_S, $(b.wrapS)), Oa.texParameteri(a, Oa.TEXTURE_WRAP_T, $(b.wrapT)), Oa.texParameteri(a, Oa.TEXTURE_MAG_FILTER, $(b.magFilter)), Oa.texParameteri(a, Oa.TEXTURE_MIN_FILTER, $(b.minFilter))) : (Oa.texParameteri(a, Oa.TEXTURE_WRAP_S, Oa.CLAMP_TO_EDGE), Oa.texParameteri(a, Oa.TEXTURE_WRAP_T, Oa.CLAMP_TO_EDGE), b.wrapS === THREE.ClampToEdgeWrapping && b.wrapT === THREE.ClampToEdgeWrapping || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.", b), Oa.texParameteri(a, Oa.TEXTURE_MAG_FILTER, Z(b.magFilter)), Oa.texParameteri(a, Oa.TEXTURE_MIN_FILTER, Z(b.minFilter)), b.minFilter !== THREE.NearestFilter && b.minFilter !== THREE.LinearFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.", b)), d = Ra.get("EXT_texture_filter_anisotropic")) {
                if (b.type === THREE.FloatType && null === Ra.get("OES_texture_float_linear")) return;
                if (b.type === THREE.HalfFloatType && null === Ra.get("OES_texture_half_float_linear")) return;
                (b.anisotropy > 1 || Ua.get(b).__currentAnisotropy) && (Oa.texParameterf(a, d.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(b.anisotropy, pa.getMaxAnisotropy())), Ua.get(b).__currentAnisotropy = b.anisotropy)
            }
        }

        function N(a, b, c) {
            void 0 === a.__webglInit && (a.__webglInit = !0, b.addEventListener("dispose", g), a.__webglTexture = Oa.createTexture(), Ma.textures++), Ta.activeTexture(Oa.TEXTURE0 + c), Ta.bindTexture(Oa.TEXTURE_2D, a.__webglTexture), Oa.pixelStorei(Oa.UNPACK_FLIP_Y_WEBGL, b.flipY), Oa.pixelStorei(Oa.UNPACK_PREMULTIPLY_ALPHA_WEBGL, b.premultiplyAlpha), Oa.pixelStorei(Oa.UNPACK_ALIGNMENT, b.unpackAlignment);
            var d = O(b.image, Sa.maxTextureSize);
            Q(b) && P(d) === !1 && (d = R(d));
            var e = P(d),
                f = $(b.format),
                h = $(b.type);
            M(Oa.TEXTURE_2D, b, e);
            var i, j = b.mipmaps;
            if (b instanceof THREE.DataTexture)
            // use manually created mipmaps if available
            // if there are no manual mipmaps
            // set 0 level mipmap and then use GL to generate other mipmap levels
                if (j.length > 0 && e) {
                for (var k = 0, l = j.length; l > k; k++) i = j[k], Ta.texImage2D(Oa.TEXTURE_2D, k, f, i.width, i.height, 0, f, h, i.data);
                b.generateMipmaps = !1
            } else Ta.texImage2D(Oa.TEXTURE_2D, 0, f, d.width, d.height, 0, f, h, d.data);
            else if (b instanceof THREE.CompressedTexture)
                for (var k = 0, l = j.length; l > k; k++) i = j[k], b.format !== THREE.RGBAFormat && b.format !== THREE.RGBFormat ? Ta.getCompressedTextureFormats().indexOf(f) > -1 ? Ta.compressedTexImage2D(Oa.TEXTURE_2D, k, f, i.width, i.height, 0, i.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Ta.texImage2D(Oa.TEXTURE_2D, k, f, i.width, i.height, 0, f, h, i.data);
            else
            // regular Texture (image, video, canvas)
            // use manually created mipmaps if available
            // if there are no manual mipmaps
            // set 0 level mipmap and then use GL to generate other mipmap levels
            if (j.length > 0 && e) {
                for (var k = 0, l = j.length; l > k; k++) i = j[k], Ta.texImage2D(Oa.TEXTURE_2D, k, f, f, h, i);
                b.generateMipmaps = !1
            } else Ta.texImage2D(Oa.TEXTURE_2D, 0, f, f, h, d);
            b.generateMipmaps && e && Oa.generateMipmap(Oa.TEXTURE_2D), a.__version = b.version, b.onUpdate && b.onUpdate(b)
        }

        function O(a, b) {
            if (a.width > b || a.height > b) {
                // Warning: Scaling through the canvas will only work with images that use
                // premultiplied alpha.
                var c = b / Math.max(a.width, a.height),
                    d = document.createElement("canvas");
                d.width = Math.floor(a.width * c), d.height = Math.floor(a.height * c);
                var e = d.getContext("2d");
                return e.drawImage(a, 0, 0, a.width, a.height, 0, 0, d.width, d.height), console.warn("THREE.WebGLRenderer: image is too big (" + a.width + "x" + a.height + "). Resized to " + d.width + "x" + d.height, a), d
            }
            return a
        }

        function P(a) {
            return THREE.Math.isPowerOfTwo(a.width) && THREE.Math.isPowerOfTwo(a.height)
        }

        function Q(a) {
            return a.wrapS !== THREE.ClampToEdgeWrapping || a.wrapT !== THREE.ClampToEdgeWrapping ? !0 : a.minFilter !== THREE.NearestFilter && a.minFilter !== THREE.LinearFilter
        }

        function R(a) {
            if (a instanceof HTMLImageElement || a instanceof HTMLCanvasElement) {
                var b = document.createElement("canvas");
                b.width = THREE.Math.nearestPowerOfTwo(a.width), b.height = THREE.Math.nearestPowerOfTwo(a.height);
                var c = b.getContext("2d");
                return c.drawImage(a, 0, 0, b.width, b.height), console.warn("THREE.WebGLRenderer: image is not power of two (" + a.width + "x" + a.height + "). Resized to " + b.width + "x" + b.height, a), b
            }
            return a
        }

        function S(a, b) {
            var c = Ua.get(a);
            if (6 === a.image.length)
                if (a.version > 0 && c.__version !== a.version) {
                    c.__image__webglTextureCube || (a.addEventListener("dispose", g), c.__image__webglTextureCube = Oa.createTexture(), Ma.textures++), Ta.activeTexture(Oa.TEXTURE0 + b), Ta.bindTexture(Oa.TEXTURE_CUBE_MAP, c.__image__webglTextureCube), Oa.pixelStorei(Oa.UNPACK_FLIP_Y_WEBGL, a.flipY);
                    for (var d = a instanceof THREE.CompressedTexture, e = a.image[0] instanceof THREE.DataTexture, f = [], h = 0; 6 > h; h++) !pa.autoScaleCubemaps || d || e ? f[h] = e ? a.image[h].image : a.image[h] : f[h] = O(a.image[h], Sa.maxCubemapSize);
                    var i = f[0],
                        j = P(i),
                        k = $(a.format),
                        l = $(a.type);
                    M(Oa.TEXTURE_CUBE_MAP, a, j);
                    for (var h = 0; 6 > h; h++)
                        if (d)
                            for (var m, n = f[h].mipmaps, o = 0, p = n.length; p > o; o++) m = n[o], a.format !== THREE.RGBAFormat && a.format !== THREE.RGBFormat ? Ta.getCompressedTextureFormats().indexOf(k) > -1 ? Ta.compressedTexImage2D(Oa.TEXTURE_CUBE_MAP_POSITIVE_X + h, o, k, m.width, m.height, 0, m.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()") : Ta.texImage2D(Oa.TEXTURE_CUBE_MAP_POSITIVE_X + h, o, k, m.width, m.height, 0, k, l, m.data);
                        else e ? Ta.texImage2D(Oa.TEXTURE_CUBE_MAP_POSITIVE_X + h, 0, k, f[h].width, f[h].height, 0, k, l, f[h].data) : Ta.texImage2D(Oa.TEXTURE_CUBE_MAP_POSITIVE_X + h, 0, k, k, l, f[h]);
                    a.generateMipmaps && j && Oa.generateMipmap(Oa.TEXTURE_CUBE_MAP), c.__version = a.version, a.onUpdate && a.onUpdate(a)
                } else Ta.activeTexture(Oa.TEXTURE0 + b), Ta.bindTexture(Oa.TEXTURE_CUBE_MAP, c.__image__webglTextureCube)
        }

        function T(a, b) {
            Ta.activeTexture(Oa.TEXTURE0 + b), Ta.bindTexture(Oa.TEXTURE_CUBE_MAP, Ua.get(a).__webglTexture)
        }
        // Render targets
        // Setup storage for target texture and bind it to correct framebuffer
        function U(a, b, c, d) {
            var e = $(b.texture.format),
                f = $(b.texture.type);
            Ta.texImage2D(d, 0, e, b.width, b.height, 0, e, f, null), Oa.bindFramebuffer(Oa.FRAMEBUFFER, a), Oa.framebufferTexture2D(Oa.FRAMEBUFFER, c, d, Ua.get(b.texture).__webglTexture, 0), Oa.bindFramebuffer(Oa.FRAMEBUFFER, null)
        }
        // Setup storage for internal depth/stencil buffers and bind to correct framebuffer
        function V(a, b) {
            Oa.bindRenderbuffer(Oa.RENDERBUFFER, a), b.depthBuffer && !b.stencilBuffer ? (Oa.renderbufferStorage(Oa.RENDERBUFFER, Oa.DEPTH_COMPONENT16, b.width, b.height), Oa.framebufferRenderbuffer(Oa.FRAMEBUFFER, Oa.DEPTH_ATTACHMENT, Oa.RENDERBUFFER, a)) : b.depthBuffer && b.stencilBuffer ? (Oa.renderbufferStorage(Oa.RENDERBUFFER, Oa.DEPTH_STENCIL, b.width, b.height), Oa.framebufferRenderbuffer(Oa.FRAMEBUFFER, Oa.DEPTH_STENCIL_ATTACHMENT, Oa.RENDERBUFFER, a)) :
                // FIXME: We don't support !depth !stencil
                Oa.renderbufferStorage(Oa.RENDERBUFFER, Oa.RGBA4, b.width, b.height), Oa.bindRenderbuffer(Oa.RENDERBUFFER, null)
        }
        // Setup GL resources for a non-texture depth buffer
        function W(a) {
            var b = Ua.get(a),
                c = a instanceof THREE.WebGLRenderTargetCube;
            if (c) {
                b.__webglDepthbuffer = [];
                for (var d = 0; 6 > d; d++) Oa.bindFramebuffer(Oa.FRAMEBUFFER, b.__webglFramebuffer[d]), b.__webglDepthbuffer[d] = Oa.createRenderbuffer(), V(b.__webglDepthbuffer[d], a)
            } else Oa.bindFramebuffer(Oa.FRAMEBUFFER, b.__webglFramebuffer), b.__webglDepthbuffer = Oa.createRenderbuffer(), V(b.__webglDepthbuffer, a);
            Oa.bindFramebuffer(Oa.FRAMEBUFFER, null)
        }
        // Set up GL resources for the render target
        function X(a) {
            var b = Ua.get(a),
                c = Ua.get(a.texture);
            a.addEventListener("dispose", h), c.__webglTexture = Oa.createTexture(), Ma.textures++;
            var d = a instanceof THREE.WebGLRenderTargetCube,
                e = THREE.Math.isPowerOfTwo(a.width) && THREE.Math.isPowerOfTwo(a.height);
            // Setup framebuffer
            if (d) {
                b.__webglFramebuffer = [];
                for (var f = 0; 6 > f; f++) b.__webglFramebuffer[f] = Oa.createFramebuffer()
            } else b.__webglFramebuffer = Oa.createFramebuffer();
            // Setup color buffer
            if (d) {
                Ta.bindTexture(Oa.TEXTURE_CUBE_MAP, c.__webglTexture), M(Oa.TEXTURE_CUBE_MAP, a.texture, e);
                for (var f = 0; 6 > f; f++) U(b.__webglFramebuffer[f], a, Oa.COLOR_ATTACHMENT0, Oa.TEXTURE_CUBE_MAP_POSITIVE_X + f);
                a.texture.generateMipmaps && e && Oa.generateMipmap(Oa.TEXTURE_CUBE_MAP), Ta.bindTexture(Oa.TEXTURE_CUBE_MAP, null)
            } else Ta.bindTexture(Oa.TEXTURE_2D, c.__webglTexture), M(Oa.TEXTURE_2D, a.texture, e), U(b.__webglFramebuffer, a, Oa.COLOR_ATTACHMENT0, Oa.TEXTURE_2D), a.texture.generateMipmaps && e && Oa.generateMipmap(Oa.TEXTURE_2D), Ta.bindTexture(Oa.TEXTURE_2D, null);
            // Setup depth and stencil buffers
            a.depthBuffer && W(a)
        }

        function Y(a) {
            var b = a instanceof THREE.WebGLRenderTargetCube ? Oa.TEXTURE_CUBE_MAP : Oa.TEXTURE_2D,
                c = Ua.get(a.texture).__webglTexture;
            Ta.bindTexture(b, c), Oa.generateMipmap(b), Ta.bindTexture(b, null)
        }
        // Fallback filters for non-power-of-2 textures
        function Z(a) {
            return a === THREE.NearestFilter || a === THREE.NearestMipMapNearestFilter || a === THREE.NearestMipMapLinearFilter ? Oa.NEAREST : Oa.LINEAR
        }
        // Map three.js constants to WebGL constants
        function $(a) {
            var b;
            if (a === THREE.RepeatWrapping) return Oa.REPEAT;
            if (a === THREE.ClampToEdgeWrapping) return Oa.CLAMP_TO_EDGE;
            if (a === THREE.MirroredRepeatWrapping) return Oa.MIRRORED_REPEAT;
            if (a === THREE.NearestFilter) return Oa.NEAREST;
            if (a === THREE.NearestMipMapNearestFilter) return Oa.NEAREST_MIPMAP_NEAREST;
            if (a === THREE.NearestMipMapLinearFilter) return Oa.NEAREST_MIPMAP_LINEAR;
            if (a === THREE.LinearFilter) return Oa.LINEAR;
            if (a === THREE.LinearMipMapNearestFilter) return Oa.LINEAR_MIPMAP_NEAREST;
            if (a === THREE.LinearMipMapLinearFilter) return Oa.LINEAR_MIPMAP_LINEAR;
            if (a === THREE.UnsignedByteType) return Oa.UNSIGNED_BYTE;
            if (a === THREE.UnsignedShort4444Type) return Oa.UNSIGNED_SHORT_4_4_4_4;
            if (a === THREE.UnsignedShort5551Type) return Oa.UNSIGNED_SHORT_5_5_5_1;
            if (a === THREE.UnsignedShort565Type) return Oa.UNSIGNED_SHORT_5_6_5;
            if (a === THREE.ByteType) return Oa.BYTE;
            if (a === THREE.ShortType) return Oa.SHORT;
            if (a === THREE.UnsignedShortType) return Oa.UNSIGNED_SHORT;
            if (a === THREE.IntType) return Oa.INT;
            if (a === THREE.UnsignedIntType) return Oa.UNSIGNED_INT;
            if (a === THREE.FloatType) return Oa.FLOAT;
            if (b = Ra.get("OES_texture_half_float"), null !== b && a === THREE.HalfFloatType) return b.HALF_FLOAT_OES;
            if (a === THREE.AlphaFormat) return Oa.ALPHA;
            if (a === THREE.RGBFormat) return Oa.RGB;
            if (a === THREE.RGBAFormat) return Oa.RGBA;
            if (a === THREE.LuminanceFormat) return Oa.LUMINANCE;
            if (a === THREE.LuminanceAlphaFormat) return Oa.LUMINANCE_ALPHA;
            if (a === THREE.AddEquation) return Oa.FUNC_ADD;
            if (a === THREE.SubtractEquation) return Oa.FUNC_SUBTRACT;
            if (a === THREE.ReverseSubtractEquation) return Oa.FUNC_REVERSE_SUBTRACT;
            if (a === THREE.ZeroFactor) return Oa.ZERO;
            if (a === THREE.OneFactor) return Oa.ONE;
            if (a === THREE.SrcColorFactor) return Oa.SRC_COLOR;
            if (a === THREE.OneMinusSrcColorFactor) return Oa.ONE_MINUS_SRC_COLOR;
            if (a === THREE.SrcAlphaFactor) return Oa.SRC_ALPHA;
            if (a === THREE.OneMinusSrcAlphaFactor) return Oa.ONE_MINUS_SRC_ALPHA;
            if (a === THREE.DstAlphaFactor) return Oa.DST_ALPHA;
            if (a === THREE.OneMinusDstAlphaFactor) return Oa.ONE_MINUS_DST_ALPHA;
            if (a === THREE.DstColorFactor) return Oa.DST_COLOR;
            if (a === THREE.OneMinusDstColorFactor) return Oa.ONE_MINUS_DST_COLOR;
            if (a === THREE.SrcAlphaSaturateFactor) return Oa.SRC_ALPHA_SATURATE;
            if (b = Ra.get("WEBGL_compressed_texture_s3tc"), null !== b) {
                if (a === THREE.RGB_S3TC_DXT1_Format) return b.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (a === THREE.RGBA_S3TC_DXT1_Format) return b.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (a === THREE.RGBA_S3TC_DXT3_Format) return b.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (a === THREE.RGBA_S3TC_DXT5_Format) return b.COMPRESSED_RGBA_S3TC_DXT5_EXT
            }
            if (b = Ra.get("WEBGL_compressed_texture_pvrtc"), null !== b) {
                if (a === THREE.RGB_PVRTC_4BPPV1_Format) return b.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (a === THREE.RGB_PVRTC_2BPPV1_Format) return b.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (a === THREE.RGBA_PVRTC_4BPPV1_Format) return b.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (a === THREE.RGBA_PVRTC_2BPPV1_Format) return b.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            }
            if (b = Ra.get("WEBGL_compressed_texture_etc1"), null !== b && a === THREE.RGB_ETC1_Format) return b.COMPRESSED_RGB_ETC1_WEBGL;
            if (b = Ra.get("EXT_blend_minmax"), null !== b) {
                if (a === THREE.MinEquation) return b.MIN_EXT;
                if (a === THREE.MaxEquation) return b.MAX_EXT
            }
            return 0
        }
        console.log("THREE.WebGLRenderer", THREE.REVISION), a = a || {};
        var _ = void 0 !== a.canvas ? a.canvas : document.createElement("canvas"),
            aa = void 0 !== a.context ? a.context : null,
            ba = void 0 !== a.alpha ? a.alpha : !1,
            ca = void 0 !== a.depth ? a.depth : !0,
            da = void 0 !== a.stencil ? a.stencil : !0,
            ea = void 0 !== a.antialias ? a.antialias : !1,
            fa = void 0 !== a.premultipliedAlpha ? a.premultipliedAlpha : !0,
            ga = void 0 !== a.preserveDrawingBuffer ? a.preserveDrawingBuffer : !1,
            ha = [],
            ia = [],
            ja = -1,
            ka = [],
            la = -1,
            ma = new Float32Array(8),
            na = [],
            oa = [];
        // public properties
        this.domElement = _, this.context = null,
            // clearing
            this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0,
            // scene graph
            this.sortObjects = !0,
            // physically based shading
            this.gammaFactor = 2, // for backwards compatibility
            this.gammaInput = !1, this.gammaOutput = !1,
            // morphs
            this.maxMorphTargets = 8, this.maxMorphNormals = 4,
            // flags
            this.autoScaleCubemaps = !0;
        // internal properties
        var pa = this,
            // internal state cache
            qa = null,
            ra = null,
            sa = null,
            ta = -1,
            ua = "",
            va = null,
            wa = new THREE.Vector4,
            xa = null,
            ya = new THREE.Vector4,
            //
            za = 0,
            //
            Aa = new THREE.Color(0),
            Ba = 0,
            Ca = _.width,
            Da = _.height,
            Ea = 1,
            Fa = new THREE.Vector4(0, 0, Ca, Da),
            Ga = !1,
            Ha = new THREE.Vector4(0, 0, Ca, Da),
            // frustum
            Ia = new THREE.Frustum,
            // camera matrices cache
            Ja = new THREE.Matrix4,
            Ka = new THREE.Vector3,
            // light arrays cache
            La = {
                hash: "",
                ambient: [0, 0, 0],
                directional: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotShadowMap: [],
                spotShadowMatrix: [],
                point: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: [],
                shadows: [],
                shadowsPointLight: 0
            },
            // info
            Ma = {
                geometries: 0,
                textures: 0
            },
            Na = {
                calls: 0,
                vertices: 0,
                faces: 0,
                points: 0
            };
        this.info = {
            render: Na,
            memory: Ma,
            programs: null
        };
        // initialize
        var Oa;
        try {
            var Pa = {
                alpha: ba,
                depth: ca,
                stencil: da,
                antialias: ea,
                premultipliedAlpha: fa,
                preserveDrawingBuffer: ga
            };
            if (Oa = aa || _.getContext("webgl", Pa) || _.getContext("experimental-webgl", Pa), null === Oa) throw null !== _.getContext("webgl") ? "Error creating WebGL context with your selected attributes." : "Error creating WebGL context.";
            _.addEventListener("webglcontextlost", f, !1)
        } catch (Qa) {
            console.error("THREE.WebGLRenderer: " + Qa)
        }
        var Ra = new THREE.WebGLExtensions(Oa);
        Ra.get("OES_texture_float"), Ra.get("OES_texture_float_linear"), Ra.get("OES_texture_half_float"), Ra.get("OES_texture_half_float_linear"), Ra.get("OES_standard_derivatives"), Ra.get("ANGLE_instanced_arrays"), Ra.get("OES_element_index_uint") && (THREE.BufferGeometry.MaxIndex = 4294967296);
        var Sa = new THREE.WebGLCapabilities(Oa, Ra, a),
            Ta = new THREE.WebGLState(Oa, Ra, $),
            Ua = new THREE.WebGLProperties,
            Va = new THREE.WebGLObjects(Oa, Ua, this.info),
            Wa = new THREE.WebGLPrograms(this, Sa),
            Xa = new THREE.WebGLLights;
        this.info.programs = Wa.programs;
        var Ya = new THREE.WebGLBufferRenderer(Oa, Ra, Na),
            Za = new THREE.WebGLIndexedBufferRenderer(Oa, Ra, Na);
        d(), this.context = Oa, this.capabilities = Sa, this.extensions = Ra, this.properties = Ua, this.state = Ta;
        // shadow map
        var $a = new THREE.WebGLShadowMap(this, La, Va);
        this.shadowMap = $a;
        // Plugins
        var _a = new THREE.SpritePlugin(this, na),
            ab = new THREE.LensFlarePlugin(this, oa);
        // API
        this.getContext = function() {
                return Oa
            }, this.getContextAttributes = function() {
                return Oa.getContextAttributes()
            }, this.forceContextLoss = function() {
                Ra.get("WEBGL_lose_context").loseContext()
            }, this.getMaxAnisotropy = function() {
                var a;
                return function() {
                    if (void 0 !== a) return a;
                    var b = Ra.get("EXT_texture_filter_anisotropic");
                    return a = null !== b ? Oa.getParameter(b.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
                }
            }(), this.getPrecision = function() {
                return Sa.precision
            }, this.getPixelRatio = function() {
                return Ea
            }, this.setPixelRatio = function(a) {
                void 0 !== a && (Ea = a, this.setSize(Ha.z, Ha.w, !1))
            }, this.getSize = function() {
                return {
                    width: Ca,
                    height: Da
                }
            }, this.setSize = function(a, b, c) {
                Ca = a, Da = b, _.width = a * Ea, _.height = b * Ea, c !== !1 && (_.style.width = a + "px", _.style.height = b + "px"), this.setViewport(0, 0, a, b)
            }, this.setViewport = function(a, b, c, d) {
                Ta.viewport(Ha.set(a, b, c, d))
            }, this.setScissor = function(a, b, c, d) {
                Ta.scissor(Fa.set(a, b, c, d))
            }, this.setScissorTest = function(a) {
                Ta.setScissorTest(Ga = a)
            },
            // Clearing
            this.getClearColor = function() {
                return Aa
            }, this.setClearColor = function(a, b) {
                Aa.set(a), Ba = void 0 !== b ? b : 1, c(Aa.r, Aa.g, Aa.b, Ba)
            }, this.getClearAlpha = function() {
                return Ba
            }, this.setClearAlpha = function(a) {
                Ba = a, c(Aa.r, Aa.g, Aa.b, Ba)
            }, this.clear = function(a, b, c) {
                var d = 0;
                (void 0 === a || a) && (d |= Oa.COLOR_BUFFER_BIT), (void 0 === b || b) && (d |= Oa.DEPTH_BUFFER_BIT), (void 0 === c || c) && (d |= Oa.STENCIL_BUFFER_BIT), Oa.clear(d)
            }, this.clearColor = function() {
                this.clear(!0, !1, !1)
            }, this.clearDepth = function() {
                this.clear(!1, !0, !1)
            }, this.clearStencil = function() {
                this.clear(!1, !1, !0)
            }, this.clearTarget = function(a, b, c, d) {
                this.setRenderTarget(a), this.clear(b, c, d)
            },
            // Reset
            this.resetGLState = e, this.dispose = function() {
                _.removeEventListener("webglcontextlost", f, !1)
            },
            // Buffer rendering
            this.renderBufferImmediate = function(a, b, c) {
                Ta.initAttributes();
                var d = Ua.get(a);
                a.hasPositions && !d.position && (d.position = Oa.createBuffer()), a.hasNormals && !d.normal && (d.normal = Oa.createBuffer()), a.hasUvs && !d.uv && (d.uv = Oa.createBuffer()), a.hasColors && !d.color && (d.color = Oa.createBuffer());
                var e = b.getAttributes();
                if (a.hasPositions && (Oa.bindBuffer(Oa.ARRAY_BUFFER, d.position), Oa.bufferData(Oa.ARRAY_BUFFER, a.positionArray, Oa.DYNAMIC_DRAW), Ta.enableAttribute(e.position), Oa.vertexAttribPointer(e.position, 3, Oa.FLOAT, !1, 0, 0)), a.hasNormals) {
                    if (Oa.bindBuffer(Oa.ARRAY_BUFFER, d.normal), "MeshPhongMaterial" !== c.type && "MeshStandardMaterial" !== c.type && c.shading === THREE.FlatShading)
                        for (var f = 0, g = 3 * a.count; g > f; f += 9) {
                            var h = a.normalArray,
                                i = (h[f + 0] + h[f + 3] + h[f + 6]) / 3,
                                j = (h[f + 1] + h[f + 4] + h[f + 7]) / 3,
                                k = (h[f + 2] + h[f + 5] + h[f + 8]) / 3;
                            h[f + 0] = i, h[f + 1] = j, h[f + 2] = k, h[f + 3] = i, h[f + 4] = j, h[f + 5] = k, h[f + 6] = i, h[f + 7] = j, h[f + 8] = k
                        }
                    Oa.bufferData(Oa.ARRAY_BUFFER, a.normalArray, Oa.DYNAMIC_DRAW), Ta.enableAttribute(e.normal), Oa.vertexAttribPointer(e.normal, 3, Oa.FLOAT, !1, 0, 0)
                }
                a.hasUvs && c.map && (Oa.bindBuffer(Oa.ARRAY_BUFFER, d.uv), Oa.bufferData(Oa.ARRAY_BUFFER, a.uvArray, Oa.DYNAMIC_DRAW), Ta.enableAttribute(e.uv), Oa.vertexAttribPointer(e.uv, 2, Oa.FLOAT, !1, 0, 0)), a.hasColors && c.vertexColors !== THREE.NoColors && (Oa.bindBuffer(Oa.ARRAY_BUFFER, d.color), Oa.bufferData(Oa.ARRAY_BUFFER, a.colorArray, Oa.DYNAMIC_DRAW), Ta.enableAttribute(e.color), Oa.vertexAttribPointer(e.color, 3, Oa.FLOAT, !1, 0, 0)), Ta.disableUnusedAttributes(), Oa.drawArrays(Oa.TRIANGLES, 0, a.count), a.count = 0
            }, this.renderBufferDirect = function(a, c, d, e, f, g) {
                v(e);
                var h = x(a, c, e, f),
                    i = !1,
                    j = d.id + "_" + h.id + "_" + e.wireframe;
                j !== ua && (ua = j, i = !0);
                // morph targets
                var k = f.morphTargetInfluences;
                if (void 0 !== k) {
                    for (var l = [], m = 0, p = k.length; p > m; m++) {
                        var q = k[m];
                        l.push([q, m])
                    }
                    l.sort(o), l.length > 8 && (l.length = 8);
                    for (var r = d.morphAttributes, m = 0, p = l.length; p > m; m++) {
                        var q = l[m];
                        if (ma[m] = q[0], 0 !== q[0]) {
                            var s = q[1];
                            e.morphTargets === !0 && r.position && d.addAttribute("morphTarget" + m, r.position[s]), e.morphNormals === !0 && r.normal && d.addAttribute("morphNormal" + m, r.normal[s])
                        } else e.morphTargets === !0 && d.removeAttribute("morphTarget" + m), e.morphNormals === !0 && d.removeAttribute("morphNormal" + m)
                    }
                    var t = h.getUniforms();
                    null !== t.morphTargetInfluences && Oa.uniform1fv(t.morphTargetInfluences, ma), i = !0
                }
                //
                var s = d.index,
                    u = d.attributes.position;
                e.wireframe === !0 && (s = Va.getWireframeAttribute(d));
                var w;
                null !== s ? (w = Za, w.setIndex(s)) : w = Ya, i && (n(e, h, d), null !== s && Oa.bindBuffer(Oa.ELEMENT_ARRAY_BUFFER, Va.getAttributeBuffer(s)));
                //
                var y = 0,
                    z = 1 / 0;
                null !== s ? z = s.count : void 0 !== u && (z = u.count);
                var A = d.drawRange.start,
                    B = d.drawRange.count,
                    C = null !== g ? g.start : 0,
                    D = null !== g ? g.count : 1 / 0,
                    E = Math.max(y, A, C),
                    F = Math.min(y + z, A + B, C + D) - 1,
                    G = Math.max(0, F - E + 1);
                //
                if (f instanceof THREE.Mesh)
                    if (e.wireframe === !0) Ta.setLineWidth(e.wireframeLinewidth * b()), w.setMode(Oa.LINES);
                    else switch (f.drawMode) {
                        case THREE.TrianglesDrawMode:
                            w.setMode(Oa.TRIANGLES);
                            break;
                        case THREE.TriangleStripDrawMode:
                            w.setMode(Oa.TRIANGLE_STRIP);
                            break;
                        case THREE.TriangleFanDrawMode:
                            w.setMode(Oa.TRIANGLE_FAN)
                    } else if (f instanceof THREE.Line) {
                        var H = e.linewidth;
                        void 0 === H && (H = 1), // Not using Line*Material
                            Ta.setLineWidth(H * b()), f instanceof THREE.LineSegments ? w.setMode(Oa.LINES) : w.setMode(Oa.LINE_STRIP)
                    } else f instanceof THREE.Points && w.setMode(Oa.POINTS);
                d instanceof THREE.InstancedBufferGeometry && d.maxInstancedCount > 0 ? w.renderInstances(d, E, G) : w.render(E, G)
            },
            // Rendering
            this.render = function(a, b, c, d) {
                if (b instanceof THREE.Camera == !1) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                var e = a.fog;
                //
                if (ua = "", ta = -1, va = null, a.autoUpdate === !0 && a.updateMatrixWorld(), null === b.parent && b.updateMatrixWorld(), b.matrixWorldInverse.getInverse(b.matrixWorld), Ja.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse), Ia.setFromMatrix(Ja), ha.length = 0, ja = -1, la = -1, na.length = 0, oa.length = 0, s(a, b), ia.length = ja + 1, ka.length = la + 1, pa.sortObjects === !0 && (ia.sort(p), ka.sort(q)), L(ha, b), $a.render(a, b), Na.calls = 0, Na.vertices = 0, Na.faces = 0, Na.points = 0, void 0 === c && (c = null), this.setRenderTarget(c), (this.autoClear || d) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil), a.overrideMaterial) {
                    var f = a.overrideMaterial;
                    t(ia, b, e, f), t(ka, b, e, f)
                } else
                // opaque pass (front-to-back order)
                    Ta.setBlending(THREE.NoBlending), t(ia, b, e),
                    // transparent pass (back-to-front order)
                    t(ka, b, e);
                // Generate mipmap if we're using any kind of mipmap filtering
                if (
                    // custom render plugins (post pass)
                    _a.render(a, b), ab.render(a, b, ya), c) {
                    var g = c.texture;
                    g.generateMipmaps && P(c) && g.minFilter !== THREE.NearestFilter && g.minFilter !== THREE.LinearFilter && Y(c)
                }
                // Ensure depth buffer writing is enabled so it can be cleared on next render
                Ta.setDepthTest(!0), Ta.setDepthWrite(!0), Ta.setColorWrite(!0)
            },
            // GL state setting
            this.setFaceCulling = function(a, b) {
                a === THREE.CullFaceNone ? Ta.disable(Oa.CULL_FACE) : (b === THREE.FrontFaceDirectionCW ? Oa.frontFace(Oa.CW) : Oa.frontFace(Oa.CCW), a === THREE.CullFaceBack ? Oa.cullFace(Oa.BACK) : a === THREE.CullFaceFront ? Oa.cullFace(Oa.FRONT) : Oa.cullFace(Oa.FRONT_AND_BACK), Ta.enable(Oa.CULL_FACE))
            }, this.setTexture = function(a, b) {
                var c = Ua.get(a);
                if (a.version > 0 && c.__version !== a.version) {
                    var d = a.image;
                    return void 0 === d ? void console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined", a) : d.complete === !1 ? void console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete", a) : void N(c, a, b)
                }
                Ta.activeTexture(Oa.TEXTURE0 + b), Ta.bindTexture(Oa.TEXTURE_2D, c.__webglTexture)
            }, this.setRenderTarget = function(a) {
                ra = a, a && void 0 === Ua.get(a).__webglFramebuffer && X(a);
                var b, c = a instanceof THREE.WebGLRenderTargetCube;
                if (a) {
                    var d = Ua.get(a);
                    b = c ? d.__webglFramebuffer[a.activeCubeFace] : d.__webglFramebuffer, wa.copy(a.scissor), xa = a.scissorTest, ya.copy(a.viewport)
                } else b = null, wa.copy(Fa).multiplyScalar(Ea), xa = Ga, ya.copy(Ha).multiplyScalar(Ea);
                if (sa !== b && (Oa.bindFramebuffer(Oa.FRAMEBUFFER, b), sa = b), Ta.scissor(wa), Ta.setScissorTest(xa), Ta.viewport(ya), c) {
                    var e = Ua.get(a.texture);
                    Oa.framebufferTexture2D(Oa.FRAMEBUFFER, Oa.COLOR_ATTACHMENT0, Oa.TEXTURE_CUBE_MAP_POSITIVE_X + a.activeCubeFace, e.__webglTexture, 0)
                }
            }, this.readRenderTargetPixels = function(a, b, c, d, e, f) {
                if (a instanceof THREE.WebGLRenderTarget == !1) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                var g = Ua.get(a).__webglFramebuffer;
                if (g) {
                    var h = !1;
                    g !== sa && (Oa.bindFramebuffer(Oa.FRAMEBUFFER, g), h = !0);
                    try {
                        var i = a.texture;
                        if (i.format !== THREE.RGBAFormat && $(i.format) !== Oa.getParameter(Oa.IMPLEMENTATION_COLOR_READ_FORMAT)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        if (!(i.type === THREE.UnsignedByteType || $(i.type) === Oa.getParameter(Oa.IMPLEMENTATION_COLOR_READ_TYPE) || i.type === THREE.FloatType && Ra.get("WEBGL_color_buffer_float") || i.type === THREE.HalfFloatType && Ra.get("EXT_color_buffer_half_float"))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        Oa.checkFramebufferStatus(Oa.FRAMEBUFFER) === Oa.FRAMEBUFFER_COMPLETE ? Oa.readPixels(b, c, d, e, $(i.format), $(i.type), f) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                    } finally {
                        h && Oa.bindFramebuffer(Oa.FRAMEBUFFER, sa)
                    }
                }
            }
    },
    // File:src/renderers/WebGLRenderTarget.js
    /**
     * @author szimek / https://github.com/szimek/
     * @author alteredq / http://alteredqualia.com/
     * @author Marius Kintel / https://github.com/kintel
     */
    /*
     In options, we can specify:
     * Texture parameters for an auto-generated target texture
     * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
     */
    THREE.WebGLRenderTarget = function(a, b, c) {
        this.uuid = THREE.Math.generateUUID(), this.width = a, this.height = b, this.scissor = new THREE.Vector4(0, 0, a, b), this.scissorTest = !1, this.viewport = new THREE.Vector4(0, 0, a, b), c = c || {}, void 0 === c.minFilter && (c.minFilter = THREE.LinearFilter), this.texture = new THREE.Texture(void 0, void 0, c.wrapS, c.wrapT, c.magFilter, c.minFilter, c.format, c.type, c.anisotropy), this.depthBuffer = void 0 !== c.depthBuffer ? c.depthBuffer : !0, this.stencilBuffer = void 0 !== c.stencilBuffer ? c.stencilBuffer : !0
    }, THREE.WebGLRenderTarget.prototype = {
        constructor: THREE.WebGLRenderTarget,
        setSize: function(a, b) {
            this.width === a && this.height === b || (this.width = a, this.height = b, this.dispose()), this.viewport.set(0, 0, a, b), this.scissor.set(0, 0, a, b)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(a) {
            return this.width = a.width, this.height = a.height, this.viewport.copy(a.viewport), this.texture = a.texture.clone(), this.depthBuffer = a.depthBuffer, this.stencilBuffer = a.stencilBuffer, this.shareDepthFrom = a.shareDepthFrom, this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }, THREE.EventDispatcher.prototype.apply(THREE.WebGLRenderTarget.prototype),
    // File:src/renderers/WebGLRenderTargetCube.js
    /**
     * @author alteredq / http://alteredqualia.com
     */
    THREE.WebGLRenderTargetCube = function(a, b, c) {
        THREE.WebGLRenderTarget.call(this, a, b, c), this.activeCubeFace = 0
    }, THREE.WebGLRenderTargetCube.prototype = Object.create(THREE.WebGLRenderTarget.prototype), THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube,
    // File:src/renderers/webgl/WebGLBufferRenderer.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.WebGLBufferRenderer = function(a, b, c) {
        function d(a) {
            g = a
        }

        function e(b, d) {
            a.drawArrays(g, b, d), c.calls++, c.vertices += d, g === a.TRIANGLES && (c.faces += d / 3)
        }

        function f(d) {
            var e = b.get("ANGLE_instanced_arrays");
            if (null === e) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            var f = d.attributes.position,
                h = 0;
            f instanceof THREE.InterleavedBufferAttribute ? (h = f.data.count, e.drawArraysInstancedANGLE(g, 0, h, d.maxInstancedCount)) : (h = f.count, e.drawArraysInstancedANGLE(g, 0, h, d.maxInstancedCount)), c.calls++, c.vertices += h * d.maxInstancedCount, g === a.TRIANGLES && (c.faces += d.maxInstancedCount * h / 3)
        }
        var g;
        this.setMode = d, this.render = e, this.renderInstances = f
    },
    // File:src/renderers/webgl/WebGLIndexedBufferRenderer.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.WebGLIndexedBufferRenderer = function(a, b, c) {
        function d(a) {
            h = a
        }

        function e(c) {
            c.array instanceof Uint32Array && b.get("OES_element_index_uint") ? (i = a.UNSIGNED_INT, j = 4) : (i = a.UNSIGNED_SHORT, j = 2)
        }

        function f(b, d) {
            a.drawElements(h, d, i, b * j), c.calls++, c.vertices += d, h === a.TRIANGLES && (c.faces += d / 3)
        }

        function g(d, e, f) {
            var g = b.get("ANGLE_instanced_arrays");
            return null === g ? void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.") : (g.drawElementsInstancedANGLE(h, f, i, e * j, d.maxInstancedCount), c.calls++, c.vertices += f * d.maxInstancedCount, void(h === a.TRIANGLES && (c.faces += d.maxInstancedCount * f / 3)))
        }
        var h, i, j;
        this.setMode = d, this.setIndex = e, this.render = f, this.renderInstances = g
    },
    // File:src/renderers/webgl/WebGLExtensions.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.WebGLExtensions = function(a) {
        var b = {};
        this.get = function(c) {
            if (void 0 !== b[c]) return b[c];
            var d;
            switch (c) {
                case "EXT_texture_filter_anisotropic":
                    d = a.getExtension("EXT_texture_filter_anisotropic") || a.getExtension("MOZ_EXT_texture_filter_anisotropic") || a.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                    break;
                case "WEBGL_compressed_texture_s3tc":
                    d = a.getExtension("WEBGL_compressed_texture_s3tc") || a.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                    break;
                case "WEBGL_compressed_texture_pvrtc":
                    d = a.getExtension("WEBGL_compressed_texture_pvrtc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                    break;
                case "WEBGL_compressed_texture_etc1":
                    d = a.getExtension("WEBGL_compressed_texture_etc1");
                    break;
                default:
                    d = a.getExtension(c)
            }
            return null === d && console.warn("THREE.WebGLRenderer: " + c + " extension not supported."), b[c] = d, d
        }
    },
    // File:src/renderers/webgl/WebGLCapabilities.js
    THREE.WebGLCapabilities = function(a, b, c) {
        function d(b) {
            if ("highp" === b) {
                if (a.getShaderPrecisionFormat(a.VERTEX_SHADER, a.HIGH_FLOAT).precision > 0 && a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.HIGH_FLOAT).precision > 0) return "highp";
                b = "mediump"
            }
            return "mediump" === b && a.getShaderPrecisionFormat(a.VERTEX_SHADER, a.MEDIUM_FLOAT).precision > 0 && a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
        }
        this.getMaxPrecision = d, this.precision = void 0 !== c.precision ? c.precision : "highp", this.logarithmicDepthBuffer = void 0 !== c.logarithmicDepthBuffer ? c.logarithmicDepthBuffer : !1, this.maxTextures = a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS), this.maxVertexTextures = a.getParameter(a.MAX_VERTEX_TEXTURE_IMAGE_UNITS), this.maxTextureSize = a.getParameter(a.MAX_TEXTURE_SIZE), this.maxCubemapSize = a.getParameter(a.MAX_CUBE_MAP_TEXTURE_SIZE), this.maxAttributes = a.getParameter(a.MAX_VERTEX_ATTRIBS), this.maxVertexUniforms = a.getParameter(a.MAX_VERTEX_UNIFORM_VECTORS), this.maxVaryings = a.getParameter(a.MAX_VARYING_VECTORS), this.maxFragmentUniforms = a.getParameter(a.MAX_FRAGMENT_UNIFORM_VECTORS), this.vertexTextures = this.maxVertexTextures > 0, this.floatFragmentTextures = !!b.get("OES_texture_float"), this.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;
        var e = d(this.precision);
        e !== this.precision && (console.warn("THREE.WebGLRenderer:", this.precision, "not supported, using", e, "instead."), this.precision = e), this.logarithmicDepthBuffer && (this.logarithmicDepthBuffer = !!b.get("EXT_frag_depth"))
    },
    // File:src/renderers/webgl/WebGLGeometries.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.WebGLGeometries = function(a, b, c) {
        function d(a) {
            var b = a.geometry;
            if (void 0 !== j[b.id]) return j[b.id];
            b.addEventListener("dispose", e);
            var d;
            return b instanceof THREE.BufferGeometry ? d = b : b instanceof THREE.Geometry && (void 0 === b._bufferGeometry && (b._bufferGeometry = (new THREE.BufferGeometry).setFromObject(a)), d = b._bufferGeometry), j[b.id] = d, c.memory.geometries++, d
        }

        function e(a) {
            var d = a.target,
                f = j[d.id];
            null !== f.index && g(f.index), h(f.attributes), d.removeEventListener("dispose", e), delete j[d.id];
            // TODO
            var i = b.get(d);
            i.wireframe && g(i.wireframe), b["delete"](d);
            var k = b.get(f);
            k.wireframe && g(k.wireframe), b["delete"](f),
                //
                c.memory.geometries--
        }

        function f(a) {
            return a instanceof THREE.InterleavedBufferAttribute ? b.get(a.data).__webglBuffer : b.get(a).__webglBuffer
        }

        function g(b) {
            var c = f(b);
            void 0 !== c && (a.deleteBuffer(c), i(b))
        }

        function h(a) {
            for (var b in a) g(a[b])
        }

        function i(a) {
            a instanceof THREE.InterleavedBufferAttribute ? b["delete"](a.data) : b["delete"](a)
        }
        var j = {};
        this.get = d
    },
    // File:src/renderers/webgl/WebGLLights.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.WebGLLights = function() {
        var a = {};
        this.get = function(b) {
            if (void 0 !== a[b.id]) return a[b.id];
            var c;
            switch (b.type) {
                case "DirectionalLight":
                    c = {
                        direction: new THREE.Vector3,
                        color: new THREE.Color,
                        shadow: !1,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new THREE.Vector2
                    };
                    break;
                case "SpotLight":
                    c = {
                        position: new THREE.Vector3,
                        direction: new THREE.Vector3,
                        color: new THREE.Color,
                        distance: 0,
                        angleCos: 0,
                        exponent: 0,
                        decay: 0,
                        shadow: !1,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new THREE.Vector2
                    };
                    break;
                case "PointLight":
                    c = {
                        position: new THREE.Vector3,
                        color: new THREE.Color,
                        distance: 0,
                        decay: 0,
                        shadow: !1,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new THREE.Vector2
                    };
                    break;
                case "HemisphereLight":
                    c = {
                        direction: new THREE.Vector3,
                        skyColor: new THREE.Color,
                        groundColor: new THREE.Color
                    }
            }
            return a[b.id] = c, c
        }
    },
    // File:src/renderers/webgl/WebGLObjects.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.WebGLObjects = function(a, b, c) {
        //
        function d(b) {
            // TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.
            var c = k.get(b);
            b.geometry instanceof THREE.Geometry && c.updateFromObject(b);
            var d = c.index,
                f = c.attributes;
            null !== d && e(d, a.ELEMENT_ARRAY_BUFFER);
            for (var g in f) e(f[g], a.ARRAY_BUFFER);
            // morph targets
            var h = c.morphAttributes;
            for (var g in h)
                for (var i = h[g], j = 0, l = i.length; l > j; j++) e(i[j], a.ARRAY_BUFFER);
            return c
        }

        function e(a, c) {
            var d = a instanceof THREE.InterleavedBufferAttribute ? a.data : a,
                e = b.get(d);
            void 0 === e.__webglBuffer ? f(e, d, c) : e.version !== d.version && g(e, d, c)
        }

        function f(b, c, d) {
            b.__webglBuffer = a.createBuffer(), a.bindBuffer(d, b.__webglBuffer);
            var e = c.dynamic ? a.DYNAMIC_DRAW : a.STATIC_DRAW;
            a.bufferData(d, c.array, e), b.version = c.version
        }

        function g(b, c, d) {
            a.bindBuffer(d, b.__webglBuffer), c.dynamic === !1 || -1 === c.updateRange.count ?
                // Not using update ranges
                a.bufferSubData(d, 0, c.array) : 0 === c.updateRange.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (a.bufferSubData(d, c.updateRange.offset * c.array.BYTES_PER_ELEMENT, c.array.subarray(c.updateRange.offset, c.updateRange.offset + c.updateRange.count)), c.updateRange.count = 0), b.version = c.version
        }

        function h(a) {
            return a instanceof THREE.InterleavedBufferAttribute ? b.get(a.data).__webglBuffer : b.get(a).__webglBuffer
        }

        function i(c) {
            var d = b.get(c);
            if (void 0 !== d.wireframe) return d.wireframe;
            var f = [],
                g = c.index,
                h = c.attributes,
                i = h.position;
            // console.time( 'wireframe' );
            if (null !== g)
                for (var k = {}, l = g.array, m = 0, n = l.length; n > m; m += 3) {
                    var o = l[m + 0],
                        p = l[m + 1],
                        q = l[m + 2];
                    j(k, o, p) && f.push(o, p), j(k, p, q) && f.push(p, q), j(k, q, o) && f.push(q, o)
                } else
                    for (var l = h.position.array, m = 0, n = l.length / 3 - 1; n > m; m += 3) {
                        var o = m + 0,
                            p = m + 1,
                            q = m + 2;
                        f.push(o, p, p, q, q, o)
                    }
                    // console.timeEnd( 'wireframe' );
            var r = i.count > 65535 ? Uint32Array : Uint16Array,
                s = new THREE.BufferAttribute(new r(f), 1);
            return e(s, a.ELEMENT_ARRAY_BUFFER), d.wireframe = s, s
        }

        function j(a, b, c) {
            if (b > c) {
                var d = b;
                b = c, c = d
            }
            var e = a[b];
            return void 0 === e ? (a[b] = [c], !0) : -1 === e.indexOf(c) ? (e.push(c), !0) : !1
        }
        var k = new THREE.WebGLGeometries(a, b, c);
        this.getAttributeBuffer = h, this.getWireframeAttribute = i, this.update = d
    },
    // File:src/renderers/webgl/WebGLProgram.js
    THREE.WebGLProgram = function() {
        function a(a, b, c) {
            a = a || {};
            var d = [a.derivatives || b.bumpMap || b.normalMap || b.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (a.fragDepth || b.logarithmicDepthBuffer) && c.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", a.drawBuffers && c.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (a.shaderTextureLOD || b.envMap) && c.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""];
            return d.filter(e).join("\n")
        }

        function b(a) {
            var b = [];
            for (var c in a) {
                var d = a[c];
                d !== !1 && b.push("#define " + c + " " + d)
            }
            return b.join("\n")
        }

        function c(a, b, c) {
            for (var d = {}, e = a.getProgramParameter(b, a.ACTIVE_UNIFORMS), f = 0; e > f; f++) {
                var g = a.getActiveUniform(b, f),
                    h = g.name,
                    l = a.getUniformLocation(b, h),
                    m = i.exec(h);
                if (m) {
                    var n = m[1],
                        o = m[2],
                        p = d[n];
                    p || (p = d[n] = {}), p[o] = l
                } else if (m = j.exec(h)) {
                    var q = m[1],
                        r = m[2],
                        s = m[3],
                        t = d[q];
                    t || (t = d[q] = []);
                    var u = t[r];
                    u || (u = t[r] = {}), u[s] = l
                } else if (m = k.exec(h)) {
                    var q = m[1];
                    d[q] = l
                } else d[h] = l
            }
            return d
        }

        function d(a, b, c) {
            for (var d = {}, e = a.getProgramParameter(b, a.ACTIVE_ATTRIBUTES), f = 0; e > f; f++) {
                var g = a.getActiveAttrib(b, f),
                    h = g.name;
                // console.log("THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:", name, i );
                d[h] = a.getAttribLocation(b, h)
            }
            return d
        }

        function e(a) {
            return "" !== a
        }

        function f(a, b) {
            return a.replace(/NUM_DIR_LIGHTS/g, b.numDirLights).replace(/NUM_SPOT_LIGHTS/g, b.numSpotLights).replace(/NUM_POINT_LIGHTS/g, b.numPointLights).replace(/NUM_HEMI_LIGHTS/g, b.numHemiLights)
        }

        function g(a) {
            function b(a, b, c, d) {
                for (var e = "", f = parseInt(b); f < parseInt(c); f++) e += d.replace(/\[ i \]/g, "[ " + f + " ]");
                return e
            }
            var c = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
            return a.replace(c, b)
        }
        var h = 0,
            i = /^([\w\d_]+)\.([\w\d_]+)$/,
            j = /^([\w\d_]+)\[(\d+)\]\.([\w\d_]+)$/,
            k = /^([\w\d_]+)\[0\]$/;
        return function(i, j, k, l) {
            var m = i.context,
                n = k.extensions,
                o = k.defines,
                p = k.__webglShader.vertexShader,
                q = k.__webglShader.fragmentShader,
                r = "SHADOWMAP_TYPE_BASIC";
            l.shadowMapType === THREE.PCFShadowMap ? r = "SHADOWMAP_TYPE_PCF" : l.shadowMapType === THREE.PCFSoftShadowMap && (r = "SHADOWMAP_TYPE_PCF_SOFT");
            var s = "ENVMAP_TYPE_CUBE",
                t = "ENVMAP_MODE_REFLECTION",
                u = "ENVMAP_BLENDING_MULTIPLY";
            if (l.envMap) {
                switch (k.envMap.mapping) {
                    case THREE.CubeReflectionMapping:
                    case THREE.CubeRefractionMapping:
                        s = "ENVMAP_TYPE_CUBE";
                        break;
                    case THREE.EquirectangularReflectionMapping:
                    case THREE.EquirectangularRefractionMapping:
                        s = "ENVMAP_TYPE_EQUIREC";
                        break;
                    case THREE.SphericalReflectionMapping:
                        s = "ENVMAP_TYPE_SPHERE"
                }
                switch (k.envMap.mapping) {
                    case THREE.CubeRefractionMapping:
                    case THREE.EquirectangularRefractionMapping:
                        t = "ENVMAP_MODE_REFRACTION"
                }
                switch (k.combine) {
                    case THREE.MultiplyOperation:
                        u = "ENVMAP_BLENDING_MULTIPLY";
                        break;
                    case THREE.MixOperation:
                        u = "ENVMAP_BLENDING_MIX";
                        break;
                    case THREE.AddOperation:
                        u = "ENVMAP_BLENDING_ADD"
                }
            }
            var v, w, x = i.gammaFactor > 0 ? i.gammaFactor : 1,
                y = a(n, l, i.extensions),
                z = b(o),
                A = m.createProgram();
            k instanceof THREE.RawShaderMaterial ? (v = "", w = "") : (v = ["precision " + l.precision + " float;", "precision " + l.precision + " int;", "#define SHADER_NAME " + k.__webglShader.name, z, l.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", i.gammaInput ? "#define GAMMA_INPUT" : "", i.gammaOutput ? "#define GAMMA_OUTPUT" : "", "#define GAMMA_FACTOR " + x, "#define MAX_BONES " + l.maxBones, l.map ? "#define USE_MAP" : "", l.envMap ? "#define USE_ENVMAP" : "", l.envMap ? "#define " + t : "", l.lightMap ? "#define USE_LIGHTMAP" : "", l.aoMap ? "#define USE_AOMAP" : "", l.emissiveMap ? "#define USE_EMISSIVEMAP" : "", l.bumpMap ? "#define USE_BUMPMAP" : "", l.normalMap ? "#define USE_NORMALMAP" : "", l.displacementMap && l.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", l.specularMap ? "#define USE_SPECULARMAP" : "", l.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", l.metalnessMap ? "#define USE_METALNESSMAP" : "", l.alphaMap ? "#define USE_ALPHAMAP" : "", l.vertexColors ? "#define USE_COLOR" : "", l.flatShading ? "#define FLAT_SHADED" : "", l.skinning ? "#define USE_SKINNING" : "", l.useVertexTexture ? "#define BONE_TEXTURE" : "", l.morphTargets ? "#define USE_MORPHTARGETS" : "", l.morphNormals && l.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", l.doubleSided ? "#define DOUBLE_SIDED" : "", l.flipSided ? "#define FLIP_SIDED" : "", l.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", l.shadowMapEnabled ? "#define " + r : "", l.pointLightShadows > 0 ? "#define POINT_LIGHT_SHADOWS" : "", l.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", l.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", l.logarithmicDepthBuffer && i.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "	attribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", "\n"].filter(e).join("\n"), w = [y, "precision " + l.precision + " float;", "precision " + l.precision + " int;", "#define SHADER_NAME " + k.__webglShader.name, z, l.alphaTest ? "#define ALPHATEST " + l.alphaTest : "", i.gammaInput ? "#define GAMMA_INPUT" : "", i.gammaOutput ? "#define GAMMA_OUTPUT" : "", "#define GAMMA_FACTOR " + x, l.useFog && l.fog ? "#define USE_FOG" : "", l.useFog && l.fogExp ? "#define FOG_EXP2" : "", l.map ? "#define USE_MAP" : "", l.envMap ? "#define USE_ENVMAP" : "", l.envMap ? "#define " + s : "", l.envMap ? "#define " + t : "", l.envMap ? "#define " + u : "", l.lightMap ? "#define USE_LIGHTMAP" : "", l.aoMap ? "#define USE_AOMAP" : "", l.emissiveMap ? "#define USE_EMISSIVEMAP" : "", l.bumpMap ? "#define USE_BUMPMAP" : "", l.normalMap ? "#define USE_NORMALMAP" : "", l.specularMap ? "#define USE_SPECULARMAP" : "", l.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", l.metalnessMap ? "#define USE_METALNESSMAP" : "", l.alphaMap ? "#define USE_ALPHAMAP" : "", l.vertexColors ? "#define USE_COLOR" : "", l.flatShading ? "#define FLAT_SHADED" : "", l.doubleSided ? "#define DOUBLE_SIDED" : "", l.flipSided ? "#define FLIP_SIDED" : "", l.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", l.shadowMapEnabled ? "#define " + r : "", l.pointLightShadows > 0 ? "#define POINT_LIGHT_SHADOWS" : "", l.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", l.logarithmicDepthBuffer && i.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", l.envMap && i.extensions.get("EXT_shader_texture_lod") ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "\n"].filter(e).join("\n")), p = f(p, l), q = f(q, l), k instanceof THREE.ShaderMaterial == !1 && (p = g(p), q = g(q));
            var B = v + p,
                C = w + q,
                D = THREE.WebGLShader(m, m.VERTEX_SHADER, B),
                E = THREE.WebGLShader(m, m.FRAGMENT_SHADER, C);
            m.attachShader(A, D), m.attachShader(A, E),
                // Force a particular attribute to index 0.
                void 0 !== k.index0AttributeName ? m.bindAttribLocation(A, 0, k.index0AttributeName) : l.morphTargets === !0 &&
                // programs with morphTargets displace position out of attribute 0
                m.bindAttribLocation(A, 0, "position"), m.linkProgram(A);
            var F = m.getProgramInfoLog(A),
                G = m.getShaderInfoLog(D),
                H = m.getShaderInfoLog(E),
                I = !0,
                J = !0;
            // console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
            // console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );
            m.getProgramParameter(A, m.LINK_STATUS) === !1 ? (I = !1, console.error("THREE.WebGLProgram: shader error: ", m.getError(), "gl.VALIDATE_STATUS", m.getProgramParameter(A, m.VALIDATE_STATUS), "gl.getProgramInfoLog", F, G, H)) : "" !== F ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", F) : "" !== G && "" !== H || (J = !1), J && (this.diagnostics = {
                    runnable: I,
                    material: k,
                    programLog: F,
                    vertexShader: {
                        log: G,
                        prefix: v
                    },
                    fragmentShader: {
                        log: H,
                        prefix: w
                    }
                }),
                // clean up
                m.deleteShader(D), m.deleteShader(E);
            // set up caching for uniform locations
            var K;
            this.getUniforms = function() {
                return void 0 === K && (K = c(m, A)), K
            };
            // set up caching for attribute locations
            var L;
            // free resource
            // DEPRECATED
            //
            return this.getAttributes = function() {
                return void 0 === L && (L = d(m, A)), L
            }, this.destroy = function() {
                m.deleteProgram(A), this.program = void 0
            }, Object.defineProperties(this, {
                uniforms: {
                    get: function() {
                        return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms()
                    }
                },
                attributes: {
                    get: function() {
                        return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."), this.getAttributes()
                    }
                }
            }), this.id = h++, this.code = j, this.usedTimes = 1, this.program = A, this.vertexShader = D, this.fragmentShader = E, this
        }
    }(),
    // File:src/renderers/webgl/WebGLPrograms.js
    THREE.WebGLPrograms = function(a, b) {
        function c(a) {
            if (b.floatVertexTextures && a && a.skeleton && a.skeleton.useVertexTexture) return 1024;
            // default for when object is not specified
            // ( for example when prebuilding shader to be used with multiple objects )
            //
            //  - leave some extra space for other uniforms
            //  - limit here is ANGLE's 254 max uniform vectors
            //    (up to 54 should be safe)
            var c = b.maxVertexUniforms,
                d = Math.floor((c - 20) / 4),
                e = d;
            return void 0 !== a && a instanceof THREE.SkinnedMesh && (e = Math.min(a.skeleton.bones.length, e), e < a.skeleton.bones.length && console.warn("WebGLRenderer: too many bones - " + a.skeleton.bones.length + ", this GPU supports just " + e + " (try OpenGL instead of ANGLE)")), e
        }
        var d = [],
            e = {
                MeshDepthMaterial: "depth",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                MeshStandardMaterial: "standard",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointsMaterial: "points"
            },
            f = ["precision", "supportsVertexTextures", "map", "envMap", "envMapMode", "lightMap", "aoMap", "emissiveMap", "bumpMap", "normalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "shadowMapEnabled", "pointLightShadows", "shadowMapType", "alphaTest", "doubleSided", "flipSided"];
        this.getParameters = function(d, f, g, h) {
                var i = e[d.type],
                    j = c(h),
                    k = a.getPrecision();
                null !== d.precision && (k = b.getMaxPrecision(d.precision), k !== d.precision && console.warn("THREE.WebGLProgram.getParameters:", d.precision, "not supported, using", k, "instead."));
                var l = {
                    shaderID: i,
                    precision: k,
                    supportsVertexTextures: b.vertexTextures,
                    map: !!d.map,
                    envMap: !!d.envMap,
                    envMapMode: d.envMap && d.envMap.mapping,
                    lightMap: !!d.lightMap,
                    aoMap: !!d.aoMap,
                    emissiveMap: !!d.emissiveMap,
                    bumpMap: !!d.bumpMap,
                    normalMap: !!d.normalMap,
                    displacementMap: !!d.displacementMap,
                    roughnessMap: !!d.roughnessMap,
                    metalnessMap: !!d.metalnessMap,
                    specularMap: !!d.specularMap,
                    alphaMap: !!d.alphaMap,
                    combine: d.combine,
                    vertexColors: d.vertexColors,
                    fog: g,
                    useFog: d.fog,
                    fogExp: g instanceof THREE.FogExp2,
                    flatShading: d.shading === THREE.FlatShading,
                    sizeAttenuation: d.sizeAttenuation,
                    logarithmicDepthBuffer: b.logarithmicDepthBuffer,
                    skinning: d.skinning,
                    maxBones: j,
                    useVertexTexture: b.floatVertexTextures && h && h.skeleton && h.skeleton.useVertexTexture,
                    morphTargets: d.morphTargets,
                    morphNormals: d.morphNormals,
                    maxMorphTargets: a.maxMorphTargets,
                    maxMorphNormals: a.maxMorphNormals,
                    numDirLights: f.directional.length,
                    numPointLights: f.point.length,
                    numSpotLights: f.spot.length,
                    numHemiLights: f.hemi.length,
                    pointLightShadows: f.shadowsPointLight,
                    shadowMapEnabled: a.shadowMap.enabled && h.receiveShadow && f.shadows.length > 0,
                    shadowMapType: a.shadowMap.type,
                    alphaTest: d.alphaTest,
                    doubleSided: d.side === THREE.DoubleSide,
                    flipSided: d.side === THREE.BackSide
                };
                return l
            }, this.getProgramCode = function(a, b) {
                var c = [];
                if (b.shaderID ? c.push(b.shaderID) : (c.push(a.fragmentShader), c.push(a.vertexShader)), void 0 !== a.defines)
                    for (var d in a.defines) c.push(d), c.push(a.defines[d]);
                for (var e = 0; e < f.length; e++) {
                    var g = f[e];
                    c.push(g), c.push(b[g])
                }
                return c.join()
            }, this.acquireProgram = function(b, c, e) {
                // Check if code has been already compiled
                for (var f, g = 0, h = d.length; h > g; g++) {
                    var i = d[g];
                    if (i.code === e) {
                        f = i, ++f.usedTimes;
                        break
                    }
                }
                return void 0 === f && (f = new THREE.WebGLProgram(a, e, b, c), d.push(f)), f
            }, this.releaseProgram = function(a) {
                if (0 === --a.usedTimes) {
                    // Remove from unordered set
                    var b = d.indexOf(a);
                    d[b] = d[d.length - 1], d.pop(),
                        // Free WebGL resources
                        a.destroy()
                }
            },
            // Exposed for resource monitoring & error feedback via renderer.info:
            this.programs = d
    },
    // File:src/renderers/webgl/WebGLProperties.js
    /**
     * @author fordacious / fordacious.github.io
     */
    THREE.WebGLProperties = function() {
        var a = {};
        this.get = function(b) {
            var c = b.uuid,
                d = a[c];
            return void 0 === d && (d = {}, a[c] = d), d
        }, this["delete"] = function(b) {
            delete a[b.uuid]
        }, this.clear = function() {
            a = {}
        }
    },
    // File:src/renderers/webgl/WebGLShader.js
    THREE.WebGLShader = function() {
        function a(a) {
            for (var b = a.split("\n"), c = 0; c < b.length; c++) b[c] = c + 1 + ": " + b[c];
            return b.join("\n")
        }
        return function(b, c, d) {
            var e = b.createShader(c);
            // --enable-privileged-webgl-extension
            // console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );
            return b.shaderSource(e, d), b.compileShader(e), b.getShaderParameter(e, b.COMPILE_STATUS) === !1 && console.error("THREE.WebGLShader: Shader couldn't compile."), "" !== b.getShaderInfoLog(e) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", c === b.VERTEX_SHADER ? "vertex" : "fragment", b.getShaderInfoLog(e), a(d)), e
        }
    }(),
    // File:src/renderers/webgl/WebGLShadowMap.js
    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.WebGLShadowMap = function(a, b, c) {
        function d(a, b, c, d) {
            var e = a.geometry,
                f = null,
                g = p,
                h = a.customDepthMaterial;
            if (c && (g = q, h = a.customDistanceMaterial), h) f = h;
            else {
                var i = void 0 !== e.morphTargets && e.morphTargets.length > 0 && b.morphTargets,
                    j = a instanceof THREE.SkinnedMesh && b.skinning,
                    k = 0;
                i && (k |= m), j && (k |= n), f = g[k]
            }
            return f.visible = b.visible, f.wireframe = b.wireframe, f.wireframeLinewidth = b.wireframeLinewidth, c && void 0 !== f.uniforms.lightPos && f.uniforms.lightPos.value.copy(d), f
        }

        function e(a, b, c) {
            if (a.visible !== !1) {
                if (a.layers.test(b.layers) && (a instanceof THREE.Mesh || a instanceof THREE.Line || a instanceof THREE.Points) && a.castShadow && (a.frustumCulled === !1 || h.intersectsObject(a) === !0)) {
                    var d = a.material;
                    d.visible === !0 && (a.modelViewMatrix.multiplyMatrices(c.matrixWorldInverse, a.matrixWorld), l.push(a))
                }
                for (var f = a.children, g = 0, i = f.length; i > g; g++) e(f[g], b, c)
            }
        }
        for (var f = a.context, g = a.state, h = new THREE.Frustum, i = new THREE.Matrix4, j = new THREE.Vector3, k = new THREE.Vector3, l = [], m = 1, n = 2, o = (m | n) + 1, p = new Array(o), q = new Array(o), r = [new THREE.Vector3(1, 0, 0), new THREE.Vector3(-1, 0, 0), new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, -1), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, -1, 0)], s = [new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, -1)], t = [new THREE.Vector4, new THREE.Vector4, new THREE.Vector4, new THREE.Vector4, new THREE.Vector4, new THREE.Vector4], u = THREE.ShaderLib.depthRGBA, v = THREE.UniformsUtils.clone(u.uniforms), w = THREE.ShaderLib.distanceRGBA, x = THREE.UniformsUtils.clone(w.uniforms), y = 0; y !== o; ++y) {
            var z = 0 !== (y & m),
                A = 0 !== (y & n),
                B = new THREE.ShaderMaterial({
                    uniforms: v,
                    vertexShader: u.vertexShader,
                    fragmentShader: u.fragmentShader,
                    morphTargets: z,
                    skinning: A
                });
            B._shadowPass = !0, p[y] = B;
            var C = new THREE.ShaderMaterial({
                uniforms: x,
                vertexShader: w.vertexShader,
                fragmentShader: w.fragmentShader,
                morphTargets: z,
                skinning: A
            });
            C._shadowPass = !0, q[y] = C
        }
        //
        var D = this;
        this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = THREE.PCFShadowMap, this.cullFace = THREE.CullFaceFront, this.render = function(m, n) {
            var o, p;
            if (D.enabled !== !1 && (D.autoUpdate !== !1 || D.needsUpdate !== !1)) {
                // Set GL state for depth map.
                g.clearColor(1, 1, 1, 1), g.disable(f.BLEND), g.enable(f.CULL_FACE), f.frontFace(f.CCW), f.cullFace(D.cullFace === THREE.CullFaceFront ? f.FRONT : f.BACK), g.setDepthTest(!0), g.setScissorTest(!1);
                for (var q = b.shadows, u = 0, v = q.length; v > u; u++) {
                    var w = q[u],
                        x = w.shadow,
                        y = x.camera,
                        z = x.mapSize;
                    if (w instanceof THREE.PointLight) {
                        o = 6, p = !0;
                        var A = z.x / 4,
                            B = z.y / 2;
                        // These viewports map a cube-map onto a 2D texture with the
                        // following orientation:
                        //
                        //  xzXZ
                        //   y Y
                        //
                        // X - Positive x direction
                        // x - Negative x direction
                        // Y - Positive y direction
                        // y - Negative y direction
                        // Z - Positive z direction
                        // z - Negative z direction
                        // positive X
                        t[0].set(2 * A, B, A, B),
                            // negative X
                            t[1].set(0, B, A, B),
                            // positive Z
                            t[2].set(3 * A, B, A, B),
                            // negative Z
                            t[3].set(A, B, A, B),
                            // positive Y
                            t[4].set(3 * A, 0, A, B),
                            // negative Y
                            t[5].set(A, 0, A, B)
                    } else o = 1, p = !1;
                    if (null === x.map) {
                        var C = {
                            minFilter: THREE.LinearFilter,
                            magFilter: THREE.LinearFilter,
                            format: THREE.RGBAFormat
                        };
                        x.map = new THREE.WebGLRenderTarget(z.x, z.y, C),
                            //
                            w instanceof THREE.SpotLight && (y.aspect = z.x / z.y), y.updateProjectionMatrix()
                    }
                    var E = x.map,
                        F = x.matrix;
                    k.setFromMatrixPosition(w.matrixWorld), y.position.copy(k), a.setRenderTarget(E), a.clear();
                    // render shadow map for each cube face (if omni-directional) or
                    // run a single pass if not
                    for (var G = 0; o > G; G++) {
                        if (p) {
                            j.copy(y.position), j.add(r[G]), y.up.copy(s[G]), y.lookAt(j);
                            var H = t[G];
                            g.viewport(H)
                        } else j.setFromMatrixPosition(w.target.matrixWorld), y.lookAt(j);
                        y.updateMatrixWorld(), y.matrixWorldInverse.getInverse(y.matrixWorld),
                            // compute shadow matrix
                            F.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), F.multiply(y.projectionMatrix), F.multiply(y.matrixWorldInverse),
                            // update camera matrices and frustum
                            i.multiplyMatrices(y.projectionMatrix, y.matrixWorldInverse), h.setFromMatrix(i),
                            // set object matrices & frustum culling
                            l.length = 0, e(m, n, y);
                        // render shadow map
                        // render regular objects
                        for (var I = 0, J = l.length; J > I; I++) {
                            var K = l[I],
                                L = c.update(K),
                                M = K.material;
                            if (M instanceof THREE.MultiMaterial)
                                for (var N = L.groups, O = M.materials, P = 0, Q = N.length; Q > P; P++) {
                                    var R = N[P],
                                        S = O[R.materialIndex];
                                    if (S.visible === !0) {
                                        var T = d(K, S, p, k);
                                        a.renderBufferDirect(y, null, L, T, K, R)
                                    }
                                } else {
                                    var T = d(K, M, p, k);
                                    a.renderBufferDirect(y, null, L, T, K, null)
                                }
                        }
                    }
                    // We must call _renderer.resetGLState() at the end of each iteration of
                    // the light loop in order to force material updates for each light.
                    a.resetGLState()
                }
                // Restore GL state.
                var U = a.getClearColor(),
                    V = a.getClearAlpha();
                a.setClearColor(U, V), g.enable(f.BLEND), D.cullFace === THREE.CullFaceFront && f.cullFace(f.BACK), a.resetGLState(), D.needsUpdate = !1
            }
        }
    },
    // File:src/renderers/webgl/WebGLState.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.WebGLState = function(a, b, c) {
        var d = this,
            e = new THREE.Vector4,
            f = new Uint8Array(16),
            g = new Uint8Array(16),
            h = new Uint8Array(16),
            i = {},
            j = null,
            k = null,
            l = null,
            m = null,
            n = null,
            o = null,
            p = null,
            q = null,
            r = null,
            s = null,
            t = null,
            u = null,
            v = null,
            w = null,
            x = null,
            y = null,
            z = null,
            A = null,
            B = null,
            C = null,
            D = null,
            E = null,
            F = null,
            G = a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS),
            H = void 0,
            I = {},
            J = new THREE.Vector4,
            K = null,
            L = null,
            M = new THREE.Vector4,
            N = new THREE.Vector4;
        this.init = function() {
                this.clearColor(0, 0, 0, 1), this.clearDepth(1), this.clearStencil(0), this.enable(a.DEPTH_TEST), a.depthFunc(a.LEQUAL), a.frontFace(a.CCW), a.cullFace(a.BACK), this.enable(a.CULL_FACE), this.enable(a.BLEND), a.blendEquation(a.FUNC_ADD), a.blendFunc(a.SRC_ALPHA, a.ONE_MINUS_SRC_ALPHA)
            }, this.initAttributes = function() {
                for (var a = 0, b = f.length; b > a; a++) f[a] = 0
            }, this.enableAttribute = function(c) {
                if (f[c] = 1, 0 === g[c] && (a.enableVertexAttribArray(c), g[c] = 1), 0 !== h[c]) {
                    var d = b.get("ANGLE_instanced_arrays");
                    d.vertexAttribDivisorANGLE(c, 0), h[c] = 0
                }
            }, this.enableAttributeAndDivisor = function(b, c, d) {
                f[b] = 1, 0 === g[b] && (a.enableVertexAttribArray(b), g[b] = 1), h[b] !== c && (d.vertexAttribDivisorANGLE(b, c), h[b] = c)
            }, this.disableUnusedAttributes = function() {
                for (var b = 0, c = g.length; c > b; b++) g[b] !== f[b] && (a.disableVertexAttribArray(b), g[b] = 0)
            }, this.enable = function(b) {
                i[b] !== !0 && (a.enable(b), i[b] = !0)
            }, this.disable = function(b) {
                i[b] !== !1 && (a.disable(b), i[b] = !1)
            }, this.getCompressedTextureFormats = function() {
                if (null === j && (j = [], b.get("WEBGL_compressed_texture_pvrtc") || b.get("WEBGL_compressed_texture_s3tc") || b.get("WEBGL_compressed_texture_etc1")))
                    for (var c = a.getParameter(a.COMPRESSED_TEXTURE_FORMATS), d = 0; d < c.length; d++) j.push(c[d]);
                return j
            }, this.setBlending = function(b, d, e, f, g, h, i) {
                b === THREE.NoBlending ? this.disable(a.BLEND) : this.enable(a.BLEND), b !== k && (b === THREE.AdditiveBlending ? (a.blendEquation(a.FUNC_ADD), a.blendFunc(a.SRC_ALPHA, a.ONE)) : b === THREE.SubtractiveBlending ? (
                    // TODO: Find blendFuncSeparate() combination
                    a.blendEquation(a.FUNC_ADD), a.blendFunc(a.ZERO, a.ONE_MINUS_SRC_COLOR)) : b === THREE.MultiplyBlending ? (
                    // TODO: Find blendFuncSeparate() combination
                    a.blendEquation(a.FUNC_ADD), a.blendFunc(a.ZERO, a.SRC_COLOR)) : (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.SRC_ALPHA, a.ONE_MINUS_SRC_ALPHA, a.ONE, a.ONE_MINUS_SRC_ALPHA)), k = b), b === THREE.CustomBlending ? (g = g || d, h = h || e, i = i || f, d === l && g === o || (a.blendEquationSeparate(c(d), c(g)), l = d, o = g), e === m && f === n && h === p && i === q || (a.blendFuncSeparate(c(e), c(f), c(h), c(i)), m = e, n = f, p = h, q = i)) : (l = null, m = null, n = null, o = null, p = null, q = null)
            }, this.setDepthFunc = function(b) {
                if (r !== b) {
                    if (b) switch (b) {
                        case THREE.NeverDepth:
                            a.depthFunc(a.NEVER);
                            break;
                        case THREE.AlwaysDepth:
                            a.depthFunc(a.ALWAYS);
                            break;
                        case THREE.LessDepth:
                            a.depthFunc(a.LESS);
                            break;
                        case THREE.LessEqualDepth:
                            a.depthFunc(a.LEQUAL);
                            break;
                        case THREE.EqualDepth:
                            a.depthFunc(a.EQUAL);
                            break;
                        case THREE.GreaterEqualDepth:
                            a.depthFunc(a.GEQUAL);
                            break;
                        case THREE.GreaterDepth:
                            a.depthFunc(a.GREATER);
                            break;
                        case THREE.NotEqualDepth:
                            a.depthFunc(a.NOTEQUAL);
                            break;
                        default:
                            a.depthFunc(a.LEQUAL)
                    } else a.depthFunc(a.LEQUAL);
                    r = b
                }
            }, this.setDepthTest = function(b) {
                b ? this.enable(a.DEPTH_TEST) : this.disable(a.DEPTH_TEST)
            }, this.setDepthWrite = function(b) {
                // TODO: Rename to setDepthMask
                s !== b && (a.depthMask(b), s = b)
            }, this.setColorWrite = function(b) {
                // TODO: Rename to setColorMask
                t !== b && (a.colorMask(b, b, b, b), t = b)
            }, this.setStencilFunc = function(b, c, d) {
                v === b && w === c && x === d || (a.stencilFunc(b, c, d), v = b, w = c, x = d)
            }, this.setStencilOp = function(b, c, d) {
                y === b && z === c && A === d || (a.stencilOp(b, c, d), y = b, z = c, A = d)
            }, this.setStencilTest = function(b) {
                b ? this.enable(a.STENCIL_TEST) : this.disable(a.STENCIL_TEST)
            }, this.setStencilWrite = function(b) {
                // TODO: Rename to setStencilMask
                u !== b && (a.stencilMask(b), u = b)
            }, this.setFlipSided = function(b) {
                B !== b && (b ? a.frontFace(a.CW) : a.frontFace(a.CCW), B = b)
            }, this.setLineWidth = function(b) {
                b !== C && (a.lineWidth(b), C = b)
            }, this.setPolygonOffset = function(b, c, d) {
                b ? this.enable(a.POLYGON_OFFSET_FILL) : this.disable(a.POLYGON_OFFSET_FILL), !b || D === c && E === d || (a.polygonOffset(c, d), D = c, E = d)
            }, this.getScissorTest = function() {
                return F
            }, this.setScissorTest = function(b) {
                F = b, b ? this.enable(a.SCISSOR_TEST) : this.disable(a.SCISSOR_TEST)
            },
            // texture
            this.activeTexture = function(b) {
                void 0 === b && (b = a.TEXTURE0 + G - 1), H !== b && (a.activeTexture(b), H = b)
            }, this.bindTexture = function(b, c) {
                void 0 === H && d.activeTexture();
                var e = I[H];
                void 0 === e && (e = {
                    type: void 0,
                    texture: void 0
                }, I[H] = e), e.type === b && e.texture === c || (a.bindTexture(b, c), e.type = b, e.texture = c)
            }, this.compressedTexImage2D = function() {
                try {
                    a.compressedTexImage2D.apply(a, arguments)
                } catch (b) {
                    console.error(b)
                }
            }, this.texImage2D = function() {
                try {
                    a.texImage2D.apply(a, arguments)
                } catch (b) {
                    console.error(b)
                }
            },
            // clear values
            this.clearColor = function(b, c, d, f) {
                e.set(b, c, d, f), J.equals(e) === !1 && (a.clearColor(b, c, d, f), J.copy(e))
            }, this.clearDepth = function(b) {
                K !== b && (a.clearDepth(b), K = b)
            }, this.clearStencil = function(b) {
                L !== b && (a.clearStencil(b), L = b)
            },
            //
            this.scissor = function(b) {
                M.equals(b) === !1 && (a.scissor(b.x, b.y, b.z, b.w), M.copy(b))
            }, this.viewport = function(b) {
                N.equals(b) === !1 && (a.viewport(b.x, b.y, b.z, b.w), N.copy(b))
            },
            //
            this.reset = function() {
                for (var b = 0; b < g.length; b++) 1 === g[b] && (a.disableVertexAttribArray(b), g[b] = 0);
                i = {}, j = null, k = null, t = null, s = null, u = null, B = null
            }
    },
    // File:src/renderers/webgl/plugins/LensFlarePlugin.js
    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     */
    THREE.LensFlarePlugin = function(a, b) {
        function c() {
            var a = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1]),
                b = new Uint16Array([0, 1, 2, 0, 2, 3]);
            e = m.createBuffer(), f = m.createBuffer(), m.bindBuffer(m.ARRAY_BUFFER, e), m.bufferData(m.ARRAY_BUFFER, a, m.STATIC_DRAW), m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, f), m.bufferData(m.ELEMENT_ARRAY_BUFFER, b, m.STATIC_DRAW), k = m.createTexture(), l = m.createTexture(), n.bindTexture(m.TEXTURE_2D, k), m.texImage2D(m.TEXTURE_2D, 0, m.RGB, 16, 16, 0, m.RGB, m.UNSIGNED_BYTE, null), m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_S, m.CLAMP_TO_EDGE), m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_T, m.CLAMP_TO_EDGE), m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MAG_FILTER, m.NEAREST), m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MIN_FILTER, m.NEAREST), n.bindTexture(m.TEXTURE_2D, l), m.texImage2D(m.TEXTURE_2D, 0, m.RGBA, 16, 16, 0, m.RGBA, m.UNSIGNED_BYTE, null), m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_S, m.CLAMP_TO_EDGE), m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_T, m.CLAMP_TO_EDGE), m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MAG_FILTER, m.NEAREST), m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MIN_FILTER, m.NEAREST), j = m.getParameter(m.MAX_VERTEX_TEXTURE_IMAGE_UNITS) > 0;
            var c;
            c = j ? {
                vertexShader: ["uniform lowp int renderType;", "uniform vec3 screenPosition;", "uniform vec2 scale;", "uniform float rotation;", "uniform sampler2D occlusionMap;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "vUV = uv;", "vec2 pos = position;", "if ( renderType == 2 ) {", "vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );", "vVisibility =        visibility.r / 9.0;", "vVisibility *= 1.0 - visibility.g / 9.0;", "vVisibility *=       visibility.b / 9.0;", "vVisibility *= 1.0 - visibility.a / 9.0;", "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;", "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;", "}", "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );", "}"].join("\n"),
                fragmentShader: ["uniform lowp int renderType;", "uniform sampler2D map;", "uniform float opacity;", "uniform vec3 color;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {",
                    // pink square
                    "if ( renderType == 0 ) {", "gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",
                    // restore
                    "} else if ( renderType == 1 ) {", "gl_FragColor = texture2D( map, vUV );",
                    // flare
                    "} else {", "vec4 texture = texture2D( map, vUV );", "texture.a *= opacity * vVisibility;", "gl_FragColor = texture;", "gl_FragColor.rgb *= color;", "}", "}"
                ].join("\n")
            } : {
                vertexShader: ["uniform lowp int renderType;", "uniform vec3 screenPosition;", "uniform vec2 scale;", "uniform float rotation;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "void main() {", "vUV = uv;", "vec2 pos = position;", "if ( renderType == 2 ) {", "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;", "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;", "}", "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );", "}"].join("\n"),
                fragmentShader: ["precision mediump float;", "uniform lowp int renderType;", "uniform sampler2D map;", "uniform sampler2D occlusionMap;", "uniform float opacity;", "uniform vec3 color;", "varying vec2 vUV;", "void main() {",
                    // pink square
                    "if ( renderType == 0 ) {", "gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );",
                    // restore
                    "} else if ( renderType == 1 ) {", "gl_FragColor = texture2D( map, vUV );",
                    // flare
                    "} else {", "float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;", "visibility = ( 1.0 - visibility / 4.0 );", "vec4 texture = texture2D( map, vUV );", "texture.a *= opacity * visibility;", "gl_FragColor = texture;", "gl_FragColor.rgb *= color;", "}", "}"
                ].join("\n")
            }, g = d(c), h = {
                vertex: m.getAttribLocation(g, "position"),
                uv: m.getAttribLocation(g, "uv")
            }, i = {
                renderType: m.getUniformLocation(g, "renderType"),
                map: m.getUniformLocation(g, "map"),
                occlusionMap: m.getUniformLocation(g, "occlusionMap"),
                opacity: m.getUniformLocation(g, "opacity"),
                color: m.getUniformLocation(g, "color"),
                scale: m.getUniformLocation(g, "scale"),
                rotation: m.getUniformLocation(g, "rotation"),
                screenPosition: m.getUniformLocation(g, "screenPosition")
            }
        }

        function d(b) {
            var c = m.createProgram(),
                d = m.createShader(m.FRAGMENT_SHADER),
                e = m.createShader(m.VERTEX_SHADER),
                f = "precision " + a.getPrecision() + " float;\n";
            return m.shaderSource(d, f + b.fragmentShader), m.shaderSource(e, f + b.vertexShader), m.compileShader(d), m.compileShader(e), m.attachShader(c, d), m.attachShader(c, e), m.linkProgram(c), c
        }
        var e, f, g, h, i, j, k, l, m = a.context,
            n = a.state;
        /*
         * Render lens flares
         * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
         *         reads these back and calculates occlusion.
         */
        this.render = function(d, o, p) {
            if (0 !== b.length) {
                var q = new THREE.Vector3,
                    r = p.w / p.z,
                    s = .5 * p.z,
                    t = .5 * p.w,
                    u = 16 / p.w,
                    v = new THREE.Vector2(u * r, u),
                    w = new THREE.Vector3(1, 1, 0),
                    x = new THREE.Vector2(1, 1);
                void 0 === g && c(), m.useProgram(g), n.initAttributes(), n.enableAttribute(h.vertex), n.enableAttribute(h.uv), n.disableUnusedAttributes(),
                    // loop through all lens flares to update their occlusion and positions
                    // setup gl and common used attribs/uniforms
                    m.uniform1i(i.occlusionMap, 0), m.uniform1i(i.map, 1), m.bindBuffer(m.ARRAY_BUFFER, e), m.vertexAttribPointer(h.vertex, 2, m.FLOAT, !1, 16, 0), m.vertexAttribPointer(h.uv, 2, m.FLOAT, !1, 16, 8), m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, f), n.disable(m.CULL_FACE), n.setDepthWrite(!1);
                for (var y = 0, z = b.length; z > y; y++) {
                    u = 16 / p.w, v.set(u * r, u);
                    // calc object screen position
                    var A = b[y];
                    // screen cull
                    if (q.set(A.matrixWorld.elements[12], A.matrixWorld.elements[13], A.matrixWorld.elements[14]), q.applyMatrix4(o.matrixWorldInverse), q.applyProjection(o.projectionMatrix),
                        // setup arrays for gl programs
                        w.copy(q), x.x = w.x * s + s, x.y = w.y * t + t, j || x.x > 0 && x.x < p.z && x.y > 0 && x.y < p.w) {
                        // save current RGB to temp texture
                        n.activeTexture(m.TEXTURE0), n.bindTexture(m.TEXTURE_2D, null), n.activeTexture(m.TEXTURE1), n.bindTexture(m.TEXTURE_2D, k), m.copyTexImage2D(m.TEXTURE_2D, 0, m.RGB, p.x + x.x - 8, p.y + x.y - 8, 16, 16, 0),
                            // render pink quad
                            m.uniform1i(i.renderType, 0), m.uniform2f(i.scale, v.x, v.y), m.uniform3f(i.screenPosition, w.x, w.y, w.z), n.disable(m.BLEND), n.enable(m.DEPTH_TEST), m.drawElements(m.TRIANGLES, 6, m.UNSIGNED_SHORT, 0),
                            // copy result to occlusionMap
                            n.activeTexture(m.TEXTURE0), n.bindTexture(m.TEXTURE_2D, l), m.copyTexImage2D(m.TEXTURE_2D, 0, m.RGBA, p.x + x.x - 8, p.y + x.y - 8, 16, 16, 0),
                            // restore graphics
                            m.uniform1i(i.renderType, 1), n.disable(m.DEPTH_TEST), n.activeTexture(m.TEXTURE1), n.bindTexture(m.TEXTURE_2D, k), m.drawElements(m.TRIANGLES, 6, m.UNSIGNED_SHORT, 0),
                            // update object positions
                            A.positionScreen.copy(w), A.customUpdateCallback ? A.customUpdateCallback(A) : A.updateLensFlares(),
                            // render flares
                            m.uniform1i(i.renderType, 2), n.enable(m.BLEND);
                        for (var B = 0, C = A.lensFlares.length; C > B; B++) {
                            var D = A.lensFlares[B];
                            D.opacity > .001 && D.scale > .001 && (w.x = D.x, w.y = D.y, w.z = D.z, u = D.size * D.scale / p.w, v.x = u * r, v.y = u, m.uniform3f(i.screenPosition, w.x, w.y, w.z), m.uniform2f(i.scale, v.x, v.y), m.uniform1f(i.rotation, D.rotation), m.uniform1f(i.opacity, D.opacity), m.uniform3f(i.color, D.color.r, D.color.g, D.color.b), n.setBlending(D.blending, D.blendEquation, D.blendSrc, D.blendDst), a.setTexture(D.texture, 1), m.drawElements(m.TRIANGLES, 6, m.UNSIGNED_SHORT, 0))
                        }
                    }
                }
                // restore gl
                n.enable(m.CULL_FACE), n.enable(m.DEPTH_TEST), n.setDepthWrite(!0), a.resetGLState()
            }
        }
    },
    // File:src/renderers/webgl/plugins/SpritePlugin.js
    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     */
    THREE.SpritePlugin = function(a, b) {
        function c() {
            var a = new Float32Array([-.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1]),
                b = new Uint16Array([0, 1, 2, 0, 2, 3]);
            f = l.createBuffer(), g = l.createBuffer(), l.bindBuffer(l.ARRAY_BUFFER, f), l.bufferData(l.ARRAY_BUFFER, a, l.STATIC_DRAW), l.bindBuffer(l.ELEMENT_ARRAY_BUFFER, g), l.bufferData(l.ELEMENT_ARRAY_BUFFER, b, l.STATIC_DRAW), h = d(), i = {
                position: l.getAttribLocation(h, "position"),
                uv: l.getAttribLocation(h, "uv")
            }, j = {
                uvOffset: l.getUniformLocation(h, "uvOffset"),
                uvScale: l.getUniformLocation(h, "uvScale"),
                rotation: l.getUniformLocation(h, "rotation"),
                scale: l.getUniformLocation(h, "scale"),
                color: l.getUniformLocation(h, "color"),
                map: l.getUniformLocation(h, "map"),
                opacity: l.getUniformLocation(h, "opacity"),
                modelViewMatrix: l.getUniformLocation(h, "modelViewMatrix"),
                projectionMatrix: l.getUniformLocation(h, "projectionMatrix"),
                fogType: l.getUniformLocation(h, "fogType"),
                fogDensity: l.getUniformLocation(h, "fogDensity"),
                fogNear: l.getUniformLocation(h, "fogNear"),
                fogFar: l.getUniformLocation(h, "fogFar"),
                fogColor: l.getUniformLocation(h, "fogColor"),
                alphaTest: l.getUniformLocation(h, "alphaTest")
            };
            var c = document.createElement("canvas");
            c.width = 8, c.height = 8;
            var e = c.getContext("2d");
            e.fillStyle = "white", e.fillRect(0, 0, 8, 8), k = new THREE.Texture(c), k.needsUpdate = !0
        }

        function d() {
            var b = l.createProgram(),
                c = l.createShader(l.VERTEX_SHADER),
                d = l.createShader(l.FRAGMENT_SHADER);
            return l.shaderSource(c, ["precision " + a.getPrecision() + " float;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform float rotation;", "uniform vec2 scale;", "uniform vec2 uvOffset;", "uniform vec2 uvScale;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "void main() {", "vUV = uvOffset + uv * uvScale;", "vec2 alignedPosition = position * scale;", "vec2 rotatedPosition;", "rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;", "rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;", "vec4 finalPosition;", "finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );", "finalPosition.xy += rotatedPosition;", "finalPosition = projectionMatrix * finalPosition;", "gl_Position = finalPosition;", "}"].join("\n")), l.shaderSource(d, ["precision " + a.getPrecision() + " float;", "uniform vec3 color;", "uniform sampler2D map;", "uniform float opacity;", "uniform int fogType;", "uniform vec3 fogColor;", "uniform float fogDensity;", "uniform float fogNear;", "uniform float fogFar;", "uniform float alphaTest;", "varying vec2 vUV;", "void main() {", "vec4 texture = texture2D( map, vUV );", "if ( texture.a < alphaTest ) discard;", "gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );", "if ( fogType > 0 ) {", "float depth = gl_FragCoord.z / gl_FragCoord.w;", "float fogFactor = 0.0;", "if ( fogType == 1 ) {", "fogFactor = smoothstep( fogNear, fogFar, depth );", "} else {", "const float LOG2 = 1.442695;", "fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );", "fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );", "}", "gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );", "}", "}"].join("\n")), l.compileShader(c), l.compileShader(d), l.attachShader(b, c), l.attachShader(b, d), l.linkProgram(b), b
        }

        function e(a, b) {
            return a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.z !== b.z ? b.z - a.z : b.id - a.id
        }
        var f, g, h, i, j, k, l = a.context,
            m = a.state,
            n = new THREE.Vector3,
            o = new THREE.Quaternion,
            p = new THREE.Vector3;
        this.render = function(d, q) {
            if (0 !== b.length) {
                // setup gl
                void 0 === h && c(), l.useProgram(h), m.initAttributes(), m.enableAttribute(i.position), m.enableAttribute(i.uv), m.disableUnusedAttributes(), m.disable(l.CULL_FACE), m.enable(l.BLEND), l.bindBuffer(l.ARRAY_BUFFER, f), l.vertexAttribPointer(i.position, 2, l.FLOAT, !1, 16, 0), l.vertexAttribPointer(i.uv, 2, l.FLOAT, !1, 16, 8), l.bindBuffer(l.ELEMENT_ARRAY_BUFFER, g), l.uniformMatrix4fv(j.projectionMatrix, !1, q.projectionMatrix.elements), m.activeTexture(l.TEXTURE0), l.uniform1i(j.map, 0);
                var r = 0,
                    s = 0,
                    t = d.fog;
                t ? (l.uniform3f(j.fogColor, t.color.r, t.color.g, t.color.b), t instanceof THREE.Fog ? (l.uniform1f(j.fogNear, t.near), l.uniform1f(j.fogFar, t.far), l.uniform1i(j.fogType, 1), r = 1, s = 1) : t instanceof THREE.FogExp2 && (l.uniform1f(j.fogDensity, t.density), l.uniform1i(j.fogType, 2), r = 2, s = 2)) : (l.uniform1i(j.fogType, 0), r = 0, s = 0);
                // update positions and sort
                for (var u = 0, v = b.length; v > u; u++) {
                    var w = b[u];
                    w.modelViewMatrix.multiplyMatrices(q.matrixWorldInverse, w.matrixWorld), w.z = -w.modelViewMatrix.elements[14]
                }
                b.sort(e);
                for (var x = [], u = 0, v = b.length; v > u; u++) {
                    var w = b[u],
                        y = w.material;
                    l.uniform1f(j.alphaTest, y.alphaTest), l.uniformMatrix4fv(j.modelViewMatrix, !1, w.modelViewMatrix.elements), w.matrixWorld.decompose(n, o, p), x[0] = p.x, x[1] = p.y;
                    var z = 0;
                    d.fog && y.fog && (z = s), r !== z && (l.uniform1i(j.fogType, z), r = z), null !== y.map ? (l.uniform2f(j.uvOffset, y.map.offset.x, y.map.offset.y), l.uniform2f(j.uvScale, y.map.repeat.x, y.map.repeat.y)) : (l.uniform2f(j.uvOffset, 0, 0), l.uniform2f(j.uvScale, 1, 1)), l.uniform1f(j.opacity, y.opacity), l.uniform3f(j.color, y.color.r, y.color.g, y.color.b), l.uniform1f(j.rotation, y.rotation), l.uniform2fv(j.scale, x), m.setBlending(y.blending, y.blendEquation, y.blendSrc, y.blendDst), m.setDepthTest(y.depthTest), m.setDepthWrite(y.depthWrite), y.map && y.map.image && y.map.image.width ? a.setTexture(y.map, 0) : a.setTexture(k, 0), l.drawElements(l.TRIANGLES, 6, l.UNSIGNED_SHORT, 0)
                }
                // restore gl
                m.enable(l.CULL_FACE), a.resetGLState()
            }
        }
    },
    // File:src/Three.Legacy.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    Object.defineProperties(THREE.Box2.prototype, {
        empty: {
            value: function() {
                return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
            }
        },
        isIntersectionBox: {
            value: function(a) {
                return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(a)
            }
        }
    }), Object.defineProperties(THREE.Box3.prototype, {
        empty: {
            value: function() {
                return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
            }
        },
        isIntersectionBox: {
            value: function(a) {
                return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(a)
            }
        },
        isIntersectionSphere: {
            value: function(a) {
                return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(a)
            }
        }
    }), Object.defineProperties(THREE.Matrix3.prototype, {
        multiplyVector3: {
            value: function(a) {
                return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), a.applyMatrix3(this)
            }
        },
        multiplyVector3Array: {
            value: function(a) {
                return console.warn("THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."), this.applyToVector3Array(a)
            }
        }
    }), Object.defineProperties(THREE.Matrix4.prototype, {
        extractPosition: {
            value: function(a) {
                return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(a)
            }
        },
        setRotationFromQuaternion: {
            value: function(a) {
                return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(a)
            }
        },
        multiplyVector3: {
            value: function(a) {
                return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead."), a.applyProjection(this)
            }
        },
        multiplyVector4: {
            value: function(a) {
                return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), a.applyMatrix4(this)
            }
        },
        multiplyVector3Array: {
            value: function(a) {
                return console.warn("THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."), this.applyToVector3Array(a)
            }
        },
        rotateAxis: {
            value: function(a) {
                console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), a.transformDirection(this)
            }
        },
        crossVector: {
            value: function(a) {
                return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), a.applyMatrix4(this)
            }
        },
        translate: {
            value: function(a) {
                console.error("THREE.Matrix4: .translate() has been removed.")
            }
        },
        rotateX: {
            value: function(a) {
                console.error("THREE.Matrix4: .rotateX() has been removed.")
            }
        },
        rotateY: {
            value: function(a) {
                console.error("THREE.Matrix4: .rotateY() has been removed.")
            }
        },
        rotateZ: {
            value: function(a) {
                console.error("THREE.Matrix4: .rotateZ() has been removed.")
            }
        },
        rotateByAxis: {
            value: function(a, b) {
                console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
            }
        }
    }), Object.defineProperties(THREE.Plane.prototype, {
        isIntersectionLine: {
            value: function(a) {
                return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(a)
            }
        }
    }), Object.defineProperties(THREE.Quaternion.prototype, {
        multiplyVector3: {
            value: function(a) {
                return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), a.applyQuaternion(this)
            }
        }
    }), Object.defineProperties(THREE.Ray.prototype, {
        isIntersectionBox: {
            value: function(a) {
                return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(a)
            }
        },
        isIntersectionPlane: {
            value: function(a) {
                return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(a)
            }
        },
        isIntersectionSphere: {
            value: function(a) {
                return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(a)
            }
        }
    }), Object.defineProperties(THREE.Vector3.prototype, {
        setEulerFromRotationMatrix: {
            value: function() {
                console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
            }
        },
        setEulerFromQuaternion: {
            value: function() {
                console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
            }
        },
        getPositionFromMatrix: {
            value: function(a) {
                return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(a)
            }
        },
        getScaleFromMatrix: {
            value: function(a) {
                return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(a)
            }
        },
        getColumnFromMatrix: {
            value: function(a, b) {
                return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(a, b)
            }
        }
    }),
    //
    THREE.Face4 = function(a, b, c, d, e, f, g) {
        return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new THREE.Face3(a, b, c, e, f, g)
    },
    //
    Object.defineProperties(THREE.Object3D.prototype, {
        eulerOrder: {
            get: function() {
                return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
            },
            set: function(a) {
                console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = a
            }
        },
        getChildByName: {
            value: function(a) {
                return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(a)
            }
        },
        renderDepth: {
            set: function(a) {
                console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
            }
        },
        translate: {
            value: function(a, b) {
                return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(b, a)
            }
        },
        useQuaternion: {
            get: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            },
            set: function(a) {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            }
        }
    }),
    //
    Object.defineProperties(THREE, {
        PointCloud: {
            value: function(a, b) {
                return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new THREE.Points(a, b)
            }
        },
        ParticleSystem: {
            value: function(a, b) {
                return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new THREE.Points(a, b)
            }
        }
    }),
    //
    Object.defineProperties(THREE.Light.prototype, {
        onlyShadow: {
            set: function(a) {
                console.warn("THREE.Light: .onlyShadow has been removed.")
            }
        },
        shadowCameraFov: {
            set: function(a) {
                console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = a
            }
        },
        shadowCameraLeft: {
            set: function(a) {
                console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = a
            }
        },
        shadowCameraRight: {
            set: function(a) {
                console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = a
            }
        },
        shadowCameraTop: {
            set: function(a) {
                console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = a
            }
        },
        shadowCameraBottom: {
            set: function(a) {
                console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = a
            }
        },
        shadowCameraNear: {
            set: function(a) {
                console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = a
            }
        },
        shadowCameraFar: {
            set: function(a) {
                console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = a
            }
        },
        shadowCameraVisible: {
            set: function(a) {
                console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
            }
        },
        shadowBias: {
            set: function(a) {
                console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = a
            }
        },
        shadowDarkness: {
            set: function(a) {
                console.warn("THREE.Light: .shadowDarkness has been removed.")
            }
        },
        shadowMapWidth: {
            set: function(a) {
                console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = a
            }
        },
        shadowMapHeight: {
            set: function(a) {
                console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = a
            }
        }
    }),
    //
    Object.defineProperties(THREE.BufferAttribute.prototype, {
        length: {
            get: function() {
                return console.warn("THREE.BufferAttribute: .length has been deprecated. Please use .count."), this.array.length
            }
        }
    }), Object.defineProperties(THREE.BufferGeometry.prototype, {
        drawcalls: {
            get: function() {
                return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
            }
        },
        offsets: {
            get: function() {
                return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
            }
        },
        addIndex: {
            value: function(a) {
                console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(a)
            }
        },
        addDrawCall: {
            value: function(a, b, c) {
                void 0 !== c && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(a, b)
            }
        },
        clearDrawCalls: {
            value: function() {
                console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
            }
        },
        computeTangents: {
            value: function() {
                console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
            }
        },
        computeOffsets: {
            value: function() {
                console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
            }
        }
    }),
    //
    Object.defineProperties(THREE.Material.prototype, {
        wrapAround: {
            get: function() {
                console.warn("THREE." + this.type + ": .wrapAround has been removed.")
            },
            set: function(a) {
                console.warn("THREE." + this.type + ": .wrapAround has been removed.")
            }
        },
        wrapRGB: {
            get: function() {
                return console.warn("THREE." + this.type + ": .wrapRGB has been removed."), new THREE.Color
            }
        }
    }), Object.defineProperties(THREE, {
        PointCloudMaterial: {
            value: function(a) {
                return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new THREE.PointsMaterial(a)
            }
        },
        ParticleBasicMaterial: {
            value: function(a) {
                return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new THREE.PointsMaterial(a)
            }
        },
        ParticleSystemMaterial: {
            value: function(a) {
                return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new THREE.PointsMaterial(a)
            }
        }
    }), Object.defineProperties(THREE.MeshPhongMaterial.prototype, {
        metal: {
            get: function() {
                return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1
            },
            set: function(a) {
                console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
            }
        }
    }), Object.defineProperties(THREE.ShaderMaterial.prototype, {
        derivatives: {
            get: function() {
                return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
            },
            set: function(a) {
                console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = a
            }
        }
    }),
    //
    Object.defineProperties(THREE.WebGLRenderer.prototype, {
        supportsFloatTextures: {
            value: function() {
                return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
            }
        },
        supportsHalfFloatTextures: {
            value: function() {
                return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
            }
        },
        supportsStandardDerivatives: {
            value: function() {
                return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
            }
        },
        supportsCompressedTextureS3TC: {
            value: function() {
                return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
            }
        },
        supportsCompressedTexturePVRTC: {
            value: function() {
                return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
            }
        },
        supportsBlendMinMax: {
            value: function() {
                return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
            }
        },
        supportsVertexTextures: {
            value: function() {
                return this.capabilities.vertexTextures
            }
        },
        supportsInstancedArrays: {
            value: function() {
                return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
            }
        },
        enableScissorTest: {
            value: function(a) {
                console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(a)
            }
        },
        initMaterial: {
            value: function() {
                console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
            }
        },
        addPrePlugin: {
            value: function() {
                console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
            }
        },
        addPostPlugin: {
            value: function() {
                console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
            }
        },
        updateShadowMap: {
            value: function() {
                console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
            }
        },
        shadowMapEnabled: {
            get: function() {
                return this.shadowMap.enabled
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = a
            }
        },
        shadowMapType: {
            get: function() {
                return this.shadowMap.type
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = a
            }
        },
        shadowMapCullFace: {
            get: function() {
                return this.shadowMap.cullFace
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace."), this.shadowMap.cullFace = a
            }
        }
    }),
    //
    Object.defineProperties(THREE.WebGLRenderTarget.prototype, {
        wrapS: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = a
            }
        },
        wrapT: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = a
            }
        },
        magFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = a
            }
        },
        minFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = a
            }
        },
        anisotropy: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = a
            }
        },
        offset: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = a
            }
        },
        repeat: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = a
            }
        },
        format: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = a
            }
        },
        type: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = a
            }
        },
        generateMipmaps: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = a
            }
        }
    }),
    //
    THREE.GeometryUtils = {
        merge: function(a, b, c) {
            console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
            var d;
            b instanceof THREE.Mesh && (b.matrixAutoUpdate && b.updateMatrix(), d = b.matrix, b = b.geometry), a.merge(b, d, c)
        },
        center: function(a) {
            return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), a.center()
        }
    }, THREE.ImageUtils = {
        crossOrigin: void 0,
        loadTexture: function(a, b, c, d) {
            console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
            var e = new THREE.TextureLoader;
            e.setCrossOrigin(this.crossOrigin);
            var f = e.load(a, c, void 0, d);
            return b && (f.mapping = b), f
        },
        loadTextureCube: function(a, b, c, d) {
            console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
            var e = new THREE.CubeTextureLoader;
            e.setCrossOrigin(this.crossOrigin);
            var f = e.load(a, c, void 0, d);
            return b && (f.mapping = b), f
        },
        loadCompressedTexture: function() {
            console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
        },
        loadCompressedTextureCube: function() {
            console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
        }
    },
    //
    THREE.Projector = function() {
        console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."), this.projectVector = function(a, b) {
            console.warn("THREE.Projector: .projectVector() is now vector.project()."), a.project(b)
        }, this.unprojectVector = function(a, b) {
            console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), a.unproject(b)
        }, this.pickingRay = function(a, b) {
            console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
        }
    },
    //
    THREE.CanvasRenderer = function() {
        console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"), this.domElement = document.createElement("canvas"), this.clear = function() {}, this.render = function() {}, this.setClearColor = function() {}, this.setSize = function() {}
    },
    //
    THREE.MeshFaceMaterial = THREE.MultiMaterial,
    // File:src/extras/CurveUtils.js
    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     */
    THREE.CurveUtils = {
        tangentQuadraticBezier: function(a, b, c, d) {
            return 2 * (1 - a) * (c - b) + 2 * a * (d - c)
        },
        // Puay Bing, thanks for helping with this derivative!
        tangentCubicBezier: function(a, b, c, d, e) {
            return -3 * b * (1 - a) * (1 - a) + 3 * c * (1 - a) * (1 - a) - 6 * a * c * (1 - a) + 6 * a * d * (1 - a) - 3 * a * a * d + 3 * a * a * e
        },
        tangentSpline: function(a, b, c, d, e) {
            // To check if my formulas are correct
            var f = 6 * a * a - 6 * a,
                g = 3 * a * a - 4 * a + 1,
                h = -6 * a * a + 6 * a,
                i = 3 * a * a - 2 * a; // t3 − t2
            return f + g + h + i
        },
        // Catmull-Rom
        interpolate: function(a, b, c, d, e) {
            var f = .5 * (c - a),
                g = .5 * (d - b),
                h = e * e,
                i = e * h;
            return (2 * b - 2 * c + f + g) * i + (-3 * b + 3 * c - 2 * f - g) * h + f * e + b
        }
    },
    // File:src/extras/SceneUtils.js
    /**
     * @author alteredq / http://alteredqualia.com/
     */
    THREE.SceneUtils = {
        createMultiMaterialObject: function(a, b) {
            for (var c = new THREE.Group, d = 0, e = b.length; e > d; d++) c.add(new THREE.Mesh(a, b[d]));
            return c
        },
        detach: function(a, b, c) {
            a.applyMatrix(b.matrixWorld), b.remove(a), c.add(a)
        },
        attach: function(a, b, c) {
            var d = new THREE.Matrix4;
            d.getInverse(c.matrixWorld), a.applyMatrix(d), b.remove(a), c.add(a)
        }
    },
    // File:src/extras/ShapeUtils.js
    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     */
    THREE.ShapeUtils = {
        // calculate area of the contour polygon
        area: function(a) {
            for (var b = a.length, c = 0, d = b - 1, e = 0; b > e; d = e++) c += a[d].x * a[e].y - a[e].x * a[d].y;
            return .5 * c
        },
        triangulate: function() {
            /**
             * This code is a quick port of code written in C++ which was submitted to
             * flipcode.com by John W. Ratcliff  // July 22, 2000
             * See original code and more information here:
             * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
             *
             * ported to actionscript by Zevan Rosser
             * www.actionsnippet.com
             *
             * ported to javascript by Joshua Koo
             * http://www.lab4games.net/zz85/blog
             *
             */
            function a(a, b, c, d, e, f) {
                var g, h, i, j, k, l, m, n, o;
                if (h = a[f[b]].x, i = a[f[b]].y, j = a[f[c]].x, k = a[f[c]].y, l = a[f[d]].x, m = a[f[d]].y, Number.EPSILON > (j - h) * (m - i) - (k - i) * (l - h)) return !1;
                var p, q, r, s, t, u, v, w, x, y, z, A, B, C, D;
                for (p = l - j, q = m - k, r = h - l, s = i - m, t = j - h, u = k - i, g = 0; e > g; g++)
                    if (n = a[f[g]].x, o = a[f[g]].y, !(n === h && o === i || n === j && o === k || n === l && o === m) && (v = n - h, w = o - i, x = n - j, y = o - k, z = n - l, A = o - m, D = p * y - q * x, B = t * w - u * v, C = r * A - s * z, D >= -Number.EPSILON && C >= -Number.EPSILON && B >= -Number.EPSILON)) return !1;
                return !0
            }
            // takes in an contour array and returns
            return function(b, c) {
                var d = b.length;
                if (3 > d) return null;
                var e, f, g, h = [],
                    i = [],
                    j = [];
                if (THREE.ShapeUtils.area(b) > 0)
                    for (f = 0; d > f; f++) i[f] = f;
                else
                    for (f = 0; d > f; f++) i[f] = d - 1 - f;
                var k = d,
                    l = 2 * k; /* error detection */
                for (f = k - 1; k > 2;) { /* if we loop, it is probably a non-simple polygon */
                    if (l-- <= 0)
                    //** Triangulate: ERROR - probable bad polygon!
                    //throw ( "Warning, unable to triangulate polygon!" );
                    //return null;
                    // Sometimes warning is fine, especially polygons are triangulated in reverse.
                        return console.warn("THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()"), c ? j : h; /* next     */
                    if (e = f, e >= k && (e = 0), f = e + 1, f >= k && (f = 0), g = f + 1, g >= k && (g = 0), a(b, e, f, g, k, i)) {
                        var m, n, o, p, q; /* remove v from the remaining polygon */
                        for (m = i[e], n = i[f], o = i[g], h.push([b[m], b[n], b[o]]), j.push([i[e], i[f], i[g]]), p = f, q = f + 1; k > q; p++, q++) i[p] = i[q];
                        k--, /* reset error detection counter */
                        l = 2 * k
                    }
                }
                return c ? j : h
            }
        }(),
        triangulateShape: function(a, b) {
            function c(a, b, c) {
                // inOtherPt needs to be collinear to the inSegment
                // inOtherPt needs to be collinear to the inSegment
                return a.x !== b.x ? a.x < b.x ? a.x <= c.x && c.x <= b.x : b.x <= c.x && c.x <= a.x : a.y < b.y ? a.y <= c.y && c.y <= b.y : b.y <= c.y && c.y <= a.y
            }

            function d(a, b, d, e, f) {
                var g = b.x - a.x,
                    h = b.y - a.y,
                    i = e.x - d.x,
                    j = e.y - d.y,
                    k = a.x - d.x,
                    l = a.y - d.y,
                    m = h * i - g * j,
                    n = h * k - g * l;
                if (Math.abs(m) > Number.EPSILON) {
                    // not parallel
                    var o;
                    if (m > 0) {
                        if (0 > n || n > m) return [];
                        if (o = j * k - i * l, 0 > o || o > m) return []
                    } else {
                        if (n > 0 || m > n) return [];
                        if (o = j * k - i * l, o > 0 || m > o) return []
                    }
                    // i.e. to reduce rounding errors
                    // intersection at endpoint of segment#1?
                    if (0 === o) return !f || 0 !== n && n !== m ? [a] : [];
                    if (o === m) return !f || 0 !== n && n !== m ? [b] : [];
                    // intersection at endpoint of segment#2?
                    if (0 === n) return [d];
                    if (n === m) return [e];
                    // return real intersection point
                    var p = o / m;
                    return [{
                        x: a.x + p * g,
                        y: a.y + p * h
                    }]
                }
                // parallel or collinear
                if (0 !== n || j * k !== i * l) return [];
                // they are collinear or degenerate
                var q = 0 === g && 0 === h,
                    r = 0 === i && 0 === j; // segment2 is just a point?
                // both segments are points
                if (q && r) return a.x !== d.x || a.y !== d.y ? [] : [a];
                // segment#1  is a single point
                if (q) return c(d, e, a) ? [a] : [];
                // segment#2  is a single point
                if (r) return c(a, b, d) ? [d] : [];
                // they are collinear segments, which might overlap
                var s, t, u, v, w, x, y, z;
                // the segments are NOT on a vertical line
                // the segments are on a vertical line
                return 0 !== g ? (a.x < b.x ? (s = a, u = a.x, t = b, v = b.x) : (s = b, u = b.x, t = a, v = a.x), d.x < e.x ? (w = d, y = d.x, x = e, z = e.x) : (w = e, y = e.x, x = d, z = d.x)) : (a.y < b.y ? (s = a, u = a.y, t = b, v = b.y) : (s = b, u = b.y, t = a, v = a.y), d.y < e.y ? (w = d, y = d.y, x = e, z = e.y) : (w = e, y = e.y, x = d, z = d.y)), y >= u ? y > v ? [] : v === y ? f ? [] : [w] : z >= v ? [w, t] : [w, x] : u > z ? [] : u === z ? f ? [] : [s] : z >= v ? [s, t] : [s, x]
            }

            function e(a, b, c, d) {
                // The order of legs is important
                // translation of all points, so that Vertex is at (0,0)
                var e = b.x - a.x,
                    f = b.y - a.y,
                    g = c.x - a.x,
                    h = c.y - a.y,
                    i = d.x - a.x,
                    j = d.y - a.y,
                    k = e * h - f * g,
                    l = e * j - f * i;
                if (Math.abs(k) > Number.EPSILON) {
                    // angle != 180 deg.
                    var m = i * h - j * g;
                    // console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );
                    // console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );
                    return k > 0 ? l >= 0 && m >= 0 : l >= 0 || m >= 0
                }
                // angle == 180 deg.
                // console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
                return l > 0
            }

            function f(a, b) {
                function c(a, b) {
                    // Check if hole point lies within angle around shape point
                    var c = s.length - 1,
                        d = a - 1;
                    0 > d && (d = c);
                    var f = a + 1;
                    f > c && (f = 0);
                    var g = e(s[a], s[d], s[f], h[b]);
                    if (!g)
                    // console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
                        return !1;
                    // Check if shape point lies within angle around hole point
                    var i = h.length - 1,
                        j = b - 1;
                    0 > j && (j = i);
                    var k = b + 1;
                    return k > i && (k = 0), g = e(h[b], h[j], h[k], s[a]), !!g
                }

                function f(a, b) {
                    // checks for intersections with shape edges
                    var c, e, f;
                    for (c = 0; c < s.length; c++)
                        if (e = c + 1, e %= s.length, f = d(a, b, s[c], s[e], !0), f.length > 0) return !0;
                    return !1
                }

                function g(a, c) {
                    // checks for intersections with hole edges
                    var e, f, g, h, i;
                    for (e = 0; e < t.length; e++)
                        for (f = b[t[e]], g = 0; g < f.length; g++)
                            if (h = g + 1, h %= f.length, i = d(a, c, f[g], f[h], !0), i.length > 0) return !0;
                    return !1
                }
                for (var h, i, j, k, l, m, n, o, p, q, r, s = a.concat(), t = [], u = [], v = 0, w = b.length; w > v; v++) t.push(v);
                for (var x = 0, y = 2 * t.length; t.length > 0;) {
                    if (y--, 0 > y) {
                        console.log("Infinite Loop! Holes left:" + t.length + ", Probably Hole outside Shape!");
                        break
                    }
                    // search for shape-vertex and hole-vertex,
                    // which can be connected without intersections
                    for (j = x; j < s.length; j++) {
                        k = s[j], i = -1;
                        // search for hole which can be reached without intersections
                        for (var v = 0; v < t.length; v++)
                            if (m = t[v], n = k.x + ":" + k.y + ":" + m, void 0 === u[n]) {
                                h = b[m];
                                for (var z = 0; z < h.length; z++)
                                    if (l = h[z], c(j, z) && !f(k, l) && !g(k, l)) {
                                        i = z, t.splice(v, 1), o = s.slice(0, j + 1), p = s.slice(j), q = h.slice(i), r = h.slice(0, i + 1), s = o.concat(q).concat(r).concat(p), x = j;
                                        // Debug only, to show the selected cuts
                                        // glob_CutLines.push( [ shapePt, holePt ] );
                                        break
                                    }
                                if (i >= 0) break; // hole-vertex found
                                u[n] = !0
                            }
                        if (i >= 0) break
                    }
                }
                return s
            }
            for (var g, h, i, j, k, l, m = {}, n = a.concat(), o = 0, p = b.length; p > o; o++) Array.prototype.push.apply(n, b[o]);
            //console.log( "allpoints",allpoints, allpoints.length );
            // prepare all points map
            for (g = 0, h = n.length; h > g; g++) k = n[g].x + ":" + n[g].y, void 0 !== m[k] && console.warn("THREE.Shape: Duplicate point", k), m[k] = g;
            // remove holes by cutting paths to holes and adding them to the shape
            var q = f(a, b),
                r = THREE.ShapeUtils.triangulate(q, !1); // True returns indices for points of spooled shape
            //console.log( "triangles",triangles, triangles.length );
            // check all face vertices against all points map
            for (g = 0, h = r.length; h > g; g++)
                for (j = r[g], i = 0; 3 > i; i++) k = j[i].x + ":" + j[i].y, l = m[k], void 0 !== l && (j[i] = l);
            return r.concat()
        },
        isClockWise: function(a) {
            return THREE.ShapeUtils.area(a) < 0
        },
        // Bezier Curves formulas obtained from
        // http://en.wikipedia.org/wiki/B%C3%A9zier_curve
        // Quad Bezier Functions
        b2: function() {
            function a(a, b) {
                var c = 1 - a;
                return c * c * b
            }

            function b(a, b) {
                return 2 * (1 - a) * a * b
            }

            function c(a, b) {
                return a * a * b
            }
            return function(d, e, f, g) {
                return a(d, e) + b(d, f) + c(d, g)
            }
        }(),
        // Cubic Bezier Functions
        b3: function() {
            function a(a, b) {
                var c = 1 - a;
                return c * c * c * b
            }

            function b(a, b) {
                var c = 1 - a;
                return 3 * c * c * a * b
            }

            function c(a, b) {
                var c = 1 - a;
                return 3 * c * a * a * b
            }

            function d(a, b) {
                return a * a * a * b
            }
            return function(e, f, g, h, i) {
                return a(e, f) + b(e, g) + c(e, h) + d(e, i)
            }
        }()
    },
    // File:src/extras/core/Curve.js
    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * Extensible curve object
     *
     * Some common of Curve methods
     * .getPoint(t), getTangent(t)
     * .getPointAt(u), getTagentAt(u)
     * .getPoints(), .getSpacedPoints()
     * .getLength()
     * .updateArcLengths()
     *
     * This following classes subclasses THREE.Curve:
     *
     * -- 2d classes --
     * THREE.LineCurve
     * THREE.QuadraticBezierCurve
     * THREE.CubicBezierCurve
     * THREE.SplineCurve
     * THREE.ArcCurve
     * THREE.EllipseCurve
     *
     * -- 3d classes --
     * THREE.LineCurve3
     * THREE.QuadraticBezierCurve3
     * THREE.CubicBezierCurve3
     * THREE.SplineCurve3
     * THREE.ClosedSplineCurve3
     *
     * A series of curves can be represented as a THREE.CurvePath
     *
     **/
    /**************************************************************
     *	Abstract Curve base class
     **************************************************************/
    THREE.Curve = function() {}, THREE.Curve.prototype = {
        constructor: THREE.Curve,
        // Virtual base class method to overwrite and implement in subclasses
        //	- t [0 .. 1]
        getPoint: function(a) {
            return console.warn("THREE.Curve: Warning, getPoint() not implemented!"), null
        },
        // Get point at relative position in curve according to arc length
        // - u [0 .. 1]
        getPointAt: function(a) {
            var b = this.getUtoTmapping(a);
            return this.getPoint(b)
        },
        // Get sequence of points using getPoint( t )
        getPoints: function(a) {
            a || (a = 5);
            var b, c = [];
            for (b = 0; a >= b; b++) c.push(this.getPoint(b / a));
            return c
        },
        // Get sequence of points using getPointAt( u )
        getSpacedPoints: function(a) {
            a || (a = 5);
            var b, c = [];
            for (b = 0; a >= b; b++) c.push(this.getPointAt(b / a));
            return c
        },
        // Get total curve arc length
        getLength: function() {
            var a = this.getLengths();
            return a[a.length - 1]
        },
        // Get list of cumulative segment lengths
        getLengths: function(a) {
            if (a || (a = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200), this.cacheArcLengths && this.cacheArcLengths.length === a + 1 && !this.needsUpdate)
            //console.log( "cached", this.cacheArcLengths );
                return this.cacheArcLengths;
            this.needsUpdate = !1;
            var b, c, d = [],
                e = this.getPoint(0),
                f = 0;
            for (d.push(0), c = 1; a >= c; c++) b = this.getPoint(c / a), f += b.distanceTo(e), d.push(f), e = b;
            return this.cacheArcLengths = d, d
        },
        updateArcLengths: function() {
            this.needsUpdate = !0, this.getLengths()
        },
        // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
        getUtoTmapping: function(a, b) {
            var c, d = this.getLengths(),
                e = 0,
                f = d.length; // The targeted u distance value to get
            c = b ? b : a * d[f - 1];
            for (
                //var time = Date.now();
                // binary search for the index with largest value smaller than target u distance
                var g, h = 0, i = f - 1; i >= h;)
                if (e = Math.floor(h + (i - h) / 2), g = d[e] - c, 0 > g) h = e + 1;
                else {
                    if (!(g > 0)) {
                        i = e;
                        break
                    }
                    i = e - 1
                }
                //console.log('b' , i, low, high, Date.now()- time);
            if (e = i, d[e] === c) {
                var j = e / (f - 1);
                return j
            }
            // we could get finer grain at lengths, or use simple interpolation between two points
            var k = d[e],
                l = d[e + 1],
                m = l - k,
                n = (c - k) / m,
                j = (e + n) / (f - 1);
            return j
        },
        // Returns a unit vector tangent at t
        // In case any sub curve does not implement its tangent derivation,
        // 2 points a small delta apart will be used to find its gradient
        // which seems to give a reasonable approximation
        getTangent: function(a) {
            var b = 1e-4,
                c = a - b,
                d = a + b;
            // Capping in case of danger
            0 > c && (c = 0), d > 1 && (d = 1);
            var e = this.getPoint(c),
                f = this.getPoint(d),
                g = f.clone().sub(e);
            return g.normalize()
        },
        getTangentAt: function(a) {
            var b = this.getUtoTmapping(a);
            return this.getTangent(b)
        }
    },
    // TODO: Transformation for Curves?
    /**************************************************************
     *	3D Curves
     **************************************************************/
    // A Factory method for creating new curve subclasses
    THREE.Curve.create = function(a, b) {
        return a.prototype = Object.create(THREE.Curve.prototype), a.prototype.constructor = a, a.prototype.getPoint = b, a
    },
    // File:src/extras/core/CurvePath.js
    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     *
     **/
    /**************************************************************
     *	Curved Path - a curve path is simply a array of connected
     *  curves, but retains the api of a curve
     **************************************************************/
    THREE.CurvePath = function() {
        this.curves = [], this.autoClose = !1
    }, THREE.CurvePath.prototype = Object.create(THREE.Curve.prototype), THREE.CurvePath.prototype.constructor = THREE.CurvePath, THREE.CurvePath.prototype.add = function(a) {
        this.curves.push(a)
    },
    /*
     THREE.CurvePath.prototype.checkConnection = function() {
     // TODO
     // If the ending of curve is not connected to the starting
     // or the next curve, then, this is not a real path
     };
     */
    THREE.CurvePath.prototype.closePath = function() {
        // TODO Test
        // and verify for vector3 (needs to implement equals)
        // Add a line curve if start and end of lines are not connected
        var a = this.curves[0].getPoint(0),
            b = this.curves[this.curves.length - 1].getPoint(1);
        a.equals(b) || this.curves.push(new THREE.LineCurve(b, a))
    },
    // To get accurate point with reference to
    // entire path distance at time t,
    // following has to be done:
    // 1. Length of each sub path have to be known
    // 2. Locate and identify type of curve
    // 3. Get t for the curve
    // 4. Return curve.getPointAt(t')
    THREE.CurvePath.prototype.getPoint = function(a) {
        // To think about boundaries points.
        for (var b = a * this.getLength(), c = this.getCurveLengths(), d = 0; d < c.length;) {
            if (c[d] >= b) {
                var e = c[d] - b,
                    f = this.curves[d],
                    g = 1 - e / f.getLength();
                return f.getPointAt(g)
            }
            d++
        }
        return null
    },
    /*
     THREE.CurvePath.prototype.getTangent = function( t ) {
     };
     */
    // We cannot use the default THREE.Curve getPoint() with getLength() because in
    // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
    // getPoint() depends on getLength
    THREE.CurvePath.prototype.getLength = function() {
        var a = this.getCurveLengths();
        return a[a.length - 1]
    },
    // Compute lengths and cache them
    // We cannot overwrite getLengths() because UtoT mapping uses it.
    THREE.CurvePath.prototype.getCurveLengths = function() {
        // We use cache values if curves and cache array are same length
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
        for (var a = [], b = 0, c = 0, d = this.curves.length; d > c; c++) b += this.curves[c].getLength(), a.push(b);
        return this.cacheLengths = a, a
    },
    /**************************************************************
     *	Create Geometries Helpers
     **************************************************************/
    /// Generate geometry from path points (for Line or Points objects)
    THREE.CurvePath.prototype.createPointsGeometry = function(a) {
        var b = this.getPoints(a);
        return this.createGeometry(b)
    },
    // Generate geometry from equidistant sampling along the path
    THREE.CurvePath.prototype.createSpacedPointsGeometry = function(a) {
        var b = this.getSpacedPoints(a);
        return this.createGeometry(b)
    }, THREE.CurvePath.prototype.createGeometry = function(a) {
        for (var b = new THREE.Geometry, c = 0, d = a.length; d > c; c++) {
            var e = a[c];
            b.vertices.push(new THREE.Vector3(e.x, e.y, e.z || 0))
        }
        return b
    },
    // File:src/extras/core/Font.js
    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.Font = function(a) {
        this.data = a
    }, THREE.Font.prototype = {
        constructor: THREE.Font,
        generateShapes: function(a, b, c) {
            function d(a) {
                for (var c = String(a).split(""), d = b / f.resolution, g = 0, h = [], i = 0; i < c.length; i++) {
                    var j = e(c[i], d, g);
                    g += j.offset, h.push(j.path)
                }
                return h
            }

            function e(a, b, d) {
                var e = f.glyphs[a] || f.glyphs["?"];
                if (e) {
                    var g, h, i, j, k, l, m, n, o, p, q, r = new THREE.Path,
                        s = [],
                        t = THREE.ShapeUtils.b2,
                        u = THREE.ShapeUtils.b3;
                    if (e.o)
                        for (var v = e._cachedOutline || (e._cachedOutline = e.o.split(" ")), w = 0, x = v.length; x > w;) {
                            var y = v[w++];
                            switch (y) {
                                case "m": // moveTo
                                    g = v[w++] * b + d, h = v[w++] * b, r.moveTo(g, h);
                                    break;
                                case "l": // lineTo
                                    g = v[w++] * b + d, h = v[w++] * b, r.lineTo(g, h);
                                    break;
                                case "q":
                                    if (i = v[w++] * b + d, j = v[w++] * b, m = v[w++] * b + d, n = v[w++] * b, r.quadraticCurveTo(m, n, i, j), q = s[s.length - 1]) {
                                        k = q.x, l = q.y;
                                        for (var z = 1; c >= z; z++) {
                                            var A = z / c;
                                            t(A, k, m, i), t(A, l, n, j)
                                        }
                                    }
                                    break;
                                case "b":
                                    if (i = v[w++] * b + d, j = v[w++] * b, m = v[w++] * b + d, n = v[w++] * b, o = v[w++] * b + d, p = v[w++] * b, r.bezierCurveTo(m, n, o, p, i, j), q = s[s.length - 1]) {
                                        k = q.x, l = q.y;
                                        for (var z = 1; c >= z; z++) {
                                            var A = z / c;
                                            u(A, k, m, o, i), u(A, l, n, p, j)
                                        }
                                    }
                            }
                        }
                    return {
                        offset: e.ha * b,
                        path: r
                    }
                }
            }
            //
            void 0 === b && (b = 100), void 0 === c && (c = 4);
            for (var f = this.data, g = d(a), h = [], i = 0, j = g.length; j > i; i++) Array.prototype.push.apply(h, g[i].toShapes());
            return h
        }
    },
    // File:src/extras/core/Path.js
    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * Creates free form 2d path using series of points, lines or curves.
     *
     **/
    THREE.Path = function(a) {
        THREE.CurvePath.call(this), this.actions = [], a && this.fromPoints(a)
    }, THREE.Path.prototype = Object.create(THREE.CurvePath.prototype), THREE.Path.prototype.constructor = THREE.Path,
    // TODO Clean up PATH API
    // Create path using straight lines to connect all points
    // - vectors: array of Vector2
    THREE.Path.prototype.fromPoints = function(a) {
        this.moveTo(a[0].x, a[0].y);
        for (var b = 1, c = a.length; c > b; b++) this.lineTo(a[b].x, a[b].y)
    },
    // startPath() endPath()?
    THREE.Path.prototype.moveTo = function(a, b) {
        this.actions.push({
            action: "moveTo",
            args: [a, b]
        })
    }, THREE.Path.prototype.lineTo = function(a, b) {
        var c = this.actions[this.actions.length - 1].args,
            d = c[c.length - 2],
            e = c[c.length - 1],
            f = new THREE.LineCurve(new THREE.Vector2(d, e), new THREE.Vector2(a, b));
        this.curves.push(f), this.actions.push({
            action: "lineTo",
            args: [a, b]
        })
    }, THREE.Path.prototype.quadraticCurveTo = function(a, b, c, d) {
        var e = this.actions[this.actions.length - 1].args,
            f = e[e.length - 2],
            g = e[e.length - 1],
            h = new THREE.QuadraticBezierCurve(new THREE.Vector2(f, g), new THREE.Vector2(a, b), new THREE.Vector2(c, d));
        this.curves.push(h), this.actions.push({
            action: "quadraticCurveTo",
            args: [a, b, c, d]
        })
    }, THREE.Path.prototype.bezierCurveTo = function(a, b, c, d, e, f) {
        var g = this.actions[this.actions.length - 1].args,
            h = g[g.length - 2],
            i = g[g.length - 1],
            j = new THREE.CubicBezierCurve(new THREE.Vector2(h, i), new THREE.Vector2(a, b), new THREE.Vector2(c, d), new THREE.Vector2(e, f));
        this.curves.push(j), this.actions.push({
            action: "bezierCurveTo",
            args: [a, b, c, d, e, f]
        })
    }, THREE.Path.prototype.splineThru = function(a) {
        var b = Array.prototype.slice.call(arguments),
            c = this.actions[this.actions.length - 1].args,
            d = c[c.length - 2],
            e = c[c.length - 1],
            f = [new THREE.Vector2(d, e)];
        Array.prototype.push.apply(f, a);
        var g = new THREE.SplineCurve(f);
        this.curves.push(g), this.actions.push({
            action: "splineThru",
            args: b
        })
    },
    // FUTURE: Change the API or follow canvas API?
    THREE.Path.prototype.arc = function(a, b, c, d, e, f) {
        var g = this.actions[this.actions.length - 1].args,
            h = g[g.length - 2],
            i = g[g.length - 1];
        this.absarc(a + h, b + i, c, d, e, f)
    }, THREE.Path.prototype.absarc = function(a, b, c, d, e, f) {
        this.absellipse(a, b, c, c, d, e, f)
    }, THREE.Path.prototype.ellipse = function(a, b, c, d, e, f, g, h) {
        var i = this.actions[this.actions.length - 1].args,
            j = i[i.length - 2],
            k = i[i.length - 1];
        this.absellipse(a + j, b + k, c, d, e, f, g, h)
    }, THREE.Path.prototype.absellipse = function(a, b, c, d, e, f, g, h) {
        var i = [a, b, c, d, e, f, g, h || 0],
            j = new THREE.EllipseCurve(a, b, c, d, e, f, g, h);
        this.curves.push(j);
        var k = j.getPoint(1);
        i.push(k.x), i.push(k.y), this.actions.push({
            action: "ellipse",
            args: i
        })
    }, THREE.Path.prototype.getSpacedPoints = function(a) {
        a || (a = 40);
        for (var b = [], c = 0; a > c; c++) b.push(this.getPoint(c / a));
        return this.autoClose && b.push(b[0]), b
    }, /* Return an array of vectors based on contour of the path */
    THREE.Path.prototype.getPoints = function(a) {
        a = a || 12;
        for (var b, c, d, e, f, g, h, i, j, k, l, m = THREE.ShapeUtils.b2, n = THREE.ShapeUtils.b3, o = [], p = 0, q = this.actions.length; q > p; p++) {
            var r = this.actions[p],
                s = r.action,
                t = r.args;
            switch (s) {
                case "moveTo":
                    o.push(new THREE.Vector2(t[0], t[1]));
                    break;
                case "lineTo":
                    o.push(new THREE.Vector2(t[0], t[1]));
                    break;
                case "quadraticCurveTo":
                    b = t[2], c = t[3], f = t[0], g = t[1], o.length > 0 ? (j = o[o.length - 1], h = j.x, i = j.y) : (j = this.actions[p - 1].args, h = j[j.length - 2], i = j[j.length - 1]);
                    for (var u = 1; a >= u; u++) {
                        var v = u / a;
                        k = m(v, h, f, b), l = m(v, i, g, c), o.push(new THREE.Vector2(k, l))
                    }
                    break;
                case "bezierCurveTo":
                    b = t[4], c = t[5], f = t[0], g = t[1], d = t[2], e = t[3], o.length > 0 ? (j = o[o.length - 1], h = j.x, i = j.y) : (j = this.actions[p - 1].args, h = j[j.length - 2], i = j[j.length - 1]);
                    for (var u = 1; a >= u; u++) {
                        var v = u / a;
                        k = n(v, h, f, d, b), l = n(v, i, g, e, c), o.push(new THREE.Vector2(k, l))
                    }
                    break;
                case "splineThru":
                    j = this.actions[p - 1].args;
                    var w = new THREE.Vector2(j[j.length - 2], j[j.length - 1]),
                        x = [w],
                        y = a * t[0].length;
                    x = x.concat(t[0]);
                    for (var z = new THREE.SplineCurve(x), u = 1; y >= u; u++) o.push(z.getPointAt(u / y));
                    break;
                case "arc":
                    for (var A, B = t[0], C = t[1], D = t[2], E = t[3], F = t[4], G = !!t[5], H = F - E, I = 2 * a, u = 1; I >= u; u++) {
                        var v = u / I;
                        G || (v = 1 - v), A = E + v * H, k = B + D * Math.cos(A), l = C + D * Math.sin(A),
                            //console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);
                            o.push(new THREE.Vector2(k, l))
                    }
                    //console.log(points);
                    break;
                case "ellipse":
                    var A, J, K, B = t[0],
                        C = t[1],
                        L = t[2],
                        M = t[3],
                        E = t[4],
                        F = t[5],
                        G = !!t[6],
                        N = t[7],
                        H = F - E,
                        I = 2 * a;
                    0 !== N && (J = Math.cos(N), K = Math.sin(N));
                    for (var u = 1; I >= u; u++) {
                        var v = u / I;
                        if (G || (v = 1 - v), A = E + v * H, k = B + L * Math.cos(A), l = C + M * Math.sin(A), 0 !== N) {
                            var O = k,
                                P = l;
                            // Rotate the point about the center of the ellipse.
                            k = (O - B) * J - (P - C) * K + B, l = (O - B) * K + (P - C) * J + C
                        }
                        //console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);
                        o.push(new THREE.Vector2(k, l))
                    }
            }
        }
        // Normalize to remove the closing point by default.
        var Q = o[o.length - 1];
        return Math.abs(Q.x - o[0].x) < Number.EPSILON && Math.abs(Q.y - o[0].y) < Number.EPSILON && o.splice(o.length - 1, 1), this.autoClose && o.push(o[0]), o
    },
    //
    // Breaks path into shapes
    //
    //	Assumptions (if parameter isCCW==true the opposite holds):
    //	- solid shapes are defined clockwise (CW)
    //	- holes are defined counterclockwise (CCW)
    //
    //	If parameter noHoles==true:
    //  - all subPaths are regarded as solid shapes
    //  - definition order CW/CCW has no relevance
    //
    THREE.Path.prototype.toShapes = function(a, b) {
        function c(a) {
            for (var b = [], c = new THREE.Path, d = 0, e = a.length; e > d; d++) {
                var f = a[d],
                    g = f.args,
                    h = f.action;
                "moveTo" === h && 0 !== c.actions.length && (b.push(c), c = new THREE.Path), c[h].apply(c, g)
            }
            // console.log(subPaths);
            return 0 !== c.actions.length && b.push(c), b
        }

        function d(a) {
            for (var b = [], c = 0, d = a.length; d > c; c++) {
                var e = a[c],
                    f = new THREE.Shape;
                f.actions = e.actions, f.curves = e.curves, b.push(f)
            }
            //console.log("shape", shapes);
            return b
        }

        function e(a, b) {
            for (var c = b.length, d = !1, e = c - 1, f = 0; c > f; e = f++) {
                var g = b[e],
                    h = b[f],
                    i = h.x - g.x,
                    j = h.y - g.y;
                if (Math.abs(j) > Number.EPSILON) {
                    if (
                        // not parallel
                        0 > j && (g = b[f], i = -i, h = b[e], j = -j), a.y < g.y || a.y > h.y) continue;
                    if (a.y === g.y) {
                        if (a.x === g.x) return !0
                    } else {
                        var k = j * (a.x - g.x) - i * (a.y - g.y);
                        if (0 === k) return !0; // inPt is on contour ?
                        if (0 > k) continue;
                        d = !d
                    }
                } else {
                    // parallel or collinear
                    if (a.y !== g.y) continue; // parallel
                    // edge lies on the same horizontal line as inPt
                    if (h.x <= a.x && a.x <= g.x || g.x <= a.x && a.x <= h.x) return !0
                }
            }
            return d
        }
        var f = THREE.ShapeUtils.isClockWise,
            g = c(this.actions);
        if (0 === g.length) return [];
        if (b === !0) return d(g);
        var h, i, j, k = [];
        if (1 === g.length) return i = g[0], j = new THREE.Shape, j.actions = i.actions, j.curves = i.curves, k.push(j), k;
        var l = !f(g[0].getPoints());
        l = a ? !l : l;
        // console.log("Holes first", holesFirst);
        var m, n = [],
            o = [],
            p = [],
            q = 0;
        o[q] = void 0, p[q] = [];
        for (var r = 0, s = g.length; s > r; r++) i = g[r], m = i.getPoints(), h = f(m), h = a ? !h : h, h ? (!l && o[q] && q++, o[q] = {
            s: new THREE.Shape,
            p: m
        }, o[q].s.actions = i.actions, o[q].s.curves = i.curves, l && q++, p[q] = []) : p[q].push({
            h: i,
            p: m[0]
        });
        // only Holes? -> probably all Shapes with wrong orientation
        if (!o[0]) return d(g);
        if (o.length > 1) {
            for (var t = !1, u = [], v = 0, w = o.length; w > v; v++) n[v] = [];
            for (var v = 0, w = o.length; w > v; v++)
                for (var x = p[v], y = 0; y < x.length; y++) {
                    for (var z = x[y], A = !0, B = 0; B < o.length; B++) e(z.p, o[B].p) && (v !== B && u.push({
                        froms: v,
                        tos: B,
                        hole: y
                    }), A ? (A = !1, n[B].push(z)) : t = !0);
                    A && n[v].push(z)
                }
                // console.log("ambiguous: ", ambiguous);
            u.length > 0 && (
                // console.log("to change: ", toChange);
                t || (p = n))
        }
        for (var C, r = 0, D = o.length; D > r; r++) {
            j = o[r].s, k.push(j), C = p[r];
            for (var E = 0, F = C.length; F > E; E++) j.holes.push(C[E].h)
        }
        //console.log("shape", shapes);
        return k
    },
    // File:src/extras/core/Shape.js
    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * Defines a 2d shape plane using paths.
     **/
    // STEP 1 Create a path.
    // STEP 2 Turn path into shape.
    // STEP 3 ExtrudeGeometry takes in Shape/Shapes
    // STEP 3a - Extract points from each shape, turn to vertices
    // STEP 3b - Triangulate each shape, add faces.
    THREE.Shape = function() {
        THREE.Path.apply(this, arguments), this.holes = []
    }, THREE.Shape.prototype = Object.create(THREE.Path.prototype), THREE.Shape.prototype.constructor = THREE.Shape,
    // Convenience method to return ExtrudeGeometry
    THREE.Shape.prototype.extrude = function(a) {
        return new THREE.ExtrudeGeometry(this, a)
    },
    // Convenience method to return ShapeGeometry
    THREE.Shape.prototype.makeGeometry = function(a) {
        return new THREE.ShapeGeometry(this, a)
    },
    // Get points of holes
    THREE.Shape.prototype.getPointsHoles = function(a) {
        for (var b = [], c = 0, d = this.holes.length; d > c; c++) b[c] = this.holes[c].getPoints(a);
        return b
    },
    // Get points of shape and holes (keypoints based on segments parameter)
    THREE.Shape.prototype.extractAllPoints = function(a) {
        return {
            shape: this.getPoints(a),
            holes: this.getPointsHoles(a)
        }
    }, THREE.Shape.prototype.extractPoints = function(a) {
        return this.extractAllPoints(a)
    },
    // File:src/extras/curves/LineCurve.js
    /**************************************************************
     *	Line
     **************************************************************/
    THREE.LineCurve = function(a, b) {
        this.v1 = a, this.v2 = b
    }, THREE.LineCurve.prototype = Object.create(THREE.Curve.prototype), THREE.LineCurve.prototype.constructor = THREE.LineCurve, THREE.LineCurve.prototype.getPoint = function(a) {
        var b = this.v2.clone().sub(this.v1);
        return b.multiplyScalar(a).add(this.v1), b
    },
    // Line curve is linear, so we can overwrite default getPointAt
    THREE.LineCurve.prototype.getPointAt = function(a) {
        return this.getPoint(a)
    }, THREE.LineCurve.prototype.getTangent = function(a) {
        var b = this.v2.clone().sub(this.v1);
        return b.normalize()
    },
    // File:src/extras/curves/QuadraticBezierCurve.js
    /**************************************************************
     *	Quadratic Bezier curve
     **************************************************************/
    THREE.QuadraticBezierCurve = function(a, b, c) {
        this.v0 = a, this.v1 = b, this.v2 = c
    }, THREE.QuadraticBezierCurve.prototype = Object.create(THREE.Curve.prototype), THREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve, THREE.QuadraticBezierCurve.prototype.getPoint = function(a) {
        var b = THREE.ShapeUtils.b2;
        return new THREE.Vector2(b(a, this.v0.x, this.v1.x, this.v2.x), b(a, this.v0.y, this.v1.y, this.v2.y))
    }, THREE.QuadraticBezierCurve.prototype.getTangent = function(a) {
        var b = THREE.CurveUtils.tangentQuadraticBezier;
        return new THREE.Vector2(b(a, this.v0.x, this.v1.x, this.v2.x), b(a, this.v0.y, this.v1.y, this.v2.y)).normalize()
    },
    // File:src/extras/curves/CubicBezierCurve.js
    /**************************************************************
     *	Cubic Bezier curve
     **************************************************************/
    THREE.CubicBezierCurve = function(a, b, c, d) {
        this.v0 = a, this.v1 = b, this.v2 = c, this.v3 = d
    }, THREE.CubicBezierCurve.prototype = Object.create(THREE.Curve.prototype), THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve, THREE.CubicBezierCurve.prototype.getPoint = function(a) {
        var b = THREE.ShapeUtils.b3;
        return new THREE.Vector2(b(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x), b(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y))
    }, THREE.CubicBezierCurve.prototype.getTangent = function(a) {
        var b = THREE.CurveUtils.tangentCubicBezier;
        return new THREE.Vector2(b(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x), b(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y)).normalize()
    },
    // File:src/extras/curves/SplineCurve.js
    /**************************************************************
     *	Spline curve
     **************************************************************/
    THREE.SplineCurve = function(a) {
        this.points = void 0 == a ? [] : a
    }, THREE.SplineCurve.prototype = Object.create(THREE.Curve.prototype), THREE.SplineCurve.prototype.constructor = THREE.SplineCurve, THREE.SplineCurve.prototype.getPoint = function(a) {
        var b = this.points,
            c = (b.length - 1) * a,
            d = Math.floor(c),
            e = c - d,
            f = b[0 === d ? d : d - 1],
            g = b[d],
            h = b[d > b.length - 2 ? b.length - 1 : d + 1],
            i = b[d > b.length - 3 ? b.length - 1 : d + 2],
            j = THREE.CurveUtils.interpolate;
        return new THREE.Vector2(j(f.x, g.x, h.x, i.x, e), j(f.y, g.y, h.y, i.y, e))
    },
    // File:src/extras/curves/EllipseCurve.js
    /**************************************************************
     *	Ellipse curve
     **************************************************************/
    THREE.EllipseCurve = function(a, b, c, d, e, f, g, h) {
        this.aX = a, this.aY = b, this.xRadius = c, this.yRadius = d, this.aStartAngle = e, this.aEndAngle = f, this.aClockwise = g, this.aRotation = h || 0
    }, THREE.EllipseCurve.prototype = Object.create(THREE.Curve.prototype), THREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve, THREE.EllipseCurve.prototype.getPoint = function(a) {
        var b = this.aEndAngle - this.aStartAngle;
        0 > b && (b += 2 * Math.PI), b > 2 * Math.PI && (b -= 2 * Math.PI);
        var c;
        c = this.aClockwise === !0 ? this.aEndAngle + (1 - a) * (2 * Math.PI - b) : this.aStartAngle + a * b;
        var d = this.aX + this.xRadius * Math.cos(c),
            e = this.aY + this.yRadius * Math.sin(c);
        if (0 !== this.aRotation) {
            var f = Math.cos(this.aRotation),
                g = Math.sin(this.aRotation),
                h = d,
                i = e;
            // Rotate the point about the center of the ellipse.
            d = (h - this.aX) * f - (i - this.aY) * g + this.aX, e = (h - this.aX) * g + (i - this.aY) * f + this.aY
        }
        return new THREE.Vector2(d, e)
    },
    // File:src/extras/curves/ArcCurve.js
    /**************************************************************
     *	Arc curve
     **************************************************************/
    THREE.ArcCurve = function(a, b, c, d, e, f) {
        THREE.EllipseCurve.call(this, a, b, c, c, d, e, f)
    }, THREE.ArcCurve.prototype = Object.create(THREE.EllipseCurve.prototype), THREE.ArcCurve.prototype.constructor = THREE.ArcCurve,
    // File:src/extras/curves/LineCurve3.js
    /**************************************************************
     *	Line3D
     **************************************************************/
    THREE.LineCurve3 = THREE.Curve.create(function(a, b) {
        this.v1 = a, this.v2 = b
    }, function(a) {
        var b = new THREE.Vector3; // diff
        return b.subVectors(this.v2, this.v1), b.multiplyScalar(a), b.add(this.v1), b
    }),
    // File:src/extras/curves/QuadraticBezierCurve3.js
    /**************************************************************
     *	Quadratic Bezier 3D curve
     **************************************************************/
    THREE.QuadraticBezierCurve3 = THREE.Curve.create(function(a, b, c) {
        this.v0 = a, this.v1 = b, this.v2 = c
    }, function(a) {
        var b = THREE.ShapeUtils.b2;
        return new THREE.Vector3(b(a, this.v0.x, this.v1.x, this.v2.x), b(a, this.v0.y, this.v1.y, this.v2.y), b(a, this.v0.z, this.v1.z, this.v2.z))
    }),
    // File:src/extras/curves/CubicBezierCurve3.js
    /**************************************************************
     *	Cubic Bezier 3D curve
     **************************************************************/
    THREE.CubicBezierCurve3 = THREE.Curve.create(function(a, b, c, d) {
        this.v0 = a, this.v1 = b, this.v2 = c, this.v3 = d
    }, function(a) {
        var b = THREE.ShapeUtils.b3;
        return new THREE.Vector3(b(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x), b(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y), b(a, this.v0.z, this.v1.z, this.v2.z, this.v3.z))
    }),
    // File:src/extras/curves/SplineCurve3.js
    /**************************************************************
     *	Spline 3D curve
     **************************************************************/
    THREE.SplineCurve3 = THREE.Curve.create(function(a) {
        console.warn("THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3"), this.points = void 0 == a ? [] : a
    }, function(a) {
        var b = this.points,
            c = (b.length - 1) * a,
            d = Math.floor(c),
            e = c - d,
            f = b[0 == d ? d : d - 1],
            g = b[d],
            h = b[d > b.length - 2 ? b.length - 1 : d + 1],
            i = b[d > b.length - 3 ? b.length - 1 : d + 2],
            j = THREE.CurveUtils.interpolate;
        return new THREE.Vector3(j(f.x, g.x, h.x, i.x, e), j(f.y, g.y, h.y, i.y, e), j(f.z, g.z, h.z, i.z, e))
    }),
    // File:src/extras/curves/CatmullRomCurve3.js
    /**
     * @author zz85 https://github.com/zz85
     *
     * Centripetal CatmullRom Curve - which is useful for avoiding
     * cusps and self-intersections in non-uniform catmull rom curves.
     * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
     *
     * curve.type accepts centripetal(default), chordal and catmullrom
     * curve.tension is used for catmullrom which defaults to 0.5
     */
    THREE.CatmullRomCurve3 = function() {
        /*
        	 Based on an optimized c++ solution in
        	 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
        	 - http://ideone.com/NoEbVM

        	 This CubicPoly class could be used for reusing some variables and calculations,
        	 but for three.js curve use, it could be possible inlined and flatten into a single function call
        	 which can be placed in CurveUtils.
        	 */
        function a() {}
        var b = new THREE.Vector3,
            c = new a,
            d = new a,
            e = new a;
        // Subclass Three.js curve
        /*
         * Compute coefficients for a cubic polynomial
         *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
         * such that
         *   p(0) = x0, p(1) = x1
         *  and
         *   p'(0) = t0, p'(1) = t1.
         */
        // standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4
        return a.prototype.init = function(a, b, c, d) {
            this.c0 = a, this.c1 = c, this.c2 = -3 * a + 3 * b - 2 * c - d, this.c3 = 2 * a - 2 * b + c + d
        }, a.prototype.initNonuniformCatmullRom = function(a, b, c, d, e, f, g) {
            // compute tangents when parameterized in [t1,t2]
            var h = (b - a) / e - (c - a) / (e + f) + (c - b) / f,
                i = (c - b) / f - (d - b) / (f + g) + (d - c) / g;
            h *= f, i *= f, this.init(b, c, h, i)
        }, a.prototype.initCatmullRom = function(a, b, c, d, e) {
            this.init(b, c, e * (c - a), e * (d - b))
        }, a.prototype.calc = function(a) {
            var b = a * a,
                c = b * a;
            return this.c0 + this.c1 * a + this.c2 * b + this.c3 * c
        }, THREE.Curve.create(function(a) {
            this.points = a || [], this.closed = !1
        }, function(a) {
            var f, g, h, i, j = this.points;
            i = j.length, 2 > i && console.log("duh, you need at least 2 points"), f = (i - (this.closed ? 0 : 1)) * a, g = Math.floor(f), h = f - g, this.closed ? g += g > 0 ? 0 : (Math.floor(Math.abs(g) / j.length) + 1) * j.length : 0 === h && g === i - 1 && (g = i - 2, h = 1);
            var k, l, m, n;
            if ( // 4 points
                this.closed || g > 0 ? k = j[(g - 1) % i] : (
                    // extrapolate first point
                    b.subVectors(j[0], j[1]).add(j[0]), k = b), l = j[g % i], m = j[(g + 1) % i], this.closed || i > g + 2 ? n = j[(g + 2) % i] : (b.subVectors(j[i - 1], j[i - 2]).add(j[i - 1]), n = b), void 0 === this.type || "centripetal" === this.type || "chordal" === this.type) {
                // init Centripetal / Chordal Catmull-Rom
                var o = "chordal" === this.type ? .5 : .25,
                    p = Math.pow(k.distanceToSquared(l), o),
                    q = Math.pow(l.distanceToSquared(m), o),
                    r = Math.pow(m.distanceToSquared(n), o);
                // safety check for repeated points
                1e-4 > q && (q = 1), 1e-4 > p && (p = q), 1e-4 > r && (r = q), c.initNonuniformCatmullRom(k.x, l.x, m.x, n.x, p, q, r), d.initNonuniformCatmullRom(k.y, l.y, m.y, n.y, p, q, r), e.initNonuniformCatmullRom(k.z, l.z, m.z, n.z, p, q, r)
            } else if ("catmullrom" === this.type) {
                var s = void 0 !== this.tension ? this.tension : .5;
                c.initCatmullRom(k.x, l.x, m.x, n.x, s), d.initCatmullRom(k.y, l.y, m.y, n.y, s), e.initCatmullRom(k.z, l.z, m.z, n.z, s)
            }
            var t = new THREE.Vector3(c.calc(h), d.calc(h), e.calc(h));
            return t
        })
    }(),
    // File:src/extras/curves/ClosedSplineCurve3.js
    /**************************************************************
     *	Closed Spline 3D curve
     **************************************************************/
    THREE.ClosedSplineCurve3 = function(a) {
        console.warn("THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3."), THREE.CatmullRomCurve3.call(this, a), this.type = "catmullrom", this.closed = !0
    }, THREE.ClosedSplineCurve3.prototype = Object.create(THREE.CatmullRomCurve3.prototype),
    // File:src/extras/geometries/BoxGeometry.js
    /**
     * @author mrdoob / http://mrdoob.com/
     * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
     */
    THREE.BoxGeometry = function(a, b, c, d, e, f) { // nz
        function g(a, b, c, d, e, f, g, i) {
            var j, k, l, m = h.widthSegments,
                n = h.heightSegments,
                o = e / 2,
                p = f / 2,
                q = h.vertices.length;
            "x" === a && "y" === b || "y" === a && "x" === b ? j = "z" : "x" === a && "z" === b || "z" === a && "x" === b ? (j = "y", n = h.depthSegments) : ("z" === a && "y" === b || "y" === a && "z" === b) && (j = "x", m = h.depthSegments);
            var r = m + 1,
                s = n + 1,
                t = e / m,
                u = f / n,
                v = new THREE.Vector3;
            for (v[j] = g > 0 ? 1 : -1, l = 0; s > l; l++)
                for (k = 0; r > k; k++) {
                    var w = new THREE.Vector3;
                    w[a] = (k * t - o) * c, w[b] = (l * u - p) * d, w[j] = g, h.vertices.push(w)
                }
            for (l = 0; n > l; l++)
                for (k = 0; m > k; k++) {
                    var x = k + r * l,
                        y = k + r * (l + 1),
                        z = k + 1 + r * (l + 1),
                        A = k + 1 + r * l,
                        B = new THREE.Vector2(k / m, 1 - l / n),
                        C = new THREE.Vector2(k / m, 1 - (l + 1) / n),
                        D = new THREE.Vector2((k + 1) / m, 1 - (l + 1) / n),
                        E = new THREE.Vector2((k + 1) / m, 1 - l / n),
                        F = new THREE.Face3(x + q, y + q, A + q);
                    F.normal.copy(v), F.vertexNormals.push(v.clone(), v.clone(), v.clone()), F.materialIndex = i, h.faces.push(F), h.faceVertexUvs[0].push([B, C, E]), F = new THREE.Face3(y + q, z + q, A + q), F.normal.copy(v), F.vertexNormals.push(v.clone(), v.clone(), v.clone()), F.materialIndex = i, h.faces.push(F), h.faceVertexUvs[0].push([C.clone(), D, E.clone()])
                }
        }
        THREE.Geometry.call(this), this.type = "BoxGeometry", this.parameters = {
            width: a,
            height: b,
            depth: c,
            widthSegments: d,
            heightSegments: e,
            depthSegments: f
        }, this.widthSegments = d || 1, this.heightSegments = e || 1, this.depthSegments = f || 1;
        var h = this,
            i = a / 2,
            j = b / 2,
            k = c / 2;
        g("z", "y", -1, -1, c, b, i, 0), // px
            g("z", "y", 1, -1, c, b, -i, 1), // nx
            g("x", "z", 1, 1, a, c, j, 2), // py
            g("x", "z", 1, -1, a, c, -j, 3), // ny
            g("x", "y", 1, -1, a, b, k, 4), // pz
            g("x", "y", -1, -1, a, b, -k, 5), this.mergeVertices()
    }, THREE.BoxGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry, THREE.CubeGeometry = THREE.BoxGeometry,
    // File:src/extras/geometries/CircleGeometry.js
    /**
     * @author hughes
     */
    THREE.CircleGeometry = function(a, b, c, d) {
        THREE.Geometry.call(this), this.type = "CircleGeometry", this.parameters = {
            radius: a,
            segments: b,
            thetaStart: c,
            thetaLength: d
        }, this.fromBufferGeometry(new THREE.CircleBufferGeometry(a, b, c, d))
    }, THREE.CircleGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry,
    // File:src/extras/geometries/CircleBufferGeometry.js
    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     */
    THREE.CircleBufferGeometry = function(a, b, c, d) {
        THREE.BufferGeometry.call(this), this.type = "CircleBufferGeometry", this.parameters = {
            radius: a,
            segments: b,
            thetaStart: c,
            thetaLength: d
        }, a = a || 50, b = void 0 !== b ? Math.max(3, b) : 8, c = void 0 !== c ? c : 0, d = void 0 !== d ? d : 2 * Math.PI;
        var e = b + 2,
            f = new Float32Array(3 * e),
            g = new Float32Array(3 * e),
            h = new Float32Array(2 * e);
        // center data is already zero, but need to set a few extras
        g[2] = 1, h[0] = .5, h[1] = .5;
        for (var i = 0, j = 3, k = 2; b >= i; i++, j += 3, k += 2) {
            var l = c + i / b * d;
            f[j] = a * Math.cos(l), f[j + 1] = a * Math.sin(l), g[j + 2] = 1, // normal z
                h[k] = (f[j] / a + 1) / 2, h[k + 1] = (f[j + 1] / a + 1) / 2
        }
        for (var m = [], j = 1; b >= j; j++) m.push(j, j + 1, 0);
        this.setIndex(new THREE.BufferAttribute(new Uint16Array(m), 1)), this.addAttribute("position", new THREE.BufferAttribute(f, 3)), this.addAttribute("normal", new THREE.BufferAttribute(g, 3)), this.addAttribute("uv", new THREE.BufferAttribute(h, 2)), this.boundingSphere = new THREE.Sphere(new THREE.Vector3, a)
    }, THREE.CircleBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype), THREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry,
    // File:src/extras/geometries/CylinderGeometry.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.CylinderGeometry = function(a, b, c, d, e, f, g, h) {
        THREE.Geometry.call(this), this.type = "CylinderGeometry", this.parameters = {
            radiusTop: a,
            radiusBottom: b,
            height: c,
            radialSegments: d,
            heightSegments: e,
            openEnded: f,
            thetaStart: g,
            thetaLength: h
        }, a = void 0 !== a ? a : 20, b = void 0 !== b ? b : 20, c = void 0 !== c ? c : 100, d = d || 8, e = e || 1, f = void 0 !== f ? f : !1, g = void 0 !== g ? g : 0, h = void 0 !== h ? h : 2 * Math.PI;
        var i, j, k = c / 2,
            l = [],
            m = [];
        for (j = 0; e >= j; j++) {
            var n = [],
                o = [],
                p = j / e,
                q = p * (b - a) + a;
            for (i = 0; d >= i; i++) {
                var r = i / d,
                    s = new THREE.Vector3;
                s.x = q * Math.sin(r * h + g), s.y = -p * c + k, s.z = q * Math.cos(r * h + g), this.vertices.push(s), n.push(this.vertices.length - 1), o.push(new THREE.Vector2(r, 1 - p))
            }
            l.push(n), m.push(o)
        }
        var t, u, v = (b - a) / c;
        for (i = 0; d > i; i++)
            for (0 !== a ? (t = this.vertices[l[0][i]].clone(), u = this.vertices[l[0][i + 1]].clone()) : (t = this.vertices[l[1][i]].clone(), u = this.vertices[l[1][i + 1]].clone()), t.setY(Math.sqrt(t.x * t.x + t.z * t.z) * v).normalize(), u.setY(Math.sqrt(u.x * u.x + u.z * u.z) * v).normalize(), j = 0; e > j; j++) {
                var w = l[j][i],
                    x = l[j + 1][i],
                    y = l[j + 1][i + 1],
                    z = l[j][i + 1],
                    A = t.clone(),
                    B = t.clone(),
                    C = u.clone(),
                    D = u.clone(),
                    E = m[j][i].clone(),
                    F = m[j + 1][i].clone(),
                    G = m[j + 1][i + 1].clone(),
                    H = m[j][i + 1].clone();
                this.faces.push(new THREE.Face3(w, x, z, [A, B, D])), this.faceVertexUvs[0].push([E, F, H]), this.faces.push(new THREE.Face3(x, y, z, [B.clone(), C, D.clone()])), this.faceVertexUvs[0].push([F.clone(), G, H.clone()])
            }
            // top cap
        if (f === !1 && a > 0)
            for (this.vertices.push(new THREE.Vector3(0, k, 0)), i = 0; d > i; i++) {
                var w = l[0][i],
                    x = l[0][i + 1],
                    y = this.vertices.length - 1,
                    A = new THREE.Vector3(0, 1, 0),
                    B = new THREE.Vector3(0, 1, 0),
                    C = new THREE.Vector3(0, 1, 0),
                    E = m[0][i].clone(),
                    F = m[0][i + 1].clone(),
                    G = new THREE.Vector2(F.x, 0);
                this.faces.push(new THREE.Face3(w, x, y, [A, B, C], void 0, 1)), this.faceVertexUvs[0].push([E, F, G])
            }
            // bottom cap
        if (f === !1 && b > 0)
            for (this.vertices.push(new THREE.Vector3(0, -k, 0)), i = 0; d > i; i++) {
                var w = l[e][i + 1],
                    x = l[e][i],
                    y = this.vertices.length - 1,
                    A = new THREE.Vector3(0, -1, 0),
                    B = new THREE.Vector3(0, -1, 0),
                    C = new THREE.Vector3(0, -1, 0),
                    E = m[e][i + 1].clone(),
                    F = m[e][i].clone(),
                    G = new THREE.Vector2(F.x, 1);
                this.faces.push(new THREE.Face3(w, x, y, [A, B, C], void 0, 2)), this.faceVertexUvs[0].push([E, F, G])
            }
        this.computeFaceNormals()
    }, THREE.CylinderGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry,
    // File:src/extras/geometries/EdgesGeometry.js
    /**
     * @author WestLangley / http://github.com/WestLangley
     */
    THREE.EdgesGeometry = function(a, b) {
        function c(a, b) {
            return a - b
        }
        THREE.BufferGeometry.call(this), b = void 0 !== b ? b : 1;
        var d, e = Math.cos(THREE.Math.degToRad(b)),
            f = [0, 0],
            g = {},
            h = ["a", "b", "c"];
        a instanceof THREE.BufferGeometry ? (d = new THREE.Geometry, d.fromBufferGeometry(a)) : d = a.clone(), d.mergeVertices(), d.computeFaceNormals();
        for (var i = d.vertices, j = d.faces, k = 0, l = j.length; l > k; k++)
            for (var m = j[k], n = 0; 3 > n; n++) {
                f[0] = m[h[n]], f[1] = m[h[(n + 1) % 3]], f.sort(c);
                var o = f.toString();
                void 0 === g[o] ? g[o] = {
                    vert1: f[0],
                    vert2: f[1],
                    face1: k,
                    face2: void 0
                } : g[o].face2 = k
            }
        var p = [];
        for (var o in g) {
            var q = g[o];
            if (void 0 === q.face2 || j[q.face1].normal.dot(j[q.face2].normal) <= e) {
                var r = i[q.vert1];
                p.push(r.x), p.push(r.y), p.push(r.z), r = i[q.vert2], p.push(r.x), p.push(r.y), p.push(r.z)
            }
        }
        this.addAttribute("position", new THREE.BufferAttribute(new Float32Array(p), 3))
    }, THREE.EdgesGeometry.prototype = Object.create(THREE.BufferGeometry.prototype), THREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry,
    // File:src/extras/geometries/ExtrudeGeometry.js
    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     *
     * Creates extruded geometry from a path shape.
     *
     * parameters = {
     *
     *  curveSegments: <int>, // number of points on the curves
     *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
     *  amount: <int>, // Depth to extrude the shape
     *
     *  bevelEnabled: <bool>, // turn on bevel
     *  bevelThickness: <float>, // how deep into the original shape bevel goes
     *  bevelSize: <float>, // how far from shape outline is bevel
     *  bevelSegments: <int>, // number of bevel layers
     *
     *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
     *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals
     *
     *  uvGenerator: <Object> // object that provides UV generator functions
     *
     * }
     **/
    THREE.ExtrudeGeometry = function(a, b) {
        return "undefined" == typeof a ? void(a = []) : (THREE.Geometry.call(this), this.type = "ExtrudeGeometry", a = Array.isArray(a) ? a : [a], this.addShapeList(a, b), void this.computeFaceNormals())
    }, THREE.ExtrudeGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry, THREE.ExtrudeGeometry.prototype.addShapeList = function(a, b) {
        for (var c = a.length, d = 0; c > d; d++) {
            var e = a[d];
            this.addShape(e, b)
        }
    }, THREE.ExtrudeGeometry.prototype.addShape = function(a, b) {
        function c(a, b, c) {
            return b || console.error("THREE.ExtrudeGeometry: vec does not exist"), b.clone().multiplyScalar(c).add(a)
        }
        // Find directions for point movement
        function d(a, b, c) {
            // computes for inPt the corresponding point inPt' on a new contour
            //   shifted by 1 unit (length of normalized vector) to the left
            // if we walk along contour clockwise, this new contour is outside the old one
            //
            // inPt' is the intersection of the two lines parallel to the two
            //  adjacent edges of inPt at a distance of 1 unit on the left side.
            var d, e, f = 1,
                g = a.x - b.x,
                h = a.y - b.y,
                i = c.x - a.x,
                j = c.y - a.y,
                k = g * g + h * h,
                l = g * j - h * i;
            if (Math.abs(l) > Number.EPSILON) {
                // not collinear
                // length of vectors for normalizing
                var m = Math.sqrt(k),
                    n = Math.sqrt(i * i + j * j),
                    o = b.x - h / m,
                    p = b.y + g / m,
                    q = c.x - j / n,
                    r = c.y + i / n,
                    s = ((q - o) * j - (r - p) * i) / (g * j - h * i);
                // vector from inPt to intersection point
                d = o + g * s - a.x, e = p + h * s - a.y;
                // Don't normalize!, otherwise sharp corners become ugly
                //  but prevent crazy spikes
                var t = d * d + e * e;
                if (2 >= t) return new THREE.Vector2(d, e);
                f = Math.sqrt(t / 2)
            } else {
                // handle special case of collinear edges
                var u = !1; // assumes: opposite
                g > Number.EPSILON ? i > Number.EPSILON && (u = !0) : g < -Number.EPSILON ? i < -Number.EPSILON && (u = !0) : Math.sign(h) === Math.sign(j) && (u = !0), u ? (d = -h, e = g, f = Math.sqrt(k)) : (d = g, e = h, f = Math.sqrt(k / 2))
            }
            return new THREE.Vector2(d / f, e / f)
        }
        /////  Internal functions
        function e() {
            if (t) {
                var a = 0,
                    b = Q * a;
                // Bottom faces
                for (T = 0; R > T; T++) P = I[T], i(P[2] + b, P[1] + b, P[0] + b);
                // Top faces
                for (a = v + 2 * s, b = Q * a, T = 0; R > T; T++) P = I[T], i(P[0] + b, P[1] + b, P[2] + b)
            } else {
                // Bottom faces
                for (T = 0; R > T; T++) P = I[T], i(P[2], P[1], P[0]);
                // Top faces
                for (T = 0; R > T; T++) P = I[T], i(P[0] + Q * v, P[1] + Q * v, P[2] + Q * v)
            }
        }
        // Create faces for the z-sides of the shape
        function f() {
            var a = 0;
            for (g(J, a), a += J.length, A = 0, B = G.length; B > A; A++) z = G[A], g(z, a), a += z.length
        }

        function g(a, b) {
            var c, d;
            for (T = a.length; --T >= 0;) {
                c = T, d = T - 1, 0 > d && (d = a.length - 1);
                //console.log('b', i,j, i-1, k,vertices.length);
                var e = 0,
                    f = v + 2 * s;
                for (e = 0; f > e; e++) {
                    var g = Q * e,
                        h = Q * (e + 1),
                        i = b + c + g,
                        k = b + d + g,
                        l = b + d + h,
                        m = b + c + h;
                    j(i, k, l, m, a, e, f, c, d)
                }
            }
        }

        function h(a, b, c) {
            C.vertices.push(new THREE.Vector3(a, b, c))
        }

        function i(a, b, c) {
            a += D, b += D, c += D, C.faces.push(new THREE.Face3(a, b, c, null, null, 0));
            var d = y.generateTopUV(C, a, b, c);
            C.faceVertexUvs[0].push(d)
        }

        function j(a, b, c, d, e, f, g, h, i) {
            a += D, b += D, c += D, d += D, C.faces.push(new THREE.Face3(a, b, d, null, null, 1)), C.faces.push(new THREE.Face3(b, c, d, null, null, 1));
            var j = y.generateSideWallUV(C, a, b, c, d);
            C.faceVertexUvs[0].push([j[0], j[1], j[3]]), C.faceVertexUvs[0].push([j[1], j[2], j[3]])
        }
        var k, l, m, n, o, p = void 0 !== b.amount ? b.amount : 100,
            q = void 0 !== b.bevelThickness ? b.bevelThickness : 6,
            r = void 0 !== b.bevelSize ? b.bevelSize : q - 2,
            s = void 0 !== b.bevelSegments ? b.bevelSegments : 3,
            t = void 0 !== b.bevelEnabled ? b.bevelEnabled : !0,
            u = void 0 !== b.curveSegments ? b.curveSegments : 12,
            v = void 0 !== b.steps ? b.steps : 1,
            w = b.extrudePath,
            x = !1,
            y = void 0 !== b.UVGenerator ? b.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;
        w && (k = w.getSpacedPoints(v), x = !0, t = !1, l = void 0 !== b.frames ? b.frames : new THREE.TubeGeometry.FrenetFrames(w, v, !1), m = new THREE.Vector3, n = new THREE.Vector3, o = new THREE.Vector3),
            // Safeguards if bevels are not enabled
            t || (s = 0, q = 0, r = 0);
        // Variables initialization
        var z, A, B, C = this,
            D = this.vertices.length,
            E = a.extractPoints(u),
            F = E.shape,
            G = E.holes,
            H = !THREE.ShapeUtils.isClockWise(F);
        if (H) {
            // Maybe we should also check if holes are in the opposite direction, just to be safe ...
            for (F = F.reverse(), A = 0, B = G.length; B > A; A++) z = G[A], THREE.ShapeUtils.isClockWise(z) && (G[A] = z.reverse());
            H = !1
        }
        var I = THREE.ShapeUtils.triangulateShape(F, G),
            J = F; // vertices has all points but contour has only points of circumference
        for (A = 0, B = G.length; B > A; A++) z = G[A], F = F.concat(z);
        for (var K, L, M, N, O, P, Q = F.length, R = I.length, S = [], T = 0, U = J.length, V = U - 1, W = T + 1; U > T; T++, V++, W++) V === U && (V = 0), W === U && (W = 0),
            //  (j)---(i)---(k)
            // console.log('i,j,k', i, j , k)
            S[T] = d(J[T], J[V], J[W]);
        var X, Y = [],
            Z = S.concat();
        for (A = 0, B = G.length; B > A; A++) {
            for (z = G[A], X = [], T = 0, U = z.length, V = U - 1, W = T + 1; U > T; T++, V++, W++) V === U && (V = 0), W === U && (W = 0),
                //  (j)---(i)---(k)
                X[T] = d(z[T], z[V], z[W]);
            Y.push(X), Z = Z.concat(X)
        }
        // Loop bevelSegments, 1 for the front, 1 for the back
        for (K = 0; s > K; K++) { // curved
            //bs = bevelSize * t; // linear
            // contract shape
            for (M = K / s, N = q * (1 - M), L = r * Math.sin(M * Math.PI / 2), T = 0, U = J.length; U > T; T++) O = c(J[T], S[T], L), h(O.x, O.y, -N);
            // expand holes
            for (A = 0, B = G.length; B > A; A++)
                for (z = G[A], X = Y[A], T = 0, U = z.length; U > T; T++) O = c(z[T], X[T], L), h(O.x, O.y, -N)
        }
        // Back facing vertices
        for (L = r, T = 0; Q > T; T++) O = t ? c(F[T], Z[T], L) : F[T], x ? (n.copy(l.normals[0]).multiplyScalar(O.x), m.copy(l.binormals[0]).multiplyScalar(O.y), o.copy(k[0]).add(n).add(m), h(o.x, o.y, o.z)) : h(O.x, O.y, 0);
        // Add stepped vertices...
        // Including front facing vertices
        var $;
        for ($ = 1; v >= $; $++)
            for (T = 0; Q > T; T++) O = t ? c(F[T], Z[T], L) : F[T], x ? (n.copy(l.normals[$]).multiplyScalar(O.x), m.copy(l.binormals[$]).multiplyScalar(O.y), o.copy(k[$]).add(n).add(m), h(o.x, o.y, o.z)) : h(O.x, O.y, p / v * $);
        // Add bevel segments planes
        //for ( b = 1; b <= bevelSegments; b ++ ) {
        for (K = s - 1; K >= 0; K--) {
            // contract shape
            for (M = K / s, N = q * (1 - M), L = r * Math.sin(M * Math.PI / 2), T = 0, U = J.length; U > T; T++) O = c(J[T], S[T], L), h(O.x, O.y, p + N);
            // expand holes
            for (A = 0, B = G.length; B > A; A++)
                for (z = G[A], X = Y[A], T = 0, U = z.length; U > T; T++) O = c(z[T], X[T], L), x ? h(O.x, O.y + k[v - 1].y, k[v - 1].x + N) : h(O.x, O.y, p + N)
        } /* Faces */
        // Top and bottom faces
        e(),
            // Sides faces
            f()
    }, THREE.ExtrudeGeometry.WorldUVGenerator = {
        generateTopUV: function(a, b, c, d) {
            var e = a.vertices,
                f = e[b],
                g = e[c],
                h = e[d];
            return [new THREE.Vector2(f.x, f.y), new THREE.Vector2(g.x, g.y), new THREE.Vector2(h.x, h.y)]
        },
        generateSideWallUV: function(a, b, c, d, e) {
            var f = a.vertices,
                g = f[b],
                h = f[c],
                i = f[d],
                j = f[e];
            return Math.abs(g.y - h.y) < .01 ? [new THREE.Vector2(g.x, 1 - g.z), new THREE.Vector2(h.x, 1 - h.z), new THREE.Vector2(i.x, 1 - i.z), new THREE.Vector2(j.x, 1 - j.z)] : [new THREE.Vector2(g.y, 1 - g.z), new THREE.Vector2(h.y, 1 - h.z), new THREE.Vector2(i.y, 1 - i.z), new THREE.Vector2(j.y, 1 - j.z)]
        }
    },
    // File:src/extras/geometries/ShapeGeometry.js
    /**
     * @author jonobr1 / http://jonobr1.com
     *
     * Creates a one-sided polygonal geometry from a path shape. Similar to
     * ExtrudeGeometry.
     *
     * parameters = {
     *
     *	curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
     *
     *	material: <int> // material index for front and back faces
     *	uvGenerator: <Object> // object that provides UV generator functions
     *
     * }
     **/
    THREE.ShapeGeometry = function(a, b) {
        THREE.Geometry.call(this), this.type = "ShapeGeometry", Array.isArray(a) === !1 && (a = [a]), this.addShapeList(a, b), this.computeFaceNormals()
    }, THREE.ShapeGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry,
    /**
     * Add an array of shapes to THREE.ShapeGeometry.
     */
    THREE.ShapeGeometry.prototype.addShapeList = function(a, b) {
        for (var c = 0, d = a.length; d > c; c++) this.addShape(a[c], b);
        return this
    },
    /**
     * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
     */
    THREE.ShapeGeometry.prototype.addShape = function(a, b) {
        void 0 === b && (b = {});
        var c, d, e, f = void 0 !== b.curveSegments ? b.curveSegments : 12,
            g = b.material,
            h = void 0 === b.UVGenerator ? THREE.ExtrudeGeometry.WorldUVGenerator : b.UVGenerator,
            i = this.vertices.length,
            j = a.extractPoints(f),
            k = j.shape,
            l = j.holes,
            m = !THREE.ShapeUtils.isClockWise(k);
        if (m) {
            // Maybe we should also check if holes are in the opposite direction, just to be safe...
            for (k = k.reverse(), c = 0, d = l.length; d > c; c++) e = l[c], THREE.ShapeUtils.isClockWise(e) && (l[c] = e.reverse());
            m = !1
        }
        var n = THREE.ShapeUtils.triangulateShape(k, l);
        // Vertices
        for (c = 0, d = l.length; d > c; c++) e = l[c], k = k.concat(e);
        //
        var o, p, q = k.length,
            r = n.length;
        for (c = 0; q > c; c++) o = k[c], this.vertices.push(new THREE.Vector3(o.x, o.y, 0));
        for (c = 0; r > c; c++) {
            p = n[c];
            var s = p[0] + i,
                t = p[1] + i,
                u = p[2] + i;
            this.faces.push(new THREE.Face3(s, t, u, null, null, g)), this.faceVertexUvs[0].push(h.generateTopUV(this, s, t, u))
        }
    },
    // File:src/extras/geometries/LatheGeometry.js
    /**
     * @author astrodud / http://astrodud.isgreat.org/
     * @author zz85 / https://github.com/zz85
     * @author bhouston / http://clara.io
     */
    // points - to create a closed torus, one must use a set of points
    //    like so: [ a, b, c, d, a ], see first is the same as last.
    // segments - the number of circumference segments to create
    // phiStart - the starting radian
    // phiLength - the radian (0 to 2*PI) range of the lathed section
    //    2*pi is a closed lathe, less than 2PI is a portion.
    THREE.LatheGeometry = function(a, b, c, d) {
        THREE.Geometry.call(this), this.type = "LatheGeometry", this.parameters = {
            points: a,
            segments: b,
            phiStart: c,
            phiLength: d
        }, b = b || 12, c = c || 0, d = d || 2 * Math.PI;
        for (var e = 1 / (a.length - 1), f = 1 / b, g = 0, h = b; h >= g; g++)
            for (var i = c + g * f * d, j = Math.sin(i), k = Math.cos(i), l = 0, m = a.length; m > l; l++) {
                var n = a[l],
                    o = new THREE.Vector3;
                o.x = n.x * j, o.y = n.y, o.z = n.x * k, this.vertices.push(o)
            }
        for (var p = a.length, g = 0, h = b; h > g; g++)
            for (var l = 0, m = a.length - 1; m > l; l++) {
                var q = l + p * g,
                    r = q,
                    s = q + p,
                    t = q + 1 + p,
                    u = q + 1,
                    v = g * f,
                    w = l * e,
                    x = v + f,
                    y = w + e;
                this.faces.push(new THREE.Face3(r, s, u)), this.faceVertexUvs[0].push([new THREE.Vector2(v, w), new THREE.Vector2(x, w), new THREE.Vector2(v, y)]), this.faces.push(new THREE.Face3(s, t, u)), this.faceVertexUvs[0].push([new THREE.Vector2(x, w), new THREE.Vector2(x, y), new THREE.Vector2(v, y)])
            }
        this.mergeVertices(), this.computeFaceNormals(), this.computeVertexNormals()
    }, THREE.LatheGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry,
    // File:src/extras/geometries/PlaneGeometry.js
    /**
     * @author mrdoob / http://mrdoob.com/
     * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
     */
    THREE.PlaneGeometry = function(a, b, c, d) {
        THREE.Geometry.call(this), this.type = "PlaneGeometry", this.parameters = {
            width: a,
            height: b,
            widthSegments: c,
            heightSegments: d
        }, this.fromBufferGeometry(new THREE.PlaneBufferGeometry(a, b, c, d))
    }, THREE.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry,
    // File:src/extras/geometries/PlaneBufferGeometry.js
    /**
     * @author mrdoob / http://mrdoob.com/
     * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
     */
    THREE.PlaneBufferGeometry = function(a, b, c, d) {
        THREE.BufferGeometry.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
            width: a,
            height: b,
            widthSegments: c,
            heightSegments: d
        };
        for (var e = a / 2, f = b / 2, g = Math.floor(c) || 1, h = Math.floor(d) || 1, i = g + 1, j = h + 1, k = a / g, l = b / h, m = new Float32Array(i * j * 3), n = new Float32Array(i * j * 3), o = new Float32Array(i * j * 2), p = 0, q = 0, r = 0; j > r; r++)
            for (var s = r * l - f, t = 0; i > t; t++) {
                var u = t * k - e;
                m[p] = u, m[p + 1] = -s, n[p + 2] = 1, o[q] = t / g, o[q + 1] = 1 - r / h, p += 3, q += 2
            }
        p = 0;
        for (var v = new(m.length / 3 > 65535 ? Uint32Array : Uint16Array)(g * h * 6), r = 0; h > r; r++)
            for (var t = 0; g > t; t++) {
                var w = t + i * r,
                    x = t + i * (r + 1),
                    y = t + 1 + i * (r + 1),
                    z = t + 1 + i * r;
                v[p] = w, v[p + 1] = x, v[p + 2] = z, v[p + 3] = x, v[p + 4] = y, v[p + 5] = z, p += 6
            }
        this.setIndex(new THREE.BufferAttribute(v, 1)), this.addAttribute("position", new THREE.BufferAttribute(m, 3)), this.addAttribute("normal", new THREE.BufferAttribute(n, 3)), this.addAttribute("uv", new THREE.BufferAttribute(o, 2))
    }, THREE.PlaneBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype), THREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry,
    // File:src/extras/geometries/RingGeometry.js
    /**
     * @author Kaleb Murphy
     */
    THREE.RingGeometry = function(a, b, c, d, e, f) {
        THREE.Geometry.call(this), this.type = "RingGeometry", this.parameters = {
            innerRadius: a,
            outerRadius: b,
            thetaSegments: c,
            phiSegments: d,
            thetaStart: e,
            thetaLength: f
        }, a = a || 0, b = b || 50, e = void 0 !== e ? e : 0, f = void 0 !== f ? f : 2 * Math.PI, c = void 0 !== c ? Math.max(3, c) : 8, d = void 0 !== d ? Math.max(1, d) : 8;
        var g, h, i = [],
            j = a,
            k = (b - a) / d;
        for (g = 0; d + 1 > g; g++) {
            // concentric circles inside ring
            for (h = 0; c + 1 > h; h++) {
                // number of segments per circle
                var l = new THREE.Vector3,
                    m = e + h / c * f;
                l.x = j * Math.cos(m), l.y = j * Math.sin(m), this.vertices.push(l), i.push(new THREE.Vector2((l.x / b + 1) / 2, (l.y / b + 1) / 2))
            }
            j += k
        }
        var n = new THREE.Vector3(0, 0, 1);
        for (g = 0; d > g; g++) {
            // concentric circles inside ring
            var o = g * (c + 1);
            for (h = 0; c > h; h++) {
                // number of segments per circle
                var m = h + o,
                    p = m,
                    q = m + c + 1,
                    r = m + c + 2;
                this.faces.push(new THREE.Face3(p, q, r, [n.clone(), n.clone(), n.clone()])), this.faceVertexUvs[0].push([i[p].clone(), i[q].clone(), i[r].clone()]), p = m, q = m + c + 2, r = m + 1, this.faces.push(new THREE.Face3(p, q, r, [n.clone(), n.clone(), n.clone()])), this.faceVertexUvs[0].push([i[p].clone(), i[q].clone(), i[r].clone()])
            }
        }
        this.computeFaceNormals(), this.boundingSphere = new THREE.Sphere(new THREE.Vector3, j)
    }, THREE.RingGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.RingGeometry.prototype.constructor = THREE.RingGeometry,
    // File:src/extras/geometries/SphereGeometry.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.SphereGeometry = function(a, b, c, d, e, f, g) {
        THREE.Geometry.call(this), this.type = "SphereGeometry", this.parameters = {
            radius: a,
            widthSegments: b,
            heightSegments: c,
            phiStart: d,
            phiLength: e,
            thetaStart: f,
            thetaLength: g
        }, this.fromBufferGeometry(new THREE.SphereBufferGeometry(a, b, c, d, e, f, g))
    }, THREE.SphereGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry,
    // File:src/extras/geometries/SphereBufferGeometry.js
    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     * based on THREE.SphereGeometry
     */
    THREE.SphereBufferGeometry = function(a, b, c, d, e, f, g) {
        THREE.BufferGeometry.call(this), this.type = "SphereBufferGeometry", this.parameters = {
            radius: a,
            widthSegments: b,
            heightSegments: c,
            phiStart: d,
            phiLength: e,
            thetaStart: f,
            thetaLength: g
        }, a = a || 50, b = Math.max(3, Math.floor(b) || 8), c = Math.max(2, Math.floor(c) || 6), d = void 0 !== d ? d : 0, e = void 0 !== e ? e : 2 * Math.PI, f = void 0 !== f ? f : 0, g = void 0 !== g ? g : Math.PI;
        for (var h = f + g, i = (b + 1) * (c + 1), j = new THREE.BufferAttribute(new Float32Array(3 * i), 3), k = new THREE.BufferAttribute(new Float32Array(3 * i), 3), l = new THREE.BufferAttribute(new Float32Array(2 * i), 2), m = 0, n = [], o = new THREE.Vector3, p = 0; c >= p; p++) {
            for (var q = [], r = p / c, s = 0; b >= s; s++) {
                var t = s / b,
                    u = -a * Math.cos(d + t * e) * Math.sin(f + r * g),
                    v = a * Math.cos(f + r * g),
                    w = a * Math.sin(d + t * e) * Math.sin(f + r * g);
                o.set(u, v, w).normalize(), j.setXYZ(m, u, v, w), k.setXYZ(m, o.x, o.y, o.z), l.setXY(m, t, 1 - r), q.push(m), m++
            }
            n.push(q)
        }
        for (var x = [], p = 0; c > p; p++)
            for (var s = 0; b > s; s++) {
                var y = n[p][s + 1],
                    z = n[p][s],
                    A = n[p + 1][s],
                    B = n[p + 1][s + 1];
                (0 !== p || f > 0) && x.push(y, z, B), (p !== c - 1 || h < Math.PI) && x.push(z, A, B)
            }
        this.setIndex(new(j.count > 65535 ? THREE.Uint32Attribute : THREE.Uint16Attribute)(x, 1)), this.addAttribute("position", j), this.addAttribute("normal", k), this.addAttribute("uv", l), this.boundingSphere = new THREE.Sphere(new THREE.Vector3, a)
    }, THREE.SphereBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype), THREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry,
    // File:src/extras/geometries/TextGeometry.js
    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * @author alteredq / http://alteredqualia.com/
     *
     * Text = 3D Text
     *
     * parameters = {
     *  font: <THREE.Font>, // font
     *
     *  size: <float>, // size of the text
     *  height: <float>, // thickness to extrude text
     *  curveSegments: <int>, // number of points on the curves
     *
     *  bevelEnabled: <bool>, // turn on bevel
     *  bevelThickness: <float>, // how deep into text bevel goes
     *  bevelSize: <float> // how far from text outline is bevel
     * }
     */
    THREE.TextGeometry = function(a, b) {
        b = b || {};
        var c = b.font;
        if (c instanceof THREE.Font == !1) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new THREE.Geometry;
        var d = c.generateShapes(a, b.size, b.curveSegments);
        // translate parameters to ExtrudeGeometry API
        b.amount = void 0 !== b.height ? b.height : 50,
            // defaults
            void 0 === b.bevelThickness && (b.bevelThickness = 10), void 0 === b.bevelSize && (b.bevelSize = 8), void 0 === b.bevelEnabled && (b.bevelEnabled = !1), THREE.ExtrudeGeometry.call(this, d, b), this.type = "TextGeometry"
    }, THREE.TextGeometry.prototype = Object.create(THREE.ExtrudeGeometry.prototype), THREE.TextGeometry.prototype.constructor = THREE.TextGeometry,
    // File:src/extras/geometries/TorusGeometry.js
    /**
     * @author oosmoxiecode
     * @author mrdoob / http://mrdoob.com/
     * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
     */
    THREE.TorusGeometry = function(a, b, c, d, e) {
        THREE.Geometry.call(this), this.type = "TorusGeometry", this.parameters = {
            radius: a,
            tube: b,
            radialSegments: c,
            tubularSegments: d,
            arc: e
        }, a = a || 100, b = b || 40, c = c || 8, d = d || 6, e = e || 2 * Math.PI;
        for (var f = new THREE.Vector3, g = [], h = [], i = 0; c >= i; i++)
            for (var j = 0; d >= j; j++) {
                var k = j / d * e,
                    l = i / c * Math.PI * 2;
                f.x = a * Math.cos(k), f.y = a * Math.sin(k);
                var m = new THREE.Vector3;
                m.x = (a + b * Math.cos(l)) * Math.cos(k), m.y = (a + b * Math.cos(l)) * Math.sin(k), m.z = b * Math.sin(l), this.vertices.push(m), g.push(new THREE.Vector2(j / d, i / c)), h.push(m.clone().sub(f).normalize())
            }
        for (var i = 1; c >= i; i++)
            for (var j = 1; d >= j; j++) {
                var n = (d + 1) * i + j - 1,
                    o = (d + 1) * (i - 1) + j - 1,
                    p = (d + 1) * (i - 1) + j,
                    q = (d + 1) * i + j,
                    r = new THREE.Face3(n, o, q, [h[n].clone(), h[o].clone(), h[q].clone()]);
                this.faces.push(r), this.faceVertexUvs[0].push([g[n].clone(), g[o].clone(), g[q].clone()]), r = new THREE.Face3(o, p, q, [h[o].clone(), h[p].clone(), h[q].clone()]), this.faces.push(r), this.faceVertexUvs[0].push([g[o].clone(), g[p].clone(), g[q].clone()])
            }
        this.computeFaceNormals()
    }, THREE.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry,
    // File:src/extras/geometries/TorusKnotGeometry.js
    /**
     * @author oosmoxiecode
     * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473
     */
    THREE.TorusKnotGeometry = function(a, b, c, d, e, f, g) {
        function h(a, b, c, d, e) {
            var f = Math.cos(a),
                g = Math.sin(a),
                h = b / c * a,
                i = Math.cos(h),
                j = d * (2 + i) * .5 * f,
                k = d * (2 + i) * g * .5,
                l = e * d * Math.sin(h) * .5;
            return new THREE.Vector3(j, k, l)
        }
        THREE.Geometry.call(this), this.type = "TorusKnotGeometry", this.parameters = {
            radius: a,
            tube: b,
            radialSegments: c,
            tubularSegments: d,
            p: e,
            q: f,
            heightScale: g
        }, a = a || 100, b = b || 40, c = c || 64, d = d || 8, e = e || 2, f = f || 3, g = g || 1;
        for (var i = new Array(c), j = new THREE.Vector3, k = new THREE.Vector3, l = new THREE.Vector3, m = 0; c > m; ++m) {
            i[m] = new Array(d);
            var n = m / c * 2 * e * Math.PI,
                o = h(n, f, e, a, g),
                p = h(n + .01, f, e, a, g);
            j.subVectors(p, o), k.addVectors(p, o), l.crossVectors(j, k), k.crossVectors(l, j), l.normalize(), k.normalize();
            for (var q = 0; d > q; ++q) {
                var r = q / d * 2 * Math.PI,
                    s = -b * Math.cos(r),
                    t = b * Math.sin(r),
                    u = new THREE.Vector3;
                u.x = o.x + s * k.x + t * l.x, u.y = o.y + s * k.y + t * l.y, u.z = o.z + s * k.z + t * l.z, i[m][q] = this.vertices.push(u) - 1
            }
        }
        for (var m = 0; c > m; ++m)
            for (var q = 0; d > q; ++q) {
                var v = (m + 1) % c,
                    w = (q + 1) % d,
                    x = i[m][q],
                    y = i[v][q],
                    z = i[v][w],
                    A = i[m][w],
                    B = new THREE.Vector2(m / c, q / d),
                    C = new THREE.Vector2((m + 1) / c, q / d),
                    D = new THREE.Vector2((m + 1) / c, (q + 1) / d),
                    E = new THREE.Vector2(m / c, (q + 1) / d);
                this.faces.push(new THREE.Face3(x, y, A)), this.faceVertexUvs[0].push([B, C, E]), this.faces.push(new THREE.Face3(y, z, A)), this.faceVertexUvs[0].push([C.clone(), D, E.clone()])
            }
        this.computeFaceNormals(), this.computeVertexNormals()
    }, THREE.TorusKnotGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry,
    // File:src/extras/geometries/TubeGeometry.js
    /**
     * @author WestLangley / https://github.com/WestLangley
     * @author zz85 / https://github.com/zz85
     * @author miningold / https://github.com/miningold
     * @author jonobr1 / https://github.com/jonobr1
     *
     * Modified from the TorusKnotGeometry by @oosmoxiecode
     *
     * Creates a tube which extrudes along a 3d spline
     *
     * Uses parallel transport frames as described in
     * http://www.cs.indiana.edu/pub/techreports/TR425.pdf
     */
    THREE.TubeGeometry = function(a, b, c, d, e, f) {
        function g(a, b, c) {
            return D.vertices.push(new THREE.Vector3(a, b, c)) - 1
        }
        THREE.Geometry.call(this), this.type = "TubeGeometry", this.parameters = {
            path: a,
            segments: b,
            radius: c,
            radialSegments: d,
            closed: e,
            taper: f
        }, b = b || 64, c = c || 1, d = d || 8, e = e || !1, f = f || THREE.TubeGeometry.NoTaper;
        var h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, A, B, C = [],
            D = this,
            E = b + 1,
            F = new THREE.Vector3,
            G = new THREE.TubeGeometry.FrenetFrames(a, b, e),
            H = G.tangents,
            I = G.normals,
            J = G.binormals;
        // construct the grid
        for (
            // proxy internals
            this.tangents = H, this.normals = I, this.binormals = J, q = 0; E > q; q++)
            for (C[q] = [], k = q / (E - 1), p = a.getPointAt(k), h = H[q], i = I[q], j = J[q], m = c * f(k), r = 0; d > r; r++) l = r / d * 2 * Math.PI, n = -m * Math.cos(l), o = m * Math.sin(l), F.copy(p), F.x += n * i.x + o * j.x, F.y += n * i.y + o * j.y, F.z += n * i.z + o * j.z, C[q][r] = g(F.x, F.y, F.z);
        // construct the mesh
        for (q = 0; b > q; q++)
            for (r = 0; d > r; r++) s = e ? (q + 1) % b : q + 1, t = (r + 1) % d, u = C[q][r], v = C[s][r], w = C[s][t], x = C[q][t], y = new THREE.Vector2(q / b, r / d), z = new THREE.Vector2((q + 1) / b, r / d), A = new THREE.Vector2((q + 1) / b, (r + 1) / d), B = new THREE.Vector2(q / b, (r + 1) / d), this.faces.push(new THREE.Face3(u, v, x)), this.faceVertexUvs[0].push([y, z, B]), this.faces.push(new THREE.Face3(v, w, x)), this.faceVertexUvs[0].push([z.clone(), A, B.clone()]);
        this.computeFaceNormals(), this.computeVertexNormals()
    }, THREE.TubeGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry, THREE.TubeGeometry.NoTaper = function(a) {
        return 1
    }, THREE.TubeGeometry.SinusoidalTaper = function(a) {
        return Math.sin(Math.PI * a)
    },
    // For computing of Frenet frames, exposing the tangents, normals and binormals the spline
    THREE.TubeGeometry.FrenetFrames = function(a, b, c) {
        /*
        	 function initialNormal1(lastBinormal) {
        	 // fixed start binormal. Has dangers of 0 vectors
        	 normals[ 0 ] = new THREE.Vector3();
        	 binormals[ 0 ] = new THREE.Vector3();
        	 if (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );
        	 normals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();
        	 binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
        	 }

        	 function initialNormal2() {

        	 // This uses the Frenet-Serret formula for deriving binormal
        	 var t2 = path.getTangentAt( epsilon );

        	 normals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();
        	 binormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );

        	 normals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent
        	 binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();

        	 }
        	 */
        function d() {
            // select an initial normal vector perpendicular to the first tangent vector,
            // and in the direction of the smallest tangent xyz component
            n[0] = new THREE.Vector3, o[0] = new THREE.Vector3, f = Number.MAX_VALUE, g = Math.abs(m[0].x), h = Math.abs(m[0].y), i = Math.abs(m[0].z), f >= g && (f = g, l.set(1, 0, 0)), f >= h && (f = h, l.set(0, 1, 0)), f >= i && l.set(0, 0, 1), p.crossVectors(m[0], l).normalize(), n[0].crossVectors(m[0], p), o[0].crossVectors(m[0], n[0])
        }
        var e, f, g, h, i, j, k, l = new THREE.Vector3,
            m = [],
            n = [],
            o = [],
            p = new THREE.Vector3,
            q = new THREE.Matrix4,
            r = b + 1;
        // compute the tangent vectors for each segment on the path
        for (
            // expose internals
            this.tangents = m, this.normals = n, this.binormals = o, j = 0; r > j; j++) k = j / (r - 1), m[j] = a.getTangentAt(k), m[j].normalize();
        // compute the slowly-varying normal and binormal vectors for each segment on the path
        for (d(), j = 1; r > j; j++) n[j] = n[j - 1].clone(), o[j] = o[j - 1].clone(), p.crossVectors(m[j - 1], m[j]), p.length() > Number.EPSILON && (p.normalize(), e = Math.acos(THREE.Math.clamp(m[j - 1].dot(m[j]), -1, 1)), n[j].applyMatrix4(q.makeRotationAxis(p, e))), o[j].crossVectors(m[j], n[j]);
        // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same
        if (c)
            for (e = Math.acos(THREE.Math.clamp(n[0].dot(n[r - 1]), -1, 1)), e /= r - 1, m[0].dot(p.crossVectors(n[0], n[r - 1])) > 0 && (e = -e), j = 1; r > j; j++)
            // twist a little...
                n[j].applyMatrix4(q.makeRotationAxis(m[j], e * j)), o[j].crossVectors(m[j], n[j])
    },
    // File:src/extras/geometries/PolyhedronGeometry.js
    /**
     * @author clockworkgeek / https://github.com/clockworkgeek
     * @author timothypratley / https://github.com/timothypratley
     * @author WestLangley / http://github.com/WestLangley
     */
    THREE.PolyhedronGeometry = function(a, b, c, d) {
        // Project vector onto sphere's surface
        function e(a) {
            var b = a.normalize().clone();
            b.index = k.vertices.push(b) - 1;
            // Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.
            var c = h(a) / 2 / Math.PI + .5,
                d = i(a) / Math.PI + .5;
            return b.uv = new THREE.Vector2(c, 1 - d), b
        }
        // Approximate a curved face with recursively sub-divided triangles.
        function f(a, b, c, d) {
            var e = new THREE.Face3(a.index, b.index, c.index, [a.clone(), b.clone(), c.clone()], void 0, d);
            k.faces.push(e), t.copy(a).add(b).add(c).divideScalar(3);
            var f = h(t);
            k.faceVertexUvs[0].push([j(a.uv, a, f), j(b.uv, b, f), j(c.uv, c, f)])
        }
        // Analytically subdivide a face to the required detail level.
        function g(a, b) {
            // Construct all of the vertices for this subdivision.
            for (var c = Math.pow(2, b), d = e(k.vertices[a.a]), g = e(k.vertices[a.b]), h = e(k.vertices[a.c]), i = [], j = a.materialIndex, l = 0; c >= l; l++) {
                i[l] = [];
                for (var m = e(d.clone().lerp(h, l / c)), n = e(g.clone().lerp(h, l / c)), o = c - l, p = 0; o >= p; p++) 0 === p && l === c ? i[l][p] = m : i[l][p] = e(m.clone().lerp(n, p / o))
            }
            // Construct all of the faces.
            for (var l = 0; c > l; l++)
                for (var p = 0; 2 * (c - l) - 1 > p; p++) {
                    var q = Math.floor(p / 2);
                    p % 2 === 0 ? f(i[l][q + 1], i[l + 1][q], i[l][q], j) : f(i[l][q + 1], i[l + 1][q + 1], i[l + 1][q], j)
                }
        }
        // Angle around the Y axis, counter-clockwise when looking from above.
        function h(a) {
            return Math.atan2(a.z, -a.x)
        }
        // Angle above the XZ plane.
        function i(a) {
            return Math.atan2(-a.y, Math.sqrt(a.x * a.x + a.z * a.z))
        }
        // Texture fixing helper. Spheres have some odd behaviours.
        function j(a, b, c) {
            return 0 > c && 1 === a.x && (a = new THREE.Vector2(a.x - 1, a.y)), 0 === b.x && 0 === b.z && (a = new THREE.Vector2(c / 2 / Math.PI + .5, a.y)), a.clone()
        }
        THREE.Geometry.call(this), this.type = "PolyhedronGeometry", this.parameters = {
            vertices: a,
            indices: b,
            radius: c,
            detail: d
        }, c = c || 1, d = d || 0;
        for (var k = this, l = 0, m = a.length; m > l; l += 3) e(new THREE.Vector3(a[l], a[l + 1], a[l + 2]));
        for (var n = this.vertices, o = [], l = 0, p = 0, m = b.length; m > l; l += 3, p++) {
            var q = n[b[l]],
                r = n[b[l + 1]],
                s = n[b[l + 2]];
            o[p] = new THREE.Face3(q.index, r.index, s.index, [q.clone(), r.clone(), s.clone()], void 0, p)
        }
        for (var t = new THREE.Vector3, l = 0, m = o.length; m > l; l++) g(o[l], d);
        // Handle case when face straddles the seam
        for (var l = 0, m = this.faceVertexUvs[0].length; m > l; l++) {
            var u = this.faceVertexUvs[0][l],
                v = u[0].x,
                w = u[1].x,
                x = u[2].x,
                y = Math.max(v, w, x),
                z = Math.min(v, w, x);
            y > .9 && .1 > z && (
                // 0.9 is somewhat arbitrary
                .2 > v && (u[0].x += 1), .2 > w && (u[1].x += 1), .2 > x && (u[2].x += 1))
        }
        // Apply radius
        for (var l = 0, m = this.vertices.length; m > l; l++) this.vertices[l].multiplyScalar(c);
        // Merge vertices
        this.mergeVertices(), this.computeFaceNormals(), this.boundingSphere = new THREE.Sphere(new THREE.Vector3, c)
    }, THREE.PolyhedronGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry,
    // File:src/extras/geometries/DodecahedronGeometry.js
    /**
     * @author Abe Pazos / https://hamoid.com
     */
    THREE.DodecahedronGeometry = function(a, b) {
        var c = (1 + Math.sqrt(5)) / 2,
            d = 1 / c,
            e = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1,
                // (0, ±1/φ, ±φ)
                0, -d, -c, 0, -d, c, 0, d, -c, 0, d, c,
                // (±1/φ, ±φ, 0)
                -d, -c, 0, -d, c, 0, d, -c, 0, d, c, 0,
                // (±φ, 0, ±1/φ)
                -c, 0, -d, c, 0, -d, -c, 0, d, c, 0, d
            ],
            f = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
        THREE.PolyhedronGeometry.call(this, e, f, a, b), this.type = "DodecahedronGeometry", this.parameters = {
            radius: a,
            detail: b
        }
    }, THREE.DodecahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype), THREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry,
    // File:src/extras/geometries/IcosahedronGeometry.js
    /**
     * @author timothypratley / https://github.com/timothypratley
     */
    THREE.IcosahedronGeometry = function(a, b) {
        var c = (1 + Math.sqrt(5)) / 2,
            d = [-1, c, 0, 1, c, 0, -1, -c, 0, 1, -c, 0, 0, -1, c, 0, 1, c, 0, -1, -c, 0, 1, -c, c, 0, -1, c, 0, 1, -c, 0, -1, -c, 0, 1],
            e = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
        THREE.PolyhedronGeometry.call(this, d, e, a, b), this.type = "IcosahedronGeometry", this.parameters = {
            radius: a,
            detail: b
        }
    }, THREE.IcosahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype), THREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry,
    // File:src/extras/geometries/OctahedronGeometry.js
    /**
     * @author timothypratley / https://github.com/timothypratley
     */
    THREE.OctahedronGeometry = function(a, b) {
        var c = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
            d = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
        THREE.PolyhedronGeometry.call(this, c, d, a, b), this.type = "OctahedronGeometry", this.parameters = {
            radius: a,
            detail: b
        }
    }, THREE.OctahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype), THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry,
    // File:src/extras/geometries/TetrahedronGeometry.js
    /**
     * @author timothypratley / https://github.com/timothypratley
     */
    THREE.TetrahedronGeometry = function(a, b) {
        var c = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
            d = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
        THREE.PolyhedronGeometry.call(this, c, d, a, b), this.type = "TetrahedronGeometry", this.parameters = {
            radius: a,
            detail: b
        }
    }, THREE.TetrahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype), THREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry,
    // File:src/extras/geometries/ParametricGeometry.js
    /**
     * @author zz85 / https://github.com/zz85
     * Parametric Surfaces Geometry
     * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
     *
     * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );
     *
     */
    THREE.ParametricGeometry = function(a, b, c) {
        THREE.Geometry.call(this), this.type = "ParametricGeometry", this.parameters = {
            func: a,
            slices: b,
            stacks: c
        };
        var d, e, f, g, h, i = this.vertices,
            j = this.faces,
            k = this.faceVertexUvs[0],
            l = b + 1;
        for (d = 0; c >= d; d++)
            for (h = d / c, e = 0; b >= e; e++) g = e / b, f = a(g, h), i.push(f);
        var m, n, o, p, q, r, s, t;
        for (d = 0; c > d; d++)
            for (e = 0; b > e; e++) m = d * l + e, n = d * l + e + 1, o = (d + 1) * l + e + 1, p = (d + 1) * l + e, q = new THREE.Vector2(e / b, d / c), r = new THREE.Vector2((e + 1) / b, d / c), s = new THREE.Vector2((e + 1) / b, (d + 1) / c), t = new THREE.Vector2(e / b, (d + 1) / c), j.push(new THREE.Face3(m, n, p)), k.push([q, r, t]), j.push(new THREE.Face3(n, o, p)), k.push([r.clone(), s, t.clone()]);
        // console.log(this);
        // magic bullet
        // var diff = this.mergeVertices();
        // console.log('removed ', diff, ' vertices by merging');
        this.computeFaceNormals(), this.computeVertexNormals()
    }, THREE.ParametricGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry,
    // File:src/extras/geometries/WireframeGeometry.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.WireframeGeometry = function(a) {
        function b(a, b) {
            return a - b
        }
        THREE.BufferGeometry.call(this);
        var c = [0, 0],
            d = {},
            e = ["a", "b", "c"];
        if (a instanceof THREE.Geometry) {
            for (var f = a.vertices, g = a.faces, h = 0, i = new Uint32Array(6 * g.length), j = 0, k = g.length; k > j; j++)
                for (var l = g[j], m = 0; 3 > m; m++) {
                    c[0] = l[e[m]], c[1] = l[e[(m + 1) % 3]], c.sort(b);
                    var n = c.toString();
                    void 0 === d[n] && (i[2 * h] = c[0], i[2 * h + 1] = c[1], d[n] = !0, h++)
                }
            for (var o = new Float32Array(2 * h * 3), j = 0, k = h; k > j; j++)
                for (var m = 0; 2 > m; m++) {
                    var p = f[i[2 * j + m]],
                        q = 6 * j + 3 * m;
                    o[q + 0] = p.x, o[q + 1] = p.y, o[q + 2] = p.z
                }
            this.addAttribute("position", new THREE.BufferAttribute(o, 3))
        } else if (a instanceof THREE.BufferGeometry)
            if (null !== a.index) {
                // Indexed BufferGeometry
                var r = a.index.array,
                    f = a.attributes.position,
                    s = a.groups,
                    h = 0;
                0 === s.length && a.addGroup(0, r.length);
                for (var i = new Uint32Array(2 * r.length), t = 0, u = s.length; u > t; ++t)
                    for (var v = s[t], w = v.start, x = v.count, j = w, y = w + x; y > j; j += 3)
                        for (var m = 0; 3 > m; m++) {
                            c[0] = r[j + m], c[1] = r[j + (m + 1) % 3], c.sort(b);
                            var n = c.toString();
                            void 0 === d[n] && (i[2 * h] = c[0], i[2 * h + 1] = c[1], d[n] = !0, h++)
                        }
                for (var o = new Float32Array(2 * h * 3), j = 0, k = h; k > j; j++)
                    for (var m = 0; 2 > m; m++) {
                        var q = 6 * j + 3 * m,
                            z = i[2 * j + m];
                        o[q + 0] = f.getX(z), o[q + 1] = f.getY(z), o[q + 2] = f.getZ(z)
                    }
                this.addAttribute("position", new THREE.BufferAttribute(o, 3))
            } else {
                for (var f = a.attributes.position.array, h = f.length / 3, A = h / 3, o = new Float32Array(2 * h * 3), j = 0, k = A; k > j; j++)
                    for (var m = 0; 3 > m; m++) {
                        var q = 18 * j + 6 * m,
                            B = 9 * j + 3 * m;
                        o[q + 0] = f[B], o[q + 1] = f[B + 1], o[q + 2] = f[B + 2];
                        var z = 9 * j + 3 * ((m + 1) % 3);
                        o[q + 3] = f[z], o[q + 4] = f[z + 1], o[q + 5] = f[z + 2]
                    }
                this.addAttribute("position", new THREE.BufferAttribute(o, 3))
            }
    }, THREE.WireframeGeometry.prototype = Object.create(THREE.BufferGeometry.prototype), THREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry,
    // File:src/extras/helpers/AxisHelper.js
    /**
     * @author sroucheray / http://sroucheray.org/
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.AxisHelper = function(a) {
        a = a || 1;
        var b = new Float32Array([0, 0, 0, a, 0, 0, 0, 0, 0, 0, a, 0, 0, 0, 0, 0, 0, a]),
            c = new Float32Array([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1]),
            d = new THREE.BufferGeometry;
        d.addAttribute("position", new THREE.BufferAttribute(b, 3)), d.addAttribute("color", new THREE.BufferAttribute(c, 3));
        var e = new THREE.LineBasicMaterial({
            vertexColors: THREE.VertexColors
        });
        THREE.LineSegments.call(this, d, e)
    }, THREE.AxisHelper.prototype = Object.create(THREE.LineSegments.prototype), THREE.AxisHelper.prototype.constructor = THREE.AxisHelper,
    // File:src/extras/helpers/ArrowHelper.js
    /**
     * @author WestLangley / http://github.com/WestLangley
     * @author zz85 / http://github.com/zz85
     * @author bhouston / http://clara.io
     *
     * Creates an arrow for visualizing directions
     *
     * Parameters:
     *  dir - Vector3
     *  origin - Vector3
     *  length - Number
     *  color - color in hex value
     *  headLength - Number
     *  headWidth - Number
     */
    THREE.ArrowHelper = function() {
        var a = new THREE.Geometry;
        a.vertices.push(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0));
        var b = new THREE.CylinderGeometry(0, .5, 1, 5, 1);
        return b.translate(0, -.5, 0),
            function(c, d, e, f, g, h) {
                // dir is assumed to be normalized
                THREE.Object3D.call(this), void 0 === f && (f = 16776960), void 0 === e && (e = 1), void 0 === g && (g = .2 * e), void 0 === h && (h = .2 * g), this.position.copy(d), this.line = new THREE.Line(a, new THREE.LineBasicMaterial({
                    color: f
                })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new THREE.Mesh(b, new THREE.MeshBasicMaterial({
                    color: f
                })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(c), this.setLength(e, g, h)
            }
    }(), THREE.ArrowHelper.prototype = Object.create(THREE.Object3D.prototype), THREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper, THREE.ArrowHelper.prototype.setDirection = function() {
        var a, b = new THREE.Vector3;
        return function(c) {
            // dir is assumed to be normalized
            c.y > .99999 ? this.quaternion.set(0, 0, 0, 1) : c.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (b.set(c.z, 0, -c.x).normalize(), a = Math.acos(c.y), this.quaternion.setFromAxisAngle(b, a))
        }
    }(), THREE.ArrowHelper.prototype.setLength = function(a, b, c) {
        void 0 === b && (b = .2 * a), void 0 === c && (c = .2 * b), this.line.scale.set(1, Math.max(0, a - b), 1), this.line.updateMatrix(), this.cone.scale.set(c, b, c), this.cone.position.y = a, this.cone.updateMatrix()
    }, THREE.ArrowHelper.prototype.setColor = function(a) {
        this.line.material.color.set(a), this.cone.material.color.set(a)
    },
    // File:src/extras/helpers/BoxHelper.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.BoxHelper = function(a) {
        var b = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
            c = new Float32Array(24),
            d = new THREE.BufferGeometry;
        d.setIndex(new THREE.BufferAttribute(b, 1)), d.addAttribute("position", new THREE.BufferAttribute(c, 3)), THREE.LineSegments.call(this, d, new THREE.LineBasicMaterial({
            color: 16776960
        })), void 0 !== a && this.update(a)
    }, THREE.BoxHelper.prototype = Object.create(THREE.LineSegments.prototype), THREE.BoxHelper.prototype.constructor = THREE.BoxHelper, THREE.BoxHelper.prototype.update = function() {
        var a = new THREE.Box3;
        return function(b) {
            if (a.setFromObject(b), !a.isEmpty()) {
                var c = a.min,
                    d = a.max,
                    e = this.geometry.attributes.position,
                    f = e.array;
                f[0] = d.x, f[1] = d.y, f[2] = d.z, f[3] = c.x, f[4] = d.y, f[5] = d.z, f[6] = c.x, f[7] = c.y, f[8] = d.z, f[9] = d.x, f[10] = c.y, f[11] = d.z, f[12] = d.x, f[13] = d.y, f[14] = c.z, f[15] = c.x, f[16] = d.y, f[17] = c.z, f[18] = c.x, f[19] = c.y, f[20] = c.z, f[21] = d.x, f[22] = c.y, f[23] = c.z, e.needsUpdate = !0, this.geometry.computeBoundingSphere()
            }
        }
    }(),
    // File:src/extras/helpers/BoundingBoxHelper.js
    /**
     * @author WestLangley / http://github.com/WestLangley
     */
    // a helper to show the world-axis-aligned bounding box for an object
    THREE.BoundingBoxHelper = function(a, b) {
        var c = void 0 !== b ? b : 8947848;
        this.object = a, this.box = new THREE.Box3, THREE.Mesh.call(this, new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({
            color: c,
            wireframe: !0
        }))
    }, THREE.BoundingBoxHelper.prototype = Object.create(THREE.Mesh.prototype), THREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper, THREE.BoundingBoxHelper.prototype.update = function() {
        this.box.setFromObject(this.object), this.box.size(this.scale), this.box.center(this.position)
    },
    // File:src/extras/helpers/CameraHelper.js
    /**
     * @author alteredq / http://alteredqualia.com/
     *
     *	- shows frustum, line of sight and up of the camera
     *	- suitable for fast updates
     * 	- based on frustum visualization in lightgl.js shadowmap example
     *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
     */
    THREE.CameraHelper = function(a) {
        function b(a, b, d) {
            c(a, d), c(b, d)
        }

        function c(a, b) {
            d.vertices.push(new THREE.Vector3), d.colors.push(new THREE.Color(b)), void 0 === f[a] && (f[a] = []), f[a].push(d.vertices.length - 1)
        }
        var d = new THREE.Geometry,
            e = new THREE.LineBasicMaterial({
                color: 16777215,
                vertexColors: THREE.FaceColors
            }),
            f = {},
            g = 16755200,
            h = 16711680,
            i = 43775,
            j = 16777215,
            k = 3355443;
        // near
        b("n1", "n2", g), b("n2", "n4", g), b("n4", "n3", g), b("n3", "n1", g),
            // far
            b("f1", "f2", g), b("f2", "f4", g), b("f4", "f3", g), b("f3", "f1", g),
            // sides
            b("n1", "f1", g), b("n2", "f2", g), b("n3", "f3", g), b("n4", "f4", g),
            // cone
            b("p", "n1", h), b("p", "n2", h), b("p", "n3", h), b("p", "n4", h),
            // up
            b("u1", "u2", i), b("u2", "u3", i), b("u3", "u1", i),
            // target
            b("c", "t", j), b("p", "c", k),
            // cross
            b("cn1", "cn2", k), b("cn3", "cn4", k), b("cf1", "cf2", k), b("cf3", "cf4", k), THREE.LineSegments.call(this, d, e), this.camera = a, this.camera.updateProjectionMatrix(), this.matrix = a.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = f, this.update()
    }, THREE.CameraHelper.prototype = Object.create(THREE.LineSegments.prototype), THREE.CameraHelper.prototype.constructor = THREE.CameraHelper, THREE.CameraHelper.prototype.update = function() {
        function a(a, f, g, h) {
            d.set(f, g, h).unproject(e);
            var i = c[a];
            if (void 0 !== i)
                for (var j = 0, k = i.length; k > j; j++) b.vertices[i[j]].copy(d)
        }
        var b, c, d = new THREE.Vector3,
            e = new THREE.Camera;
        return function() {
            b = this.geometry, c = this.pointMap;
            var d = 1,
                f = 1;
            // we need just camera projection matrix
            // world matrix must be identity
            e.projectionMatrix.copy(this.camera.projectionMatrix),
                // center / target
                a("c", 0, 0, -1), a("t", 0, 0, 1),
                // near
                a("n1", -d, -f, -1), a("n2", d, -f, -1), a("n3", -d, f, -1), a("n4", d, f, -1),
                // far
                a("f1", -d, -f, 1), a("f2", d, -f, 1), a("f3", -d, f, 1), a("f4", d, f, 1),
                // up
                a("u1", .7 * d, 1.1 * f, -1), a("u2", .7 * -d, 1.1 * f, -1), a("u3", 0, 2 * f, -1),
                // cross
                a("cf1", -d, 0, 1), a("cf2", d, 0, 1), a("cf3", 0, -f, 1), a("cf4", 0, f, 1), a("cn1", -d, 0, -1), a("cn2", d, 0, -1), a("cn3", 0, -f, -1), a("cn4", 0, f, -1), b.verticesNeedUpdate = !0
        }
    }(),
    // File:src/extras/helpers/DirectionalLightHelper.js
    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     * @author WestLangley / http://github.com/WestLangley
     */
    THREE.DirectionalLightHelper = function(a, b) {
        THREE.Object3D.call(this), this.light = a, this.light.updateMatrixWorld(), this.matrix = a.matrixWorld, this.matrixAutoUpdate = !1, b = b || 1;
        var c = new THREE.Geometry;
        c.vertices.push(new THREE.Vector3(-b, b, 0), new THREE.Vector3(b, b, 0), new THREE.Vector3(b, -b, 0), new THREE.Vector3(-b, -b, 0), new THREE.Vector3(-b, b, 0));
        var d = new THREE.LineBasicMaterial({
            fog: !1
        });
        d.color.copy(this.light.color).multiplyScalar(this.light.intensity), this.lightPlane = new THREE.Line(c, d), this.add(this.lightPlane), c = new THREE.Geometry, c.vertices.push(new THREE.Vector3, new THREE.Vector3), d = new THREE.LineBasicMaterial({
            fog: !1
        }), d.color.copy(this.light.color).multiplyScalar(this.light.intensity), this.targetLine = new THREE.Line(c, d), this.add(this.targetLine), this.update()
    }, THREE.DirectionalLightHelper.prototype = Object.create(THREE.Object3D.prototype), THREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper, THREE.DirectionalLightHelper.prototype.dispose = function() {
        this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
    }, THREE.DirectionalLightHelper.prototype.update = function() {
        var a = new THREE.Vector3,
            b = new THREE.Vector3,
            c = new THREE.Vector3;
        return function() {
            a.setFromMatrixPosition(this.light.matrixWorld), b.setFromMatrixPosition(this.light.target.matrixWorld), c.subVectors(b, a), this.lightPlane.lookAt(c), this.lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity), this.targetLine.geometry.vertices[1].copy(c), this.targetLine.geometry.verticesNeedUpdate = !0, this.targetLine.material.color.copy(this.lightPlane.material.color)
        }
    }(),
    // File:src/extras/helpers/EdgesHelper.js
    /**
     * @author WestLangley / http://github.com/WestLangley
     * @param object THREE.Mesh whose geometry will be used
     * @param hex line color
     * @param thresholdAngle the minimum angle (in degrees),
     * between the face normals of adjacent faces,
     * that is required to render an edge. A value of 10 means
     * an edge is only rendered if the angle is at least 10 degrees.
     */
    THREE.EdgesHelper = function(a, b, c) {
        var d = void 0 !== b ? b : 16777215;
        THREE.LineSegments.call(this, new THREE.EdgesGeometry(a.geometry, c), new THREE.LineBasicMaterial({
            color: d
        })), this.matrix = a.matrixWorld, this.matrixAutoUpdate = !1
    }, THREE.EdgesHelper.prototype = Object.create(THREE.LineSegments.prototype), THREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper,
    // File:src/extras/helpers/FaceNormalsHelper.js
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author WestLangley / http://github.com/WestLangley
     */
    THREE.FaceNormalsHelper = function(a, b, c, d) {
        // FaceNormalsHelper only supports THREE.Geometry
        this.object = a, this.size = void 0 !== b ? b : 1;
        var e = void 0 !== c ? c : 16776960,
            f = void 0 !== d ? d : 1,
            g = 0,
            h = this.object.geometry;
        h instanceof THREE.Geometry ? g = h.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
        //
        var i = new THREE.BufferGeometry,
            j = new THREE.Float32Attribute(2 * g * 3, 3);
        i.addAttribute("position", j), THREE.LineSegments.call(this, i, new THREE.LineBasicMaterial({
                color: e,
                linewidth: f
            })),
            //
            this.matrixAutoUpdate = !1, this.update()
    }, THREE.FaceNormalsHelper.prototype = Object.create(THREE.LineSegments.prototype), THREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper, THREE.FaceNormalsHelper.prototype.update = function() {
        var a = new THREE.Vector3,
            b = new THREE.Vector3,
            c = new THREE.Matrix3;
        return function() {
            this.object.updateMatrixWorld(!0), c.getNormalMatrix(this.object.matrixWorld);
            for (var d = this.object.matrixWorld, e = this.geometry.attributes.position, f = this.object.geometry, g = f.vertices, h = f.faces, i = 0, j = 0, k = h.length; k > j; j++) {
                var l = h[j],
                    m = l.normal;
                a.copy(g[l.a]).add(g[l.b]).add(g[l.c]).divideScalar(3).applyMatrix4(d), b.copy(m).applyMatrix3(c).normalize().multiplyScalar(this.size).add(a), e.setXYZ(i, a.x, a.y, a.z), i += 1, e.setXYZ(i, b.x, b.y, b.z), i += 1
            }
            return e.needsUpdate = !0, this
        }
    }(),
    // File:src/extras/helpers/GridHelper.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.GridHelper = function(a, b) {
        var c = new THREE.Geometry,
            d = new THREE.LineBasicMaterial({
                vertexColors: THREE.VertexColors
            });
        this.color1 = new THREE.Color(4473924), this.color2 = new THREE.Color(8947848);
        for (var e = -a; a >= e; e += b) {
            c.vertices.push(new THREE.Vector3(-a, 0, e), new THREE.Vector3(a, 0, e), new THREE.Vector3(e, 0, -a), new THREE.Vector3(e, 0, a));
            var f = 0 === e ? this.color1 : this.color2;
            c.colors.push(f, f, f, f)
        }
        THREE.LineSegments.call(this, c, d)
    }, THREE.GridHelper.prototype = Object.create(THREE.LineSegments.prototype), THREE.GridHelper.prototype.constructor = THREE.GridHelper, THREE.GridHelper.prototype.setColors = function(a, b) {
        this.color1.set(a), this.color2.set(b), this.geometry.colorsNeedUpdate = !0
    },
    // File:src/extras/helpers/HemisphereLightHelper.js
    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.HemisphereLightHelper = function(a, b) {
        THREE.Object3D.call(this), this.light = a, this.light.updateMatrixWorld(), this.matrix = a.matrixWorld, this.matrixAutoUpdate = !1, this.colors = [new THREE.Color, new THREE.Color];
        var c = new THREE.SphereGeometry(b, 4, 2);
        c.rotateX(-Math.PI / 2);
        for (var d = 0, e = 8; e > d; d++) c.faces[d].color = this.colors[4 > d ? 0 : 1];
        var f = new THREE.MeshBasicMaterial({
            vertexColors: THREE.FaceColors,
            wireframe: !0
        });
        this.lightSphere = new THREE.Mesh(c, f), this.add(this.lightSphere), this.update()
    }, THREE.HemisphereLightHelper.prototype = Object.create(THREE.Object3D.prototype), THREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper, THREE.HemisphereLightHelper.prototype.dispose = function() {
        this.lightSphere.geometry.dispose(), this.lightSphere.material.dispose()
    }, THREE.HemisphereLightHelper.prototype.update = function() {
        var a = new THREE.Vector3;
        return function() {
            this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity), this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity), this.lightSphere.lookAt(a.setFromMatrixPosition(this.light.matrixWorld).negate()), this.lightSphere.geometry.colorsNeedUpdate = !0
        }
    }(),
    // File:src/extras/helpers/PointLightHelper.js
    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.PointLightHelper = function(a, b) {
        this.light = a, this.light.updateMatrixWorld();
        var c = new THREE.SphereGeometry(b, 4, 2),
            d = new THREE.MeshBasicMaterial({
                wireframe: !0,
                fog: !1
            });
        d.color.copy(this.light.color).multiplyScalar(this.light.intensity), THREE.Mesh.call(this, c, d), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1
    }, THREE.PointLightHelper.prototype = Object.create(THREE.Mesh.prototype), THREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper, THREE.PointLightHelper.prototype.dispose = function() {
        this.geometry.dispose(), this.material.dispose()
    }, THREE.PointLightHelper.prototype.update = function() {
        this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
    },
    // File:src/extras/helpers/SkeletonHelper.js
    /**
     * @author Sean Griffin / http://twitter.com/sgrif
     * @author Michael Guerrero / http://realitymeltdown.com
     * @author mrdoob / http://mrdoob.com/
     * @author ikerr / http://verold.com
     */
    THREE.SkeletonHelper = function(a) {
        this.bones = this.getBoneList(a);
        for (var b = new THREE.Geometry, c = 0; c < this.bones.length; c++) {
            var d = this.bones[c];
            d.parent instanceof THREE.Bone && (b.vertices.push(new THREE.Vector3), b.vertices.push(new THREE.Vector3), b.colors.push(new THREE.Color(0, 0, 1)), b.colors.push(new THREE.Color(0, 1, 0)))
        }
        b.dynamic = !0;
        var e = new THREE.LineBasicMaterial({
            vertexColors: THREE.VertexColors,
            depthTest: !1,
            depthWrite: !1,
            transparent: !0
        });
        THREE.LineSegments.call(this, b, e), this.root = a, this.matrix = a.matrixWorld, this.matrixAutoUpdate = !1, this.update()
    }, THREE.SkeletonHelper.prototype = Object.create(THREE.LineSegments.prototype), THREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper, THREE.SkeletonHelper.prototype.getBoneList = function(a) {
        var b = [];
        a instanceof THREE.Bone && b.push(a);
        for (var c = 0; c < a.children.length; c++) b.push.apply(b, this.getBoneList(a.children[c]));
        return b
    }, THREE.SkeletonHelper.prototype.update = function() {
        for (var a = this.geometry, b = (new THREE.Matrix4).getInverse(this.root.matrixWorld), c = new THREE.Matrix4, d = 0, e = 0; e < this.bones.length; e++) {
            var f = this.bones[e];
            f.parent instanceof THREE.Bone && (c.multiplyMatrices(b, f.matrixWorld), a.vertices[d].setFromMatrixPosition(c), c.multiplyMatrices(b, f.parent.matrixWorld), a.vertices[d + 1].setFromMatrixPosition(c), d += 2)
        }
        a.verticesNeedUpdate = !0, a.computeBoundingSphere()
    },
    // File:src/extras/helpers/SpotLightHelper.js
    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     * @author WestLangley / http://github.com/WestLangley
     */
    THREE.SpotLightHelper = function(a) {
        THREE.Object3D.call(this), this.light = a, this.light.updateMatrixWorld(), this.matrix = a.matrixWorld, this.matrixAutoUpdate = !1;
        var b = new THREE.CylinderGeometry(0, 1, 1, 8, 1, !0);
        b.translate(0, -.5, 0), b.rotateX(-Math.PI / 2);
        var c = new THREE.MeshBasicMaterial({
            wireframe: !0,
            fog: !1
        });
        this.cone = new THREE.Mesh(b, c), this.add(this.cone), this.update()
    }, THREE.SpotLightHelper.prototype = Object.create(THREE.Object3D.prototype), THREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper, THREE.SpotLightHelper.prototype.dispose = function() {
        this.cone.geometry.dispose(), this.cone.material.dispose()
    }, THREE.SpotLightHelper.prototype.update = function() {
        var a = new THREE.Vector3,
            b = new THREE.Vector3;
        return function() {
            var c = this.light.distance ? this.light.distance : 1e4,
                d = c * Math.tan(this.light.angle);
            this.cone.scale.set(d, d, c), a.setFromMatrixPosition(this.light.matrixWorld), b.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(b.sub(a)), this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
        }
    }(),
    // File:src/extras/helpers/VertexNormalsHelper.js
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author WestLangley / http://github.com/WestLangley
     */
    THREE.VertexNormalsHelper = function(a, b, c, d) {
        this.object = a, this.size = void 0 !== b ? b : 1;
        var e = void 0 !== c ? c : 16711680,
            f = void 0 !== d ? d : 1,
            g = 0,
            h = this.object.geometry;
        h instanceof THREE.Geometry ? g = 3 * h.faces.length : h instanceof THREE.BufferGeometry && (g = h.attributes.normal.count);
        //
        var i = new THREE.BufferGeometry,
            j = new THREE.Float32Attribute(2 * g * 3, 3);
        i.addAttribute("position", j), THREE.LineSegments.call(this, i, new THREE.LineBasicMaterial({
                color: e,
                linewidth: f
            })),
            //
            this.matrixAutoUpdate = !1, this.update()
    }, THREE.VertexNormalsHelper.prototype = Object.create(THREE.LineSegments.prototype), THREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper, THREE.VertexNormalsHelper.prototype.update = function() {
        var a = new THREE.Vector3,
            b = new THREE.Vector3,
            c = new THREE.Matrix3;
        return function() {
            var d = ["a", "b", "c"];
            this.object.updateMatrixWorld(!0), c.getNormalMatrix(this.object.matrixWorld);
            var e = this.object.matrixWorld,
                f = this.geometry.attributes.position,
                g = this.object.geometry;
            if (g instanceof THREE.Geometry)
                for (var h = g.vertices, i = g.faces, j = 0, k = 0, l = i.length; l > k; k++)
                    for (var m = i[k], n = 0, o = m.vertexNormals.length; o > n; n++) {
                        var p = h[m[d[n]]],
                            q = m.vertexNormals[n];
                        a.copy(p).applyMatrix4(e), b.copy(q).applyMatrix3(c).normalize().multiplyScalar(this.size).add(a), f.setXYZ(j, a.x, a.y, a.z), j += 1, f.setXYZ(j, b.x, b.y, b.z), j += 1
                    } else if (g instanceof THREE.BufferGeometry)
                    // for simplicity, ignore index and drawcalls, and render every normal
                        for (var r = g.attributes.position, s = g.attributes.normal, j = 0, n = 0, o = r.count; o > n; n++) a.set(r.getX(n), r.getY(n), r.getZ(n)).applyMatrix4(e), b.set(s.getX(n), s.getY(n), s.getZ(n)), b.applyMatrix3(c).normalize().multiplyScalar(this.size).add(a), f.setXYZ(j, a.x, a.y, a.z), j += 1, f.setXYZ(j, b.x, b.y, b.z), j += 1;
            return f.needsUpdate = !0, this
        }
    }(),
    // File:src/extras/helpers/WireframeHelper.js
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    THREE.WireframeHelper = function(a, b) {
        var c = void 0 !== b ? b : 16777215;
        THREE.LineSegments.call(this, new THREE.WireframeGeometry(a.geometry), new THREE.LineBasicMaterial({
            color: c
        })), this.matrix = a.matrixWorld, this.matrixAutoUpdate = !1
    }, THREE.WireframeHelper.prototype = Object.create(THREE.LineSegments.prototype), THREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper,
    // File:src/extras/objects/ImmediateRenderObject.js
    /**
     * @author alteredq / http://alteredqualia.com/
     */
    THREE.ImmediateRenderObject = function(a) {
        THREE.Object3D.call(this), this.material = a, this.render = function(a) {}
    }, THREE.ImmediateRenderObject.prototype = Object.create(THREE.Object3D.prototype), THREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject,
    // File:src/extras/objects/MorphBlendMesh.js
    /**
     * @author alteredq / http://alteredqualia.com/
     */
    THREE.MorphBlendMesh = function(a, b) {
        THREE.Mesh.call(this, a, b), this.animationsMap = {}, this.animationsList = [];
        // prepare default animation
        // (all frames played together in 1 second)
        var c = this.geometry.morphTargets.length,
            d = "__default",
            e = 0,
            f = c - 1,
            g = c / 1;
        this.createAnimation(d, e, f, g), this.setAnimationWeight(d, 1)
    }, THREE.MorphBlendMesh.prototype = Object.create(THREE.Mesh.prototype), THREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh, THREE.MorphBlendMesh.prototype.createAnimation = function(a, b, c, d) {
        var e = {
            start: b,
            end: c,
            length: c - b + 1,
            fps: d,
            duration: (c - b) / d,
            lastFrame: 0,
            currentFrame: 0,
            active: !1,
            time: 0,
            direction: 1,
            weight: 1,
            directionBackwards: !1,
            mirroredLoop: !1
        };
        this.animationsMap[a] = e, this.animationsList.push(e)
    }, THREE.MorphBlendMesh.prototype.autoCreateAnimations = function(a) {
        for (var b, c = /([a-z]+)_?(\d+)/i, d = {}, e = this.geometry, f = 0, g = e.morphTargets.length; g > f; f++) {
            var h = e.morphTargets[f],
                i = h.name.match(c);
            if (i && i.length > 1) {
                var j = i[1];
                d[j] || (d[j] = {
                    start: 1 / 0,
                    end: -(1 / 0)
                });
                var k = d[j];
                f < k.start && (k.start = f), f > k.end && (k.end = f), b || (b = j)
            }
        }
        for (var j in d) {
            var k = d[j];
            this.createAnimation(j, k.start, k.end, a)
        }
        this.firstAnimation = b
    }, THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function(a) {
        var b = this.animationsMap[a];
        b && (b.direction = 1, b.directionBackwards = !1)
    }, THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function(a) {
        var b = this.animationsMap[a];
        b && (b.direction = -1, b.directionBackwards = !0)
    }, THREE.MorphBlendMesh.prototype.setAnimationFPS = function(a, b) {
        var c = this.animationsMap[a];
        c && (c.fps = b, c.duration = (c.end - c.start) / c.fps)
    }, THREE.MorphBlendMesh.prototype.setAnimationDuration = function(a, b) {
        var c = this.animationsMap[a];
        c && (c.duration = b, c.fps = (c.end - c.start) / c.duration)
    }, THREE.MorphBlendMesh.prototype.setAnimationWeight = function(a, b) {
        var c = this.animationsMap[a];
        c && (c.weight = b)
    }, THREE.MorphBlendMesh.prototype.setAnimationTime = function(a, b) {
        var c = this.animationsMap[a];
        c && (c.time = b)
    }, THREE.MorphBlendMesh.prototype.getAnimationTime = function(a) {
        var b = 0,
            c = this.animationsMap[a];
        return c && (b = c.time), b
    }, THREE.MorphBlendMesh.prototype.getAnimationDuration = function(a) {
        var b = -1,
            c = this.animationsMap[a];
        return c && (b = c.duration), b
    }, THREE.MorphBlendMesh.prototype.playAnimation = function(a) {
        var b = this.animationsMap[a];
        b ? (b.time = 0, b.active = !0) : console.warn("THREE.MorphBlendMesh: animation[" + a + "] undefined in .playAnimation()")
    }, THREE.MorphBlendMesh.prototype.stopAnimation = function(a) {
        var b = this.animationsMap[a];
        b && (b.active = !1)
    }, THREE.MorphBlendMesh.prototype.update = function(a) {
        for (var b = 0, c = this.animationsList.length; c > b; b++) {
            var d = this.animationsList[b];
            if (d.active) {
                var e = d.duration / d.length;
                d.time += d.direction * a, d.mirroredLoop ? (d.time > d.duration || d.time < 0) && (d.direction *= -1, d.time > d.duration && (d.time = d.duration, d.directionBackwards = !0), d.time < 0 && (d.time = 0, d.directionBackwards = !1)) : (d.time = d.time % d.duration, d.time < 0 && (d.time += d.duration));
                var f = d.start + THREE.Math.clamp(Math.floor(d.time / e), 0, d.length - 1),
                    g = d.weight;
                f !== d.currentFrame && (this.morphTargetInfluences[d.lastFrame] = 0, this.morphTargetInfluences[d.currentFrame] = 1 * g, this.morphTargetInfluences[f] = 0, d.lastFrame = d.currentFrame, d.currentFrame = f);
                var h = d.time % e / e;
                d.directionBackwards && (h = 1 - h), d.currentFrame !== d.lastFrame ? (this.morphTargetInfluences[d.currentFrame] = h * g, this.morphTargetInfluences[d.lastFrame] = (1 - h) * g) : this.morphTargetInfluences[d.currentFrame] = g
            }
        }
    }; // This THREEx helper makes it easy to handle window resize.
// It will update renderer and camera when window is resized.
//
// # Usage
//
// **Step 1**: Start updating renderer and camera
//
// ```var windowResize = new THREEx.WindowResize(aRenderer, aCamera)```
//    
// **Step 2**: stop updating renderer and camera
//
// ```windowResize.destroy()```
// # Code
//
/** @namespace */
var THREEx = THREEx || {};
/**
 * Update renderer and camera when the window is resized
 * 
 * @param {Object} renderer the renderer to update
 * @param {Object} Camera the camera to update
 * @param {Function} dimension callback for renderer size
 */
THREEx.WindowResize = function(a, b, c) {
    c = c || function() {
        return {
            width: window.innerWidth,
            height: window.innerHeight
        }
    };
    var d = function() {
        // fetch target renderer size
        var d = c();
        // notify the renderer of the size change
        a.setSize(d.width, d.height),
            // update the camera
            b.aspect = d.width / d.height, b.updateProjectionMatrix()
    };
    // return .stop() the function to stop watching window resize
    // bind the resize event
    return window.addEventListener("resize", d, !1), {
        trigger: function() {
            d()
        },
        /**
         * Stop watching window resize
         */
        destroy: function() {
            window.removeEventListener("resize", d)
        }
    }
};
/*!
 * VERSION: 1.15.3
 * DATE: 2015-12-22
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2016, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/
var _gsScope = "undefined" != typeof module && module.exports && "undefined" != typeof global ? global : this || window; //helps ensure compatibility with AMD/RequireJS and CommonJS/Node
(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push(function() {
        "use strict";
        _gsScope._gsDefine("easing.Back", ["easing.Ease"], function(a) {
            var b, c, d, e = _gsScope.GreenSockGlobals || _gsScope,
                f = e.com.greensock,
                g = 2 * Math.PI,
                h = Math.PI / 2,
                i = f._class,
                j = function(b, c) {
                    var d = i("easing." + b, function() {}, !0),
                        e = d.prototype = new a;
                    return e.constructor = d, e.getRatio = c, d
                },
                k = a.register || function() {}, //put an empty function in place just as a safety measure in case someone loads an OLD version of TweenLite.js where Ease.register doesn't exist.
                l = function(a, b, c, d, e) {
                    var f = i("easing." + a, {
                        easeOut: new b,
                        easeIn: new c,
                        easeInOut: new d
                    }, !0);
                    return k(f, a), f
                },
                m = function(a, b, c) {
                    this.t = a, this.v = b, c && (this.next = c, c.prev = this, this.c = c.v - b, this.gap = c.t - a)
                },
                //Back
                n = function(b, c) {
                    var d = i("easing." + b, function(a) {
                            this._p1 = a || 0 === a ? a : 1.70158, this._p2 = 1.525 * this._p1
                        }, !0),
                        e = d.prototype = new a;
                    return e.constructor = d, e.getRatio = c, e.config = function(a) {
                        return new d(a)
                    }, d
                },
                o = l("Back", n("BackOut", function(a) {
                    return (a -= 1) * a * ((this._p1 + 1) * a + this._p1) + 1
                }), n("BackIn", function(a) {
                    return a * a * ((this._p1 + 1) * a - this._p1)
                }), n("BackInOut", function(a) {
                    return (a *= 2) < 1 ? .5 * a * a * ((this._p2 + 1) * a - this._p2) : .5 * ((a -= 2) * a * ((this._p2 + 1) * a + this._p2) + 2)
                })),
                //SlowMo
                p = i("easing.SlowMo", function(a, b, c) {
                    b = b || 0 === b ? b : .7, null == a ? a = .7 : a > 1 && (a = 1), this._p = 1 !== a ? b : 0, this._p1 = (1 - a) / 2, this._p2 = a, this._p3 = this._p1 + this._p2, this._calcEnd = c === !0
                }, !0),
                q = p.prototype = new a;
            //SteppedEase
            //RoughEase
            //Bounce
            //CIRC
            //Elastic
            //Expo
            //Sine
            //register the non-standard eases
            return q.constructor = p, q.getRatio = function(a) {
                var b = a + (.5 - a) * this._p;
                return a < this._p1 ? this._calcEnd ? 1 - (a = 1 - a / this._p1) * a : b - (a = 1 - a / this._p1) * a * a * a * b : a > this._p3 ? this._calcEnd ? 1 - (a = (a - this._p3) / this._p1) * a : b + (a - b) * (a = (a - this._p3) / this._p1) * a * a * a : this._calcEnd ? 1 : b
            }, p.ease = new p(.7, .7), q.config = p.config = function(a, b, c) {
                return new p(a, b, c)
            }, b = i("easing.SteppedEase", function(a) {
                a = a || 1, this._p1 = 1 / a, this._p2 = a + 1
            }, !0), q = b.prototype = new a, q.constructor = b, q.getRatio = function(a) {
                return 0 > a ? a = 0 : a >= 1 && (a = .999999999), (this._p2 * a >> 0) * this._p1
            }, q.config = b.config = function(a) {
                return new b(a)
            }, c = i("easing.RoughEase", function(b) {
                b = b || {};
                for (var c, d, e, f, g, h, i = b.taper || "none", j = [], k = 0, l = 0 | (b.points || 20), n = l, o = b.randomize !== !1, p = b.clamp === !0, q = b.template instanceof a ? b.template : null, r = "number" == typeof b.strength ? .4 * b.strength : .4; --n > -1;) c = o ? Math.random() : 1 / l * n, d = q ? q.getRatio(c) : c, "none" === i ? e = r : "out" === i ? (f = 1 - c, e = f * f * r) : "in" === i ? e = c * c * r : .5 > c ? (f = 2 * c, e = f * f * .5 * r) : (f = 2 * (1 - c), e = f * f * .5 * r), o ? d += Math.random() * e - .5 * e : n % 2 ? d += .5 * e : d -= .5 * e, p && (d > 1 ? d = 1 : 0 > d && (d = 0)), j[k++] = {
                    x: c,
                    y: d
                };
                for (j.sort(function(a, b) {
                        return a.x - b.x
                    }), h = new m(1, 1, null), n = l; --n > -1;) g = j[n], h = new m(g.x, g.y, h);
                this._prev = new m(0, 0, 0 !== h.t ? h : h.next)
            }, !0), q = c.prototype = new a, q.constructor = c, q.getRatio = function(a) {
                var b = this._prev;
                if (a > b.t) {
                    for (; b.next && a >= b.t;) b = b.next;
                    b = b.prev
                } else
                    for (; b.prev && a <= b.t;) b = b.prev;
                return this._prev = b, b.v + (a - b.t) / b.gap * b.c
            }, q.config = function(a) {
                return new c(a)
            }, c.ease = new c, l("Bounce", j("BounceOut", function(a) {
                return 1 / 2.75 > a ? 7.5625 * a * a : 2 / 2.75 > a ? 7.5625 * (a -= 1.5 / 2.75) * a + .75 : 2.5 / 2.75 > a ? 7.5625 * (a -= 2.25 / 2.75) * a + .9375 : 7.5625 * (a -= 2.625 / 2.75) * a + .984375
            }), j("BounceIn", function(a) {
                return (a = 1 - a) < 1 / 2.75 ? 1 - 7.5625 * a * a : 2 / 2.75 > a ? 1 - (7.5625 * (a -= 1.5 / 2.75) * a + .75) : 2.5 / 2.75 > a ? 1 - (7.5625 * (a -= 2.25 / 2.75) * a + .9375) : 1 - (7.5625 * (a -= 2.625 / 2.75) * a + .984375)
            }), j("BounceInOut", function(a) {
                var b = .5 > a;
                return a = b ? 1 - 2 * a : 2 * a - 1, a = 1 / 2.75 > a ? 7.5625 * a * a : 2 / 2.75 > a ? 7.5625 * (a -= 1.5 / 2.75) * a + .75 : 2.5 / 2.75 > a ? 7.5625 * (a -= 2.25 / 2.75) * a + .9375 : 7.5625 * (a -= 2.625 / 2.75) * a + .984375, b ? .5 * (1 - a) : .5 * a + .5
            })), l("Circ", j("CircOut", function(a) {
                return Math.sqrt(1 - (a -= 1) * a)
            }), j("CircIn", function(a) {
                return -(Math.sqrt(1 - a * a) - 1)
            }), j("CircInOut", function(a) {
                return (a *= 2) < 1 ? -.5 * (Math.sqrt(1 - a * a) - 1) : .5 * (Math.sqrt(1 - (a -= 2) * a) + 1)
            })), d = function(b, c, d) {
                var e = i("easing." + b, function(a, b) {
                        this._p1 = a >= 1 ? a : 1, this._p2 = (b || d) / (1 > a ? a : 1), this._p3 = this._p2 / g * (Math.asin(1 / this._p1) || 0), this._p2 = g / this._p2
                    }, !0),
                    f = e.prototype = new a;
                return f.constructor = e, f.getRatio = c, f.config = function(a, b) {
                    return new e(a, b)
                }, e
            }, l("Elastic", d("ElasticOut", function(a) {
                return this._p1 * Math.pow(2, -10 * a) * Math.sin((a - this._p3) * this._p2) + 1
            }, .3), d("ElasticIn", function(a) {
                return -(this._p1 * Math.pow(2, 10 * (a -= 1)) * Math.sin((a - this._p3) * this._p2))
            }, .3), d("ElasticInOut", function(a) {
                return (a *= 2) < 1 ? -.5 * (this._p1 * Math.pow(2, 10 * (a -= 1)) * Math.sin((a - this._p3) * this._p2)) : this._p1 * Math.pow(2, -10 * (a -= 1)) * Math.sin((a - this._p3) * this._p2) * .5 + 1
            }, .45)), l("Expo", j("ExpoOut", function(a) {
                return 1 - Math.pow(2, -10 * a)
            }), j("ExpoIn", function(a) {
                return Math.pow(2, 10 * (a - 1)) - .001
            }), j("ExpoInOut", function(a) {
                return (a *= 2) < 1 ? .5 * Math.pow(2, 10 * (a - 1)) : .5 * (2 - Math.pow(2, -10 * (a - 1)))
            })), l("Sine", j("SineOut", function(a) {
                return Math.sin(a * h)
            }), j("SineIn", function(a) {
                return -Math.cos(a * h) + 1
            }), j("SineInOut", function(a) {
                return -.5 * (Math.cos(Math.PI * a) - 1)
            })), i("easing.EaseLookup", {
                find: function(b) {
                    return a.map[b]
                }
            }, !0), k(e.SlowMo, "SlowMo", "ease,"), k(c, "RoughEase", "ease,"), k(b, "SteppedEase", "ease,"), o
        }, !0)
    }), _gsScope._gsDefine && _gsScope._gsQueue.pop()(),
    //export to AMD/RequireJS and CommonJS/Node (precursor to full modular build system coming at a later date)
    function() {
        "use strict";
        var a = function() {
            return _gsScope.GreenSockGlobals || _gsScope
        };
        "function" == typeof define && define.amd ? //AMD
            define(["TweenLite"], a) : "undefined" != typeof module && module.exports && ( //node
                require("../TweenLite.js"), module.exports = a())
    }();
/*!
 * VERSION: 1.18.4
 * DATE: 2016-04-26
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2016, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 */
var _gsScope = "undefined" != typeof module && module.exports && "undefined" != typeof global ? global : this || window; //helps ensure compatibility with AMD/RequireJS and CommonJS/Node
(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push(function() {
        "use strict";
        _gsScope._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], function(a, b) { /** @constructor **/
            var c, //turns true whenever a CSSPropTween instance is created that has a priority other than 0. This helps us discern whether or not we should spend the time organizing the linked list or not after a CSSPlugin's _onInitTween() method is called.
                d, //we set this in _onInitTween() each time as a way to have a persistent variable we can use in other methods like _parse() without having to pass it around as a parameter and we keep _parse() decoupled from a particular CSSPlugin instance
                e, //computed style (we store this in a shared variable to conserve memory and make minification tighter
                f, g = function() {
                    a.call(this, "css"), this._overwriteProps.length = 0, this.setRatio = g.prototype.setRatio
                },
                h = _gsScope._gsDefine.globals, //alias to the currently instantiating CSSPlugin's _overwriteProps array. We use this closure in order to avoid having to pass a reference around from method to method and aid in minification.
                i = {},
                j = g.prototype = new a("css");
            j.constructor = g, g.version = "1.18.4", g.API = 2, g.defaultTransformPerspective = 0, g.defaultSkewType = "compensated", g.defaultSmoothOrigin = !0, j = "px", g.suffixMap = {
                top: j,
                right: j,
                bottom: j,
                left: j,
                width: j,
                height: j,
                fontSize: j,
                padding: j,
                margin: j,
                perspective: j,
                lineHeight: ""
            };
            var k, l, //we won't apply the Safari transform fix until we actually come across a tween that affects a transform property (to maintain best performance).
                m, n, //Firefox has a bug that causes 3D transformed elements to randomly disappear unless a repaint is forced after each update on each element.
                o, //Safari (and Android 4 which uses a flavor of Safari) has a bug that prevents changes to "top" and "left" properties from rendering properly if changed on the same frame as a transform UNLESS we set the element's WebkitBackfaceVisibility to hidden (weird, I know). Doing this for Android 3 and earlier seems to actually cause other problems, though (fun!)
                p, q = /(?:\-|\.|\b)(\d|\.|e\-)+/g,
                r = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
                s = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi, //finds all the values that begin with numbers or += or -= and then a number. Includes suffixes. We use this to split complex values apart like "1px 5px 20px rgb(255,102,51)"
                t = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g, //also allows scientific notation and doesn't kill the leading -/+ in -= and +=
                u = /(?:\d|\-|\+|=|#|\.)*/g,
                v = /opacity *= *([^)]*)/i,
                w = /opacity:([^;]*)/i,
                x = /alpha\(opacity *=.+?\)/i,
                y = /^(rgb|hsl)/,
                z = /([A-Z])/g,
                A = /-([a-z])/gi,
                B = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi, //for pulling out urls from url(...) or url("...") strings (some browsers wrap urls in quotes, some don't when reporting things like backgroundImage)
                C = function(a, b) {
                    return b.toUpperCase()
                },
                D = /(?:Left|Right|Width)/i,
                E = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
                F = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
                G = /,(?=[^\)]*(?:\(|$))/gi, //finds any commas that are not within parenthesis
                H = /[\s,\(]/i, //for testing a string to find if it has a space, comma, or open parenthesis (clues that it's a complex value)
                I = Math.PI / 180,
                J = 180 / Math.PI,
                K = {},
                L = document,
                M = function(a) {
                    return L.createElementNS ? L.createElementNS("http://www.w3.org/1999/xhtml", a) : L.createElement(a)
                },
                N = M("div"),
                O = M("img"),
                P = g._internals = {
                    _specialProps: i
                }, //provides a hook to a few internal methods that we need to access from inside other plugins
                Q = navigator.userAgent,
                R = function() { //we set _isSafari, _ieVers, _isFirefox, and _supportsOpacity all in one function here to reduce file size slightly, especially in the minified version.
                    var a = Q.indexOf("Android"),
                        b = M("a");
                    return m = -1 !== Q.indexOf("Safari") && -1 === Q.indexOf("Chrome") && (-1 === a || Number(Q.substr(a + 8, 1)) > 3), o = m && Number(Q.substr(Q.indexOf("Version/") + 8, 1)) < 6, n = -1 !== Q.indexOf("Firefox"), (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(Q) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(Q)) && (p = parseFloat(RegExp.$1)), b ? (b.style.cssText = "top:1px;opacity:.55;", /^0.55/.test(b.style.opacity)) : !1
                }(),
                S = function(a) {
                    return v.test("string" == typeof a ? a : (a.currentStyle ? a.currentStyle.filter : a.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1
                },
                T = function(a) { //for logging messages, but in a way that won't throw errors in old versions of IE.
                    window.console && console.log(a)
                },
                U = "", //the non-camelCase vendor prefix like "-o-", "-moz-", "-ms-", or "-webkit-"
                V = "", //camelCase vendor prefix like "O", "ms", "Webkit", or "Moz".
                // @private feed in a camelCase property name like "transform" and it will check to see if it is valid as-is or if it needs a vendor prefix. It returns the corrected camelCase property name (i.e. "WebkitTransform" or "MozTransform" or "transform" or null if no such property is found, like if the browser is IE8 or before, "transform" won't be found at all)
                W = function(a, b) {
                    b = b || N;
                    var c, d, e = b.style;
                    if (void 0 !== e[a]) return a;
                    for (a = a.charAt(0).toUpperCase() + a.substr(1), c = ["O", "Moz", "ms", "Ms", "Webkit"], d = 5; --d > -1 && void 0 === e[c[d] + a];);
                    return d >= 0 ? (V = 3 === d ? "ms" : c[d], U = "-" + V.toLowerCase() + "-", V + a) : null
                },
                X = L.defaultView ? L.defaultView.getComputedStyle : function() {},
                /**
                 * @private Returns the css style for a particular property of an element. For example, to get whatever the current "left" css value for an element with an ID of "myElement", you could do:
                 * var currentLeft = CSSPlugin.getStyle( document.getElementById("myElement"), "left");
                 *
                 * @param {!Object} t Target element whose style property you want to query
                 * @param {!string} p Property name (like "left" or "top" or "marginTop", etc.)
                 * @param {Object=} cs Computed style object. This just provides a way to speed processing if you're going to get several properties on the same element in quick succession - you can reuse the result of the getComputedStyle() call.
                 * @param {boolean=} calc If true, the value will not be read directly from the element's "style" property (if it exists there), but instead the getComputedStyle() result will be used. This can be useful when you want to ensure that the browser itself is interpreting the value.
                 * @param {string=} dflt Default value that should be returned in the place of null, "none", "auto" or "auto auto".
                 * @return {?string} The current property value
                 */
                Y = g.getStyle = function(a, b, c, d, e) {
                    var f;
                    return R || "opacity" !== b ? (!d && a.style[b] ? f = a.style[b] : (c = c || X(a)) ? f = c[b] || c.getPropertyValue(b) || c.getPropertyValue(b.replace(z, "-$1").toLowerCase()) : a.currentStyle && (f = a.currentStyle[b]), null == e || f && "none" !== f && "auto" !== f && "auto auto" !== f ? f : e) : S(a)
                },
                /**
                 * @private Pass the target element, the property name, the numeric value, and the suffix (like "%", "em", "px", etc.) and it will spit back the equivalent pixel number.
                 * @param {!Object} t Target element
                 * @param {!string} p Property name (like "left", "top", "marginLeft", etc.)
                 * @param {!number} v Value
                 * @param {string=} sfx Suffix (like "px" or "%" or "em")
                 * @param {boolean=} recurse If true, the call is a recursive one. In some browsers (like IE7/8), occasionally the value isn't accurately reported initially, but if we run the function again it will take effect.
                 * @return {number} value in pixels
                 */
                Z = P.convertToPixels = function(a, c, d, e, f) {
                    if ("px" === e || !e) return d;
                    if ("auto" === e || !d) return 0;
                    var h, i, j, k = D.test(c),
                        l = a,
                        m = N.style,
                        n = 0 > d;
                    if (n && (d = -d), "%" === e && -1 !== c.indexOf("border")) h = d / 100 * (k ? a.clientWidth : a.clientHeight);
                    else {
                        if (m.cssText = "border:0 solid red;position:" + Y(a, "position") + ";line-height:0;", "%" !== e && l.appendChild && "v" !== e.charAt(0) && "rem" !== e) m[k ? "borderLeftWidth" : "borderTopWidth"] = d + e;
                        else {
                            if (l = a.parentNode || L.body, i = l._gsCache, j = b.ticker.frame, i && k && i.time === j) //performance optimization: we record the width of elements along with the ticker frame so that we can quickly get it again on the same tick (seems relatively safe to assume it wouldn't change on the same tick)
                                return i.width * d / 100;
                            m[k ? "width" : "height"] = d + e
                        }
                        l.appendChild(N), h = parseFloat(N[k ? "offsetWidth" : "offsetHeight"]), l.removeChild(N), k && "%" === e && g.cacheWidths !== !1 && (i = l._gsCache = l._gsCache || {}, i.time = j, i.width = h / d * 100), 0 !== h || f || (h = Z(a, c, d, e, !0))
                    }
                    return n ? -h : h
                },
                $ = P.calculateOffset = function(a, b, c) { //for figuring out "top" or "left" in px when it's "auto". We need to factor in margin with the offsetLeft/offsetTop
                    if ("absolute" !== Y(a, "position", c)) return 0;
                    var d = "left" === b ? "Left" : "Top",
                        e = Y(a, "margin" + d, c);
                    return a["offset" + d] - (Z(a, b, parseFloat(e), e.replace(u, "")) || 0)
                },
                // @private returns at object containing ALL of the style properties in camelCase and their associated values.
                _ = function(a, b) {
                    var c, d, e, f = {};
                    if (b = b || X(a, null))
                        if (c = b.length)
                            for (; --c > -1;) e = b[c], -1 !== e.indexOf("-transform") && Aa !== e || (f[e.replace(A, C)] = b.getPropertyValue(e));
                        else //some browsers behave differently - cs.length is always 0, so we must do a for...in loop.
                            for (c in b) - 1 !== c.indexOf("Transform") && za !== c || ( //Some webkit browsers duplicate transform values, one non-prefixed and one prefixed ("transform" and "WebkitTransform"), so we must weed out the extra one here.
                            f[c] = b[c]);
                    else if (b = a.currentStyle || a.style)
                        for (c in b) "string" == typeof c && void 0 === f[c] && (f[c.replace(A, C)] = b[c]);
                    return R || (f.opacity = S(a)), d = Na(a, b, !1), f.rotation = d.rotation, f.skewX = d.skewX, f.scaleX = d.scaleX, f.scaleY = d.scaleY, f.x = d.x, f.y = d.y, Ca && (f.z = d.z, f.rotationX = d.rotationX, f.rotationY = d.rotationY, f.scaleZ = d.scaleZ), f.filters && delete f.filters, f
                },
                // @private analyzes two style objects (as returned by _getAllStyles()) and only looks for differences between them that contain tweenable values (like a number or color). It returns an object with a "difs" property which refers to an object containing only those isolated properties and values for tweening, and a "firstMPT" property which refers to the first MiniPropTween instance in a linked list that recorded all the starting values of the different properties so that we can revert to them at the end or beginning of the tween - we don't want the cascading to get messed up. The forceLookup parameter is an optional generic object with properties that should be forced into the results - this is necessary for className tweens that are overwriting others because imagine a scenario where a rollover/rollout adds/removes a class and the user swipes the mouse over the target SUPER fast, thus nothing actually changed yet and the subsequent comparison of the properties would indicate they match (especially when px rounding is taken into consideration), thus no tweening is necessary even though it SHOULD tween and remove those properties after the tween (otherwise the inline styles will contaminate things). See the className SpecialProp code for details.
                aa = function(a, b, c, d, e) {
                    var f, g, h, i = {},
                        j = a.style;
                    for (g in c) "cssText" !== g && "length" !== g && isNaN(g) && (b[g] !== (f = c[g]) || e && e[g]) && -1 === g.indexOf("Origin") && ("number" != typeof f && "string" != typeof f || (i[g] = "auto" !== f || "left" !== g && "top" !== g ? "" !== f && "auto" !== f && "none" !== f || "string" != typeof b[g] || "" === b[g].replace(t, "") ? f : 0 : $(a, g), //if the ending value is defaulting ("" or "auto"), we check the starting value and if it can be parsed into a number (a string which could have a suffix too, like 700px), then we swap in 0 for "" or "auto" so that things actually tween.
                        void 0 !== j[g] && ( //for className tweens, we must remember which properties already existed inline - the ones that didn't should be removed when the tween isn't in progress because they were only introduced to facilitate the transition between classes.
                            h = new pa(j, g, j[g], h))));
                    if (d)
                        for (g in d) //copy properties (except className)
                            "className" !== g && (i[g] = d[g]);
                    return {
                        difs: i,
                        firstMPT: h
                    }
                },
                ba = {
                    width: ["Left", "Right"],
                    height: ["Top", "Bottom"]
                },
                ca = ["marginLeft", "marginRight", "marginTop", "marginBottom"],
                /**
                 * @private Gets the width or height of an element
                 * @param {!Object} t Target element
                 * @param {!string} p Property name ("width" or "height")
                 * @param {Object=} cs Computed style object (if one exists). Just a speed optimization.
                 * @return {number} Dimension (in pixels)
                 */
                da = function(a, b, c) {
                    if ("svg" === (a.nodeName + "").toLowerCase()) //Chrome no longer supports offsetWidth/offsetHeight on SVG elements.
                        return (c || X(a))[b] || 0;
                    if (a.getBBox && Ka(a)) return a.getBBox()[b] || 0;
                    var d = parseFloat("width" === b ? a.offsetWidth : a.offsetHeight),
                        e = ba[b],
                        f = e.length;
                    for (c = c || X(a, null); --f > -1;) d -= parseFloat(Y(a, "padding" + e[f], c, !0)) || 0, d -= parseFloat(Y(a, "border" + e[f] + "Width", c, !0)) || 0;
                    return d
                },
                // @private Parses position-related complex strings like "top left" or "50px 10px" or "70% 20%", etc. which are used for things like transformOrigin or backgroundPosition. Optionally decorates a supplied object (recObj) with the following properties: "ox" (offsetX), "oy" (offsetY), "oxp" (if true, "ox" is a percentage not a pixel value), and "oxy" (if true, "oy" is a percentage not a pixel value)
                ea = function(a, b) {
                    if ("contain" === a || "auto" === a || "auto auto" === a) return a + " ";
                    null != a && "" !== a || ( //note: Firefox uses "auto auto" as default whereas Chrome uses "auto".
                        a = "0 0");
                    var c, d = a.split(" "),
                        e = -1 !== a.indexOf("left") ? "0%" : -1 !== a.indexOf("right") ? "100%" : d[0],
                        f = -1 !== a.indexOf("top") ? "0%" : -1 !== a.indexOf("bottom") ? "100%" : d[1];
                    if (d.length > 3 && !b) {
                        for (d = a.split(", ").join(",").split(","), a = [], c = 0; c < d.length; c++) a.push(ea(d[c]));
                        return a.join(",")
                    } //remember, the user could flip-flop the values and say "bottom center" or "center bottom", etc. "center" is ambiguous because it could be used to describe horizontal or vertical, hence the isNaN(). If there's an "=" sign in the value, it's relative.
                    return null == f ? f = "center" === e ? "50%" : "0" : "center" === f && (f = "50%"), ("center" === e || isNaN(parseFloat(e)) && -1 === (e + "").indexOf("=")) && (e = "50%"), a = e + " " + f + (d.length > 2 ? " " + d[2] : ""), b && (b.oxp = -1 !== e.indexOf("%"), b.oyp = -1 !== f.indexOf("%"), b.oxr = "=" === e.charAt(1), b.oyr = "=" === f.charAt(1), b.ox = parseFloat(e.replace(t, "")), b.oy = parseFloat(f.replace(t, "")), b.v = a), b || a
                },
                /**
                 * @private Takes an ending value (typically a string, but can be a number) and a starting value and returns the change between the two, looking for relative value indicators like += and -= and it also ignores suffixes (but make sure the ending value starts with a number or +=/-= and that the starting value is a NUMBER!)
                 * @param {(number|string)} e End value which is typically a string, but could be a number
                 * @param {(number|string)} b Beginning value which is typically a string but could be a number
                 * @return {number} Amount of change between the beginning and ending values (relative values that have a "+=" or "-=" are recognized)
                 */
                fa = function(a, b) {
                    return "string" == typeof a && "=" === a.charAt(1) ? parseInt(a.charAt(0) + "1", 10) * parseFloat(a.substr(2)) : parseFloat(a) - parseFloat(b) || 0
                },
                /**
                 * @private Takes a value and a default number, checks if the value is relative, null, or numeric and spits back a normalized number accordingly. Primarily used in the _parseTransform() function.
                 * @param {Object} v Value to be parsed
                 * @param {!number} d Default value (which is also used for relative calculations if "+=" or "-=" is found in the first parameter)
                 * @return {number} Parsed value
                 */
                ga = function(a, b) {
                    return null == a ? b : "string" == typeof a && "=" === a.charAt(1) ? parseInt(a.charAt(0) + "1", 10) * parseFloat(a.substr(2)) + b : parseFloat(a) || 0
                },
                /**
                 * @private Translates strings like "40deg" or "40" or 40rad" or "+=40deg" or "270_short" or "-90_cw" or "+=45_ccw" to a numeric radian angle. Of course a starting/default value must be fed in too so that relative values can be calculated properly.
                 * @param {Object} v Value to be parsed
                 * @param {!number} d Default value (which is also used for relative calculations if "+=" or "-=" is found in the first parameter)
                 * @param {string=} p property name for directionalEnd (optional - only used when the parsed value is directional ("_short", "_cw", or "_ccw" suffix). We need a way to store the uncompensated value so that at the end of the tween, we set it to exactly what was requested with no directional compensation). Property name would be "rotation", "rotationX", or "rotationY"
                 * @param {Object=} directionalEnd An object that will store the raw end values for directional angles ("_short", "_cw", or "_ccw" suffix). We need a way to store the uncompensated value so that at the end of the tween, we set it to exactly what was requested with no directional compensation.
                 * @return {number} parsed angle in radians
                 */
                ha = function(a, b, c, d) {
                    var e, f, g, h, i, j = 1e-6;
                    return null == a ? h = b : "number" == typeof a ? h = a : (e = 360, f = a.split("_"), i = "=" === a.charAt(1), g = (i ? parseInt(a.charAt(0) + "1", 10) * parseFloat(f[0].substr(2)) : parseFloat(f[0])) * (-1 === a.indexOf("rad") ? 1 : J) - (i ? 0 : b), f.length && (d && (d[c] = b + g), -1 !== a.indexOf("short") && (g %= e, g !== g % (e / 2) && (g = 0 > g ? g + e : g - e)), -1 !== a.indexOf("_cw") && 0 > g ? g = (g + 9999999999 * e) % e - (g / e | 0) * e : -1 !== a.indexOf("ccw") && g > 0 && (g = (g - 9999999999 * e) % e - (g / e | 0) * e)), h = b + g), j > h && h > -j && (h = 0), h
                },
                ia = {
                    aqua: [0, 255, 255],
                    lime: [0, 255, 0],
                    silver: [192, 192, 192],
                    black: [0, 0, 0],
                    maroon: [128, 0, 0],
                    teal: [0, 128, 128],
                    blue: [0, 0, 255],
                    navy: [0, 0, 128],
                    white: [255, 255, 255],
                    fuchsia: [255, 0, 255],
                    olive: [128, 128, 0],
                    yellow: [255, 255, 0],
                    orange: [255, 165, 0],
                    gray: [128, 128, 128],
                    purple: [128, 0, 128],
                    green: [0, 128, 0],
                    red: [255, 0, 0],
                    pink: [255, 192, 203],
                    cyan: [0, 255, 255],
                    transparent: [255, 255, 255, 0]
                },
                ja = function(a, b, c) {
                    return a = 0 > a ? a + 1 : a > 1 ? a - 1 : a, 255 * (1 > 6 * a ? b + (c - b) * a * 6 : .5 > a ? c : 2 > 3 * a ? b + (c - b) * (2 / 3 - a) * 6 : b) + .5 | 0
                },
                /**
                 * @private Parses a color (like #9F0, #FF9900, rgb(255,51,153) or hsl(108, 50%, 10%)) into an array with 3 elements for red, green, and blue or if toHSL parameter is true, it will populate the array with hue, saturation, and lightness values. If a relative value is found in an hsl() or hsla() string, it will preserve those relative prefixes and all the values in the array will be strings instead of numbers (in all other cases it will be populated with numbers).
                 * @param {(string|number)} v The value the should be parsed which could be a string like #9F0 or rgb(255,102,51) or rgba(255,0,0,0.5) or it could be a number like 0xFF00CC or even a named color like red, blue, purple, etc.
                 * @param {(boolean)} toHSL If true, an hsl() or hsla() value will be returned instead of rgb() or rgba()
                 * @return {Array.<number>} An array containing red, green, and blue (and optionally alpha) in that order, or if the toHSL parameter was true, the array will contain hue, saturation and lightness (and optionally alpha) in that order. Always numbers unless there's a relative prefix found in an hsl() or hsla() string and toHSL is true.
                 */
                ka = g.parseColor = function(a, b) {
                    var c, d, e, f, g, h, i, j, k, l, m;
                    if (a)
                        if ("number" == typeof a) c = [a >> 16, a >> 8 & 255, 255 & a];
                        else {
                            if ("," === a.charAt(a.length - 1) && ( //sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)" - in this example "blue," has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.
                                    a = a.substr(0, a.length - 1)), ia[a]) c = ia[a];
                            else if ("#" === a.charAt(0)) 4 === a.length && (d = a.charAt(1), e = a.charAt(2), f = a.charAt(3), a = "#" + d + d + e + e + f + f), a = parseInt(a.substr(1), 16), c = [a >> 16, a >> 8 & 255, 255 & a];
                            else if ("hsl" === a.substr(0, 3))
                                if (c = m = a.match(q), b) {
                                    if (-1 !== a.indexOf("=")) //if relative values are found, just return the raw strings with the relative prefixes in place.
                                        return a.match(r)
                                } else g = Number(c[0]) % 360 / 360, h = Number(c[1]) / 100, i = Number(c[2]) / 100, e = .5 >= i ? i * (h + 1) : i + h - i * h, d = 2 * i - e, c.length > 3 && (c[3] = Number(a[3])), c[0] = ja(g + 1 / 3, d, e), c[1] = ja(g, d, e), c[2] = ja(g - 1 / 3, d, e);
                            else c = a.match(q) || ia.transparent;
                            c[0] = Number(c[0]), c[1] = Number(c[1]), c[2] = Number(c[2]), c.length > 3 && (c[3] = Number(c[3]))
                        } else c = ia.black;
                    return b && !m && (d = c[0] / 255, e = c[1] / 255, f = c[2] / 255, j = Math.max(d, e, f), k = Math.min(d, e, f), i = (j + k) / 2, j === k ? g = h = 0 : (l = j - k, h = i > .5 ? l / (2 - j - k) : l / (j + k), g = j === d ? (e - f) / l + (f > e ? 6 : 0) : j === e ? (f - d) / l + 2 : (d - e) / l + 4, g *= 60), c[0] = g + .5 | 0, c[1] = 100 * h + .5 | 0, c[2] = 100 * i + .5 | 0), c
                },
                la = function(a, b) {
                    var c, d, e, f = a.match(ma) || [],
                        g = 0,
                        h = f.length ? "" : a;
                    for (c = 0; c < f.length; c++) d = f[c], e = a.substr(g, a.indexOf(d, g) - g), g += e.length + d.length, d = ka(d, b), 3 === d.length && d.push(1), h += e + (b ? "hsla(" + d[0] + "," + d[1] + "%," + d[2] + "%," + d[3] : "rgba(" + d.join(",")) + ")";
                    return h + a.substr(g)
                },
                ma = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b"; //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.
            for (j in ia) ma += "|" + j + "\\b";
            ma = new RegExp(ma + ")", "gi"), g.colorStringFilter = function(a) {
                var b, c = a[0] + a[1];
                ma.test(c) && (b = -1 !== c.indexOf("hsl(") || -1 !== c.indexOf("hsla("), a[0] = la(a[0], b), a[1] = la(a[1], b)), ma.lastIndex = 0
            }, b.defaultStringFilter || (b.defaultStringFilter = g.colorStringFilter);
            /**
             * @private Returns a formatter function that handles taking a string (or number in some cases) and returning a consistently formatted one in terms of delimiters, quantity of values, etc. For example, we may get boxShadow values defined as "0px red" or "0px 0px 10px rgb(255,0,0)" or "0px 0px 20px 20px #F00" and we need to ensure that what we get back is described with 4 numbers and a color. This allows us to feed it into the _parseComplex() method and split the values up appropriately. The neat thing about this _getFormatter() function is that the dflt defines a pattern as well as a default, so for example, _getFormatter("0px 0px 0px 0px #777", true) not only sets the default as 0px for all distances and #777 for the color, but also sets the pattern such that 4 numbers and a color will always get returned.
             * @param {!string} dflt The default value and pattern to follow. So "0px 0px 0px 0px #777" will ensure that 4 numbers and a color will always get returned.
             * @param {boolean=} clr If true, the values should be searched for color-related data. For example, boxShadow values typically contain a color whereas borderRadius don't.
             * @param {boolean=} collapsible If true, the value is a top/left/right/bottom style one that acts like margin or padding, where if only one value is received, it's used for all 4; if 2 are received, the first is duplicated for 3rd (bottom) and the 2nd is duplicated for the 4th spot (left), etc.
             * @return {Function} formatter function
             */
            var na = function(a, b, c, d) {
                    if (null == a) return function(a) {
                        return a
                    };
                    var e, f = b ? (a.match(ma) || [""])[0] : "",
                        g = a.split(f).join("").match(s) || [],
                        h = a.substr(0, a.indexOf(g[0])),
                        i = ")" === a.charAt(a.length - 1) ? ")" : "",
                        j = -1 !== a.indexOf(" ") ? " " : ",",
                        k = g.length,
                        l = k > 0 ? g[0].replace(q, "") : "";
                    return k ? e = b ? function(a) {
                        var b, m, n, o;
                        if ("number" == typeof a) a += l;
                        else if (d && G.test(a)) {
                            for (o = a.replace(G, "|").split("|"), n = 0; n < o.length; n++) o[n] = e(o[n]);
                            return o.join(",")
                        }
                        if (b = (a.match(ma) || [f])[0], m = a.split(b).join("").match(s) || [], n = m.length, k > n--)
                            for (; ++n < k;) m[n] = c ? m[(n - 1) / 2 | 0] : g[n];
                        return h + m.join(j) + j + b + i + (-1 !== a.indexOf("inset") ? " inset" : "")
                    } : function(a) {
                        var b, f, m;
                        if ("number" == typeof a) a += l;
                        else if (d && G.test(a)) {
                            for (f = a.replace(G, "|").split("|"), m = 0; m < f.length; m++) f[m] = e(f[m]);
                            return f.join(",")
                        }
                        if (b = a.match(s) || [], m = b.length, k > m--)
                            for (; ++m < k;) b[m] = c ? b[(m - 1) / 2 | 0] : g[m];
                        return h + b.join(j) + i
                    } : function(a) {
                        return a
                    }
                },
                /**
                 * @private returns a formatter function that's used for edge-related values like marginTop, marginLeft, paddingBottom, paddingRight, etc. Just pass a comma-delimited list of property names related to the edges.
                 * @param {!string} props a comma-delimited list of property names in order from top to left, like "marginTop,marginRight,marginBottom,marginLeft"
                 * @return {Function} a formatter function
                 */
                oa = function(a) {
                    return a = a.split(","),
                        function(b, c, d, e, f, g, h) {
                            var i, j = (c + "").split(" ");
                            for (h = {}, i = 0; 4 > i; i++) h[a[i]] = j[i] = j[i] || j[(i - 1) / 2 >> 0];
                            return e.parse(b, h, f, g)
                        }
                },
                /**
                 * @private @constructor Used by a few SpecialProps to hold important values for proxies. For example, _parseToProxy() creates a MiniPropTween instance for each property that must get tweened on the proxy, and we record the original property name as well as the unique one we create for the proxy, plus whether or not the value needs to be rounded plus the original value.
                 * @param {!Object} t target object whose property we're tweening (often a CSSPropTween)
                 * @param {!string} p property name
                 * @param {(number|string|object)} v value
                 * @param {MiniPropTween=} next next MiniPropTween in the linked list
                 * @param {boolean=} r if true, the tweened value should be rounded to the nearest integer
                 */
                pa = (P._setPluginRatio = function(a) {
                    this.plugin.setRatio(a);
                    for (var b, c, d, e, f, g = this.data, h = g.proxy, i = g.firstMPT, j = 1e-6; i;) b = h[i.v], i.r ? b = Math.round(b) : j > b && b > -j && (b = 0), i.t[i.p] = b, i = i._next;
                    //at the end, we must set the CSSPropTween's "e" (end) value dynamically here because that's what is used in the final setRatio() method. Same for "b" at the beginning.
                    if (g.autoRotate && (g.autoRotate.rotation = h.rotation), 1 === a || 0 === a)
                        for (i = g.firstMPT, f = 1 === a ? "e" : "b"; i;) {
                            if (c = i.t, c.type) {
                                if (1 === c.type) {
                                    for (e = c.xs0 + c.s + c.xs1, d = 1; d < c.l; d++) e += c["xn" + d] + c["xs" + (d + 1)];
                                    c[f] = e
                                }
                            } else c[f] = c.s + c.xs0;
                            i = i._next
                        }
                }, function(a, b, c, d, e) {
                    this.t = a, this.p = b, this.v = c, this.r = e, d && (d._prev = this, this._next = d)
                }),
                /**
                 * @constructor Each property that is tweened has at least one CSSPropTween associated with it. These instances store important information like the target, property, starting value, amount of change, etc. They can also optionally have a number of "extra" strings and numeric values named xs1, xn1, xs2, xn2, xs3, xn3, etc. where "s" indicates string and "n" indicates number. These can be pieced together in a complex-value tween (type:1) that has alternating types of data like a string, number, string, number, etc. For example, boxShadow could be "5px 5px 8px rgb(102, 102, 51)". In that value, there are 6 numbers that may need to tween and then pieced back together into a string again with spaces, suffixes, etc. xs0 is special in that it stores the suffix for standard (type:0) tweens, -OR- the first string (prefix) in a complex-value (type:1) CSSPropTween -OR- it can be the non-tweening value in a type:-1 CSSPropTween. We do this to conserve memory.
                 * CSSPropTweens have the following optional properties as well (not defined through the constructor):
                 *  - l: Length in terms of the number of extra properties that the CSSPropTween has (default: 0). For example, for a boxShadow we may need to tween 5 numbers in which case l would be 5; Keep in mind that the start/end values for the first number that's tweened are always stored in the s and c properties to conserve memory. All additional values thereafter are stored in xn1, xn2, etc.
                 *  - xfirst: The first instance of any sub-CSSPropTweens that are tweening properties of this instance. For example, we may split up a boxShadow tween so that there's a main CSSPropTween of type:1 that has various xs* and xn* values associated with the h-shadow, v-shadow, blur, color, etc. Then we spawn a CSSPropTween for each of those that has a higher priority and runs BEFORE the main CSSPropTween so that the values are all set by the time it needs to re-assemble them. The xfirst gives us an easy way to identify the first one in that chain which typically ends at the main one (because they're all prepende to the linked list)
                 *  - plugin: The TweenPlugin instance that will handle the tweening of any complex values. For example, sometimes we don't want to use normal subtweens (like xfirst refers to) to tween the values - we might want ThrowPropsPlugin or BezierPlugin some other plugin to do the actual tweening, so we create a plugin instance and store a reference here. We need this reference so that if we get a request to round values or disable a tween, we can pass along that request.
                 *  - data: Arbitrary data that needs to be stored with the CSSPropTween. Typically if we're going to have a plugin handle the tweening of a complex-value tween, we create a generic object that stores the END values that we're tweening to and the CSSPropTween's xs1, xs2, etc. have the starting values. We store that object as data. That way, we can simply pass that object to the plugin and use the CSSPropTween as the target.
                 *  - setRatio: Only used for type:2 tweens that require custom functionality. In this case, we call the CSSPropTween's setRatio() method and pass the ratio each time the tween updates. This isn't quite as efficient as doing things directly in the CSSPlugin's setRatio() method, but it's very convenient and flexible.
                 * @param {!Object} t Target object whose property will be tweened. Often a DOM element, but not always. It could be anything.
                 * @param {string} p Property to tween (name). For example, to tween element.width, p would be "width".
                 * @param {number} s Starting numeric value
                 * @param {number} c Change in numeric value over the course of the entire tween. For example, if element.width starts at 5 and should end at 100, c would be 95.
                 * @param {CSSPropTween=} next The next CSSPropTween in the linked list. If one is defined, we will define its _prev as the new instance, and the new instance's _next will be pointed at it.
                 * @param {number=} type The type of CSSPropTween where -1 = a non-tweening value, 0 = a standard simple tween, 1 = a complex value (like one that has multiple numbers in a comma- or space-delimited string like border:"1px solid red"), and 2 = one that uses a custom setRatio function that does all of the work of applying the values on each update.
                 * @param {string=} n Name of the property that should be used for overwriting purposes which is typically the same as p but not always. For example, we may need to create a subtween for the 2nd part of a "clip:rect(...)" tween in which case "p" might be xs1 but "n" is still "clip"
                 * @param {boolean=} r If true, the value(s) should be rounded
                 * @param {number=} pr Priority in the linked list order. Higher priority CSSPropTweens will be updated before lower priority ones. The default priority is 0.
                 * @param {string=} b Beginning value. We store this to ensure that it is EXACTLY what it was when the tween began without any risk of interpretation issues.
                 * @param {string=} e Ending value. We store this to ensure that it is EXACTLY what the user defined at the end of the tween without any risk of interpretation issues.
                 */
                qa = (P._parseToProxy = function(a, b, c, d, e, f) {
                    var g, h, i, j, k, l = d,
                        m = {},
                        n = {},
                        o = c._transform,
                        p = K;
                    for (c._transform = null, K = b, d = k = c.parse(a, b, d, e), K = p,
                        //break off from the linked list so the new ones are isolated.
                        f && (c._transform = o, l && (l._prev = null, l._prev && (l._prev._next = null))); d && d !== l;) {
                        if (d.type <= 1 && (h = d.p, n[h] = d.s + d.c, m[h] = d.s, f || (j = new pa(d, "s", h, j, d.r), d.c = 0), 1 === d.type))
                            for (g = d.l; --g > 0;) i = "xn" + g, h = d.p + "_" + i, n[h] = d.data[i], m[h] = d[i], f || (j = new pa(d, i, h, j, d.rxp[i]));
                        d = d._next
                    }
                    return {
                        proxy: m,
                        end: n,
                        firstMPT: j,
                        pt: k
                    }
                }, P.CSSPropTween = function(a, b, d, e, g, h, i, j, k, l, m) {
                    this.t = a, //target
                        this.p = b, //property
                        this.s = d, //starting value
                        this.c = e, //change value
                        this.n = i || b, //name that this CSSPropTween should be associated to (usually the same as p, but not always - n is what overwriting looks at)
                        a instanceof qa || f.push(this.n), this.r = j, //round (boolean)
                        this.type = h || 0, //0 = normal tween, -1 = non-tweening (in which case xs0 will be applied to the target's property, like tp.t[tp.p] = tp.xs0), 1 = complex-value SpecialProp, 2 = custom setRatio() that does all the work
                        k && (this.pr = k, c = !0), this.b = void 0 === l ? d : l, this.e = void 0 === m ? d + e : m, g && (this._next = g, g._prev = this)
                }),
                ra = function(a, b, c, d, e, f) { //cleans up some code redundancies and helps minification. Just a fast way to add a NUMERIC non-tweening CSSPropTween
                    var g = new qa(a, b, c, d - c, e, -1, f);
                    return g.b = c, g.e = g.xs0 = d, g
                },
                /**
                 * Takes a target, the beginning value and ending value (as strings) and parses them into a CSSPropTween (possibly with child CSSPropTweens) that accommodates multiple numbers, colors, comma-delimited values, etc. For example:
                 * sp.parseComplex(element, "boxShadow", "5px 10px 20px rgb(255,102,51)", "0px 0px 0px red", true, "0px 0px 0px rgb(0,0,0,0)", pt);
                 * It will walk through the beginning and ending values (which should be in the same format with the same number and type of values) and figure out which parts are numbers, what strings separate the numeric/tweenable values, and then create the CSSPropTweens accordingly. If a plugin is defined, no child CSSPropTweens will be created. Instead, the ending values will be stored in the "data" property of the returned CSSPropTween like: {s:-5, xn1:-10, xn2:-20, xn3:255, xn4:0, xn5:0} so that it can be fed to any other plugin and it'll be plain numeric tweens but the recomposition of the complex value will be handled inside CSSPlugin's setRatio().
                 * If a setRatio is defined, the type of the CSSPropTween will be set to 2 and recomposition of the values will be the responsibility of that method.
                 *
                 * @param {!Object} t Target whose property will be tweened
                 * @param {!string} p Property that will be tweened (its name, like "left" or "backgroundColor" or "boxShadow")
                 * @param {string} b Beginning value
                 * @param {string} e Ending value
                 * @param {boolean} clrs If true, the value could contain a color value like "rgb(255,0,0)" or "#F00" or "red". The default is false, so no colors will be recognized (a performance optimization)
                 * @param {(string|number|Object)} dflt The default beginning value that should be used if no valid beginning value is defined or if the number of values inside the complex beginning and ending values don't match
                 * @param {?CSSPropTween} pt CSSPropTween instance that is the current head of the linked list (we'll prepend to this).
                 * @param {number=} pr Priority in the linked list order. Higher priority properties will be updated before lower priority ones. The default priority is 0.
                 * @param {TweenPlugin=} plugin If a plugin should handle the tweening of extra properties, pass the plugin instance here. If one is defined, then NO subtweens will be created for any extra properties (the properties will be created - just not additional CSSPropTween instances to tween them) because the plugin is expected to do so. However, the end values WILL be populated in the "data" property, like {s:100, xn1:50, xn2:300}
                 * @param {function(number)=} setRatio If values should be set in a custom function instead of being pieced together in a type:1 (complex-value) CSSPropTween, define that custom function here.
                 * @return {CSSPropTween} The first CSSPropTween in the linked list which includes the new one(s) added by the parseComplex() call.
                 */
                sa = g.parseComplex = function(a, b, c, d, e, f, h, i, j, l) {
                    c = c || f || "", h = new qa(a, b, 0, 0, h, l ? 2 : 1, null, !1, i, c, d), d += "", e && ma.test(d + c) && (d = [c, d], g.colorStringFilter(d), c = d[0], d = d[1]);
                    var m, n, o, p, s, t, u, v, w, x, y, z, A, B = c.split(", ").join(",").split(" "), //beginning array
                        C = d.split(", ").join(",").split(" "), //ending array
                        D = B.length,
                        E = k !== !1;
                    for (-1 === d.indexOf(",") && -1 === c.indexOf(",") || (B = B.join(" ").replace(G, ", ").split(" "), C = C.join(" ").replace(G, ", ").split(" "), D = B.length), D !== C.length && (B = (f || "").split(" "), D = B.length), h.plugin = j, h.setRatio = l, ma.lastIndex = 0, m = 0; D > m; m++)
                    //if the value begins with a number (most common). It's fine if it has a suffix like px
                        if (p = B[m], s = C[m], v = parseFloat(p), v || 0 === v) h.appendXtra("", v, fa(s, v), s.replace(r, ""), E && -1 !== s.indexOf("px"), !0);
                        else if (e && ma.test(p)) z = s.indexOf(")") + 1, z = ")" + (z ? s.substr(z) : ""), A = -1 !== s.indexOf("hsl") && R, p = ka(p, A), s = ka(s, A), w = p.length + s.length > 6, w && !R && 0 === s[3] ? (h["xs" + h.l] += h.l ? " transparent" : "transparent", h.e = h.e.split(C[m]).join("transparent")) : (R || (w = !1), A ? h.appendXtra(w ? "hsla(" : "hsl(", p[0], fa(s[0], p[0]), ",", !1, !0).appendXtra("", p[1], fa(s[1], p[1]), "%,", !1).appendXtra("", p[2], fa(s[2], p[2]), w ? "%," : "%" + z, !1) : h.appendXtra(w ? "rgba(" : "rgb(", p[0], s[0] - p[0], ",", !0, !0).appendXtra("", p[1], s[1] - p[1], ",", !0).appendXtra("", p[2], s[2] - p[2], w ? "," : z, !0), w && (p = p.length < 4 ? 1 : p[3], h.appendXtra("", p, (s.length < 4 ? 1 : s[3]) - p, z, !1))), ma.lastIndex = 0;
                    else //gets each group of numbers in the beginning value string and drops them into an array
                    //if no number is found, treat it as a non-tweening value and just append the string to the current xs.
                    if (t = p.match(q)) { //get each group of numbers in the end value string and drop them into an array. We allow relative values too, like +=50 or -=.5
                        if (u = s.match(r), !u || u.length !== t.length)
                        //DEBUG: _log("mismatched formatting detected on " + p + " (" + b + " vs " + e + ")");
                            return h;
                        for (o = 0, n = 0; n < t.length; n++) y = t[n], x = p.indexOf(y, o), h.appendXtra(p.substr(o, x - o), Number(y), fa(u[n], y), "", E && "px" === p.substr(x + y.length, 2), 0 === n), o = x + y.length;
                        h["xs" + h.l] += p.substr(o)
                    } else h["xs" + h.l] += h.l || h["xs" + h.l] ? " " + s : s;
                    //if there are relative values ("+=" or "-=" prefix), we need to adjust the ending value to eliminate the prefixes and combine the values properly.
                    if (-1 !== d.indexOf("=") && h.data) {
                        for (z = h.xs0 + h.data.s, m = 1; m < h.l; m++) z += h["xs" + m] + h.data["xn" + m];
                        h.e = z + h["xs" + m]
                    }
                    return h.l || (h.type = -1, h.xs0 = h.e), h.xfirst || h
                },
                ta = 9; //length (number of extra properties like xn1, xn2, xn3, etc.
            for (j = qa.prototype, j.l = j.pr = 0; --ta > 0;) j["xn" + ta] = 0, j["xs" + ta] = "";
            j.xs0 = "", j._next = j._prev = j.xfirst = j.data = j.plugin = j.setRatio = j.rxp = null,
                /**
                 * Appends and extra tweening value to a CSSPropTween and automatically manages any prefix and suffix strings. The first extra value is stored in the s and c of the main CSSPropTween instance, but thereafter any extras are stored in the xn1, xn2, xn3, etc. The prefixes and suffixes are stored in the xs0, xs1, xs2, etc. properties. For example, if I walk through a clip value like "rect(10px, 5px, 0px, 20px)", the values would be stored like this:
                 * xs0:"rect(", s:10, xs1:"px, ", xn1:5, xs2:"px, ", xn2:0, xs3:"px, ", xn3:20, xn4:"px)"
                 * And they'd all get joined together when the CSSPlugin renders (in the setRatio() method).
                 * @param {string=} pfx Prefix (if any)
                 * @param {!number} s Starting value
                 * @param {!number} c Change in numeric value over the course of the entire tween. For example, if the start is 5 and the end is 100, the change would be 95.
                 * @param {string=} sfx Suffix (if any)
                 * @param {boolean=} r Round (if true).
                 * @param {boolean=} pad If true, this extra value should be separated by the previous one by a space. If there is no previous extra and pad is true, it will automatically drop the space.
                 * @return {CSSPropTween} returns itself so that multiple methods can be chained together.
                 */
                j.appendXtra = function(a, b, c, d, e, f) {
                    var g = this,
                        h = g.l; //round extra property (we need to tap into this in the _parseToProxy() method)
                    //typically we'll combine non-changing values right into the xs to optimize performance, but we don't combine them when there's a plugin that will be tweening the values because it may depend on the values being split apart, like for a bezier, if a value doesn't change between the first and second iteration but then it does on the 3rd, we'll run into trouble because there's no xn slot for that value!
                    return g["xs" + h] += f && (h || g["xs" + h]) ? " " + a : a || "", c || 0 === h || g.plugin ? (g.l++, g.type = g.setRatio ? 2 : 1, g["xs" + g.l] = d || "", h > 0 ? (g.data["xn" + h] = b + c, g.rxp["xn" + h] = e, g["xn" + h] = b, g.plugin || (g.xfirst = new qa(g, "xn" + h, b, c, g.xfirst || g, 0, g.n, e, g.pr), g.xfirst.xs0 = 0), g) : (g.data = {
                        s: b + c
                    }, g.rxp = {}, g.s = b, g.c = c, g.r = e, g)) : (g["xs" + h] += b + (d || ""), g)
                };
            /**
             * @constructor A SpecialProp is basically a css property that needs to be treated in a non-standard way, like if it may contain a complex value like boxShadow:"5px 10px 15px rgb(255, 102, 51)" or if it is associated with another plugin like ThrowPropsPlugin or BezierPlugin. Every SpecialProp is associated with a particular property name like "boxShadow" or "throwProps" or "bezier" and it will intercept those values in the vars object that's passed to the CSSPlugin and handle them accordingly.
             * @param {!string} p Property name (like "boxShadow" or "throwProps")
             * @param {Object=} options An object containing any of the following configuration options:
             *                      - defaultValue: the default value
             *                      - parser: A function that should be called when the associated property name is found in the vars. This function should return a CSSPropTween instance and it should ensure that it is properly inserted into the linked list. It will receive 4 paramters: 1) The target, 2) The value defined in the vars, 3) The CSSPlugin instance (whose _firstPT should be used for the linked list), and 4) A computed style object if one was calculated (this is a speed optimization that allows retrieval of starting values quicker)
             *                      - formatter: a function that formats any value received for this special property (for example, boxShadow could take "5px 5px red" and format it to "5px 5px 0px 0px red" so that both the beginning and ending values have a common order and quantity of values.)
             *                      - prefix: if true, we'll determine whether or not this property requires a vendor prefix (like Webkit or Moz or ms or O)
             *                      - color: set this to true if the value for this SpecialProp may contain color-related values like rgb(), rgba(), etc.
             *                      - priority: priority in the linked list order. Higher priority SpecialProps will be updated before lower priority ones. The default priority is 0.
             *                      - multi: if true, the formatter should accommodate a comma-delimited list of values, like boxShadow could have multiple boxShadows listed out.
             *                      - collapsible: if true, the formatter should treat the value like it's a top/right/bottom/left value that could be collapsed, like "5px" would apply to all, "5px, 10px" would use 5px for top/bottom and 10px for right/left, etc.
             *                      - keyword: a special keyword that can [optionally] be found inside the value (like "inset" for boxShadow). This allows us to validate beginning/ending values to make sure they match (if the keyword is found in one, it'll be added to the other for consistency by default).
             */
            var ua = function(a, b) {
                    b = b || {}, this.p = b.prefix ? W(a) || a : a, i[a] = i[this.p] = this, this.format = b.formatter || na(b.defaultValue, b.color, b.collapsible, b.multi), b.parser && (this.parse = b.parser), this.clrs = b.color, this.multi = b.multi, this.keyword = b.keyword, this.dflt = b.defaultValue, this.pr = b.priority || 0
                },
                //shortcut for creating a new SpecialProp that can accept multiple properties as a comma-delimited list (helps minification). dflt can be an array for multiple values (we don't do a comma-delimited list because the default value may contain commas, like rect(0px,0px,0px,0px)). We attach this method to the SpecialProp class/object instead of using a private _createSpecialProp() method so that we can tap into it externally if necessary, like from another plugin.
                va = P._registerComplexSpecialProp = function(a, b, c) {
                    "object" != typeof b && (b = {
                        parser: c
                    });
                    var d, e, f = a.split(","),
                        g = b.defaultValue;
                    for (c = c || [g], d = 0; d < f.length; d++) b.prefix = 0 === d && b.prefix, b.defaultValue = c[d] || g, e = new ua(f[d], b)
                },
                //creates a placeholder special prop for a plugin so that the property gets caught the first time a tween of it is attempted, and at that time it makes the plugin register itself, thus taking over for all future tweens of that property. This allows us to not mandate that things load in a particular order and it also allows us to log() an error that informs the user when they attempt to tween an external plugin-related property without loading its .js file.
                wa = function(a) {
                    if (!i[a]) {
                        var b = a.charAt(0).toUpperCase() + a.substr(1) + "Plugin";
                        va(a, {
                            parser: function(a, c, d, e, f, g, j) {
                                var k = h.com.greensock.plugins[b];
                                return k ? (k._cssRegister(), i[d].parse(a, c, d, e, f, g, j)) : (T("Error: " + b + " js file not loaded."), f)
                            }
                        })
                    }
                };
            j = ua.prototype, j.parseComplex = function(a, b, c, d, e, f) {
                var g, h, i, j, k, l, m = this.keyword;
                if (this.multi && (G.test(c) || G.test(b) ? (h = b.replace(G, "|").split("|"), i = c.replace(G, "|").split("|")) : m && (h = [b], i = [c])), i) {
                    for (j = i.length > h.length ? i.length : h.length, g = 0; j > g; g++) b = h[g] = h[g] || this.dflt, c = i[g] = i[g] || this.dflt, m && (k = b.indexOf(m), l = c.indexOf(m), k !== l && (-1 === l ? h[g] = h[g].split(m).join("") : -1 === k && (h[g] += " " + m)));
                    b = h.join(", "), c = i.join(", ")
                }
                return sa(a, this.p, b, c, this.clrs, this.dflt, d, this.pr, e, f)
            }, j.parse = function(a, b, c, d, f, g, h) {
                return this.parseComplex(a.style, this.format(Y(a, this.p, e, !1, this.dflt)), this.format(b), f, g)
            }, g.registerSpecialProp = function(a, b, c) {
                va(a, {
                    parser: function(a, d, e, f, g, h, i) {
                        var j = new qa(a, e, 0, 0, g, 2, e, !1, c);
                        return j.plugin = h, j.setRatio = b(a, d, f._tween, e), j
                    },
                    priority: c
                })
            }, g.useSVGTransformAttr = m || n; //Safari and Firefox both have some rendering bugs when applying CSS transforms to SVG elements, so default to using the "transform" attribute instead (users can override this).
            var xa, ya = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","),
                za = W("transform"), //the Javascript (camelCase) transform property, like msTransform, WebkitTransform, MozTransform, or OTransform.
                Aa = U + "transform",
                Ba = W("transformOrigin"),
                Ca = null !== W("perspective"),
                Da = P.Transform = function() {
                    this.perspective = parseFloat(g.defaultTransformPerspective) || 0, this.force3D = g.defaultForce3D !== !1 && Ca ? g.defaultForce3D || "auto" : !1
                },
                Ea = window.SVGElement,
                //Some browsers (like Firefox and IE) don't honor transform-origin properly in SVG elements, so we need to manually adjust the matrix accordingly. We feature detect here rather than always doing the conversion for certain browsers because they may fix the problem at some point in the future.
                Fa = function(a, b, c) {
                    var d, e = L.createElementNS("http://www.w3.org/2000/svg", a),
                        f = /([a-z])([A-Z])/g;
                    for (d in c) e.setAttributeNS(null, d.replace(f, "$1-$2").toLowerCase(), c[d]);
                    return b.appendChild(e), e
                },
                Ga = L.documentElement,
                Ha = function() {
                    //IE and Android stock don't support CSS transforms on SVG elements, so we must write them to the "transform" attribute. We populate this variable in the _parseTransform() method, and only if/when we come across an SVG element
                    var a, b, c, d = p || /Android/i.test(Q) && !window.chrome; //IE8 and earlier doesn't support SVG anyway
                    //note: Firefox fails the test even though it does support CSS transforms in 3D. Since we can't push 3D stuff into the transform attribute, we force Firefox to pass the test here (as long as it does truly support 3D).
                    return L.createElementNS && !d && (a = Fa("svg", Ga), b = Fa("rect", a, {
                        width: 100,
                        height: 50,
                        x: 100
                    }), c = b.getBoundingClientRect().width, b.style[Ba] = "50% 50%", b.style[za] = "scaleX(0.5)", d = c === b.getBoundingClientRect().width && !(n && Ca), Ga.removeChild(a)), d
                }(),
                Ia = function(a, b, c, d, e, f) {
                    var h, i, j, k, l, m, n, o, p, q, r, s, t, u, v = a._gsTransform,
                        w = Ma(a, !0);
                    v && (t = v.xOrigin, u = v.yOrigin), (!d || (h = d.split(" ")).length < 2) && (n = a.getBBox(), b = ea(b).split(" "), h = [(-1 !== b[0].indexOf("%") ? parseFloat(b[0]) / 100 * n.width : parseFloat(b[0])) + n.x, (-1 !== b[1].indexOf("%") ? parseFloat(b[1]) / 100 * n.height : parseFloat(b[1])) + n.y]), c.xOrigin = k = parseFloat(h[0]), c.yOrigin = l = parseFloat(h[1]), d && w !== La && (m = w[0], n = w[1], o = w[2], p = w[3], q = w[4], r = w[5], s = m * p - n * o, i = k * (p / s) + l * (-o / s) + (o * r - p * q) / s, j = k * (-n / s) + l * (m / s) - (m * r - n * q) / s, k = c.xOrigin = h[0] = i, l = c.yOrigin = h[1] = j), v && ( //avoid jump when transformOrigin is changed - adjust the x/y values accordingly
                        f && (c.xOffset = v.xOffset, c.yOffset = v.yOffset, v = c), e || e !== !1 && g.defaultSmoothOrigin !== !1 ? (i = k - t, j = l - u, v.xOffset += i * w[0] + j * w[2] - i, v.yOffset += i * w[1] + j * w[3] - j) : v.xOffset = v.yOffset = 0), f || a.setAttribute("data-svg-origin", h.join(" "))
                },
                Ja = function(a) {
                    try {
                        return a.getBBox()
                    } catch (a) {}
                },
                Ka = function(a) { //reports if the element is an SVG on which getBBox() actually works
                    return !!(Ea && a.getBBox && a.getCTM && Ja(a) && (!a.parentNode || a.parentNode.getBBox && a.parentNode.getCTM))
                },
                La = [1, 0, 0, 1, 0, 0],
                Ma = function(a, b) {
                    var c, d, e, f, g, h = a._gsTransform || new Da,
                        i = 1e5;
                    if (za ? d = Y(a, Aa, null, !0) : a.currentStyle && (d = a.currentStyle.filter.match(E), d = d && 4 === d.length ? [d[0].substr(4), Number(d[2].substr(4)), Number(d[1].substr(4)), d[3].substr(4), h.x || 0, h.y || 0].join(",") : ""), c = !d || "none" === d || "matrix(1, 0, 0, 1, 0, 0)" === d, (h.svg || a.getBBox && Ka(a)) && (c && -1 !== (a.style[za] + "").indexOf("matrix") && (d = a.style[za], c = 0), e = a.getAttribute("transform"), c && e && (-1 !== e.indexOf("matrix") ? (d = e, c = 0) : -1 !== e.indexOf("translate") && (d = "matrix(1,0,0,1," + e.match(/(?:\-|\b)[\d\-\.e]+\b/gi).join(",") + ")", c = 0))), c) return La;
                    for (
                        //split the matrix values out into an array (m for matrix)
                        e = (d || "").match(q) || [], ta = e.length; --ta > -1;) f = Number(e[ta]), e[ta] = (g = f - (f |= 0)) ? (g * i + (0 > g ? -.5 : .5) | 0) / i + f : f;
                    return b && e.length > 6 ? [e[0], e[1], e[4], e[5], e[12], e[13]] : e
                },
                /**
                 * Parses the transform values for an element, returning an object with x, y, z, scaleX, scaleY, scaleZ, rotation, rotationX, rotationY, skewX, and skewY properties. Note: by default (for performance reasons), all skewing is combined into skewX and rotation but skewY still has a place in the transform object so that we can record how much of the skew is attributed to skewX vs skewY. Remember, a skewY of 10 looks the same as a rotation of 10 and skewX of -10.
                 * @param {!Object} t target element
                 * @param {Object=} cs computed style object (optional)
                 * @param {boolean=} rec if true, the transform values will be recorded to the target element's _gsTransform object, like target._gsTransform = {x:0, y:0, z:0, scaleX:1...}
                 * @param {boolean=} parse if true, we'll ignore any _gsTransform values that already exist on the element, and force a reparsing of the css (calculated style)
                 * @return {object} object containing all of the transform properties/values like {x:0, y:0, z:0, scaleX:1...}
                 */
                Na = P.getTransform = function(a, c, d, f) {
                    if (a._gsTransform && d && !f) return a._gsTransform;
                    var h, i, j, k, l, m, n = d ? a._gsTransform || new Da : new Da,
                        o = n.scaleX < 0, //in order to interpret things properly, we need to know if the user applied a negative scaleX previously so that we can adjust the rotation and skewX accordingly. Otherwise, if we always interpret a flipped matrix as affecting scaleY and the user only wants to tween the scaleX on multiple sequential tweens, it would keep the negative scaleY without that being the user's intent.
                        p = 2e-5,
                        q = 1e5,
                        r = Ca ? parseFloat(Y(a, Ba, c, !1, "0 0 0").split(" ")[2]) || n.zOrigin || 0 : 0,
                        s = parseFloat(g.defaultTransformPerspective) || 0;
                    if (n.svg = !(!a.getBBox || !Ka(a)), n.svg && (Ia(a, Y(a, Ba, e, !1, "50% 50%") + "", n, a.getAttribute("data-svg-origin")), xa = g.useSVGTransformAttr || Ha), h = Ma(a), h !== La) {
                        if (16 === h.length) {
                            //we'll only look at these position-related 6 variables first because if x/y/z all match, it's relatively safe to assume we don't need to re-parse everything which risks losing important rotational information (like rotationX:180 plus rotationY:180 would look the same as rotation:180 - there's no way to know for sure which direction was taken based solely on the matrix3d() values)
                            var t, u, v, w, x, y = h[0],
                                z = h[1],
                                A = h[2],
                                B = h[3],
                                C = h[4],
                                D = h[5],
                                E = h[6],
                                F = h[7],
                                G = h[8],
                                H = h[9],
                                I = h[10],
                                K = h[12],
                                L = h[13],
                                M = h[14],
                                N = h[11],
                                O = Math.atan2(E, I);
                            //we manually compensate for non-zero z component of transformOrigin to work around bugs in Safari
                            n.zOrigin && (M = -n.zOrigin, K = G * M - h[12], L = H * M - h[13], M = I * M + n.zOrigin - h[14]), n.rotationX = O * J,
                                //rotationX
                                O && (w = Math.cos(-O), x = Math.sin(-O), t = C * w + G * x, u = D * w + H * x, v = E * w + I * x, G = C * -x + G * w, H = D * -x + H * w, I = E * -x + I * w, N = F * -x + N * w, C = t, D = u, E = v),
                                //rotationY
                                O = Math.atan2(-A, I), n.rotationY = O * J, O && (w = Math.cos(-O), x = Math.sin(-O), t = y * w - G * x, u = z * w - H * x, v = A * w - I * x, H = z * x + H * w, I = A * x + I * w, N = B * x + N * w, y = t, z = u, A = v),
                                //rotationZ
                                O = Math.atan2(z, y), n.rotation = O * J, O && (w = Math.cos(-O), x = Math.sin(-O), y = y * w + C * x, u = z * w + D * x, D = z * -x + D * w, E = A * -x + E * w, z = u), n.rotationX && Math.abs(n.rotationX) + Math.abs(n.rotation) > 359.9 && ( //when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.
                                    n.rotationX = n.rotation = 0, n.rotationY = 180 - n.rotationY), n.scaleX = (Math.sqrt(y * y + z * z) * q + .5 | 0) / q, n.scaleY = (Math.sqrt(D * D + H * H) * q + .5 | 0) / q, n.scaleZ = (Math.sqrt(E * E + I * I) * q + .5 | 0) / q, n.skewX = C || D ? Math.atan2(C, D) * J + n.rotation : n.skewX || 0, Math.abs(n.skewX) > 90 && Math.abs(n.skewX) < 270 && (o ? (n.scaleX *= -1, n.skewX += n.rotation <= 0 ? 180 : -180, n.rotation += n.rotation <= 0 ? 180 : -180) : (n.scaleY *= -1, n.skewX += n.skewX <= 0 ? 180 : -180)), n.perspective = N ? 1 / (0 > N ? -N : N) : 0, n.x = K, n.y = L, n.z = M, n.svg && (n.x -= n.xOrigin - (n.xOrigin * y - n.yOrigin * C), n.y -= n.yOrigin - (n.yOrigin * z - n.xOrigin * D))
                        } else if ((!Ca || f || !h.length || n.x !== h[4] || n.y !== h[5] || !n.rotationX && !n.rotationY) && (void 0 === n.x || "none" !== Y(a, "display", c))) { //sometimes a 6-element matrix is returned even when we performed 3D transforms, like if rotationX and rotationY are 180. In cases like this, we still need to honor the 3D transforms. If we just rely on the 2D info, it could affect how the data is interpreted, like scaleY might get set to -1 or rotation could get offset by 180 degrees. For example, do a TweenLite.to(element, 1, {css:{rotationX:180, rotationY:180}}) and then later, TweenLite.to(element, 1, {css:{rotationX:0}}) and without this conditional logic in place, it'd jump to a state of being unrotated when the 2nd tween starts. Then again, we need to honor the fact that the user COULD alter the transforms outside of CSSPlugin, like by manually applying new css, so we try to sense that by looking at x and y because if those changed, we know the changes were made outside CSSPlugin and we force a reinterpretation of the matrix values. Also, in Webkit browsers, if the element's "display" is "none", its calculated style value will always return empty, so if we've already recorded the values in the _gsTransform object, we'll just rely on those.
                            var P = h.length >= 6,
                                Q = P ? h[0] : 1,
                                R = h[1] || 0,
                                S = h[2] || 0,
                                T = P ? h[3] : 1;
                            n.x = h[4] || 0, n.y = h[5] || 0, j = Math.sqrt(Q * Q + R * R), k = Math.sqrt(T * T + S * S), l = Q || R ? Math.atan2(R, Q) * J : n.rotation || 0, //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).
                                m = S || T ? Math.atan2(S, T) * J + l : n.skewX || 0, Math.abs(m) > 90 && Math.abs(m) < 270 && (o ? (j *= -1, m += 0 >= l ? 180 : -180, l += 0 >= l ? 180 : -180) : (k *= -1, m += 0 >= m ? 180 : -180)), n.scaleX = j, n.scaleY = k, n.rotation = l, n.skewX = m, Ca && (n.rotationX = n.rotationY = n.z = 0, n.perspective = s, n.scaleZ = 1), n.svg && (n.x -= n.xOrigin - (n.xOrigin * Q + n.yOrigin * S), n.y -= n.yOrigin - (n.xOrigin * R + n.yOrigin * T))
                        }
                        n.zOrigin = r;
                        //some browsers have a hard time with very small values like 2.4492935982947064e-16 (notice the "e-" towards the end) and would render the object slightly off. So we round to 0 in these cases. The conditional logic here is faster than calling Math.abs(). Also, browsers tend to render a SLIGHTLY rotated object in a fuzzy way, so we need to snap to exactly 0 when appropriate.
                        for (i in n) n[i] < p && n[i] > -p && (n[i] = 0)
                    }
                    //DEBUG: _log("parsed rotation of " + t.getAttribute("id")+": "+(tm.rotationX)+", "+(tm.rotationY)+", "+(tm.rotation)+", scale: "+tm.scaleX+", "+tm.scaleY+", "+tm.scaleZ+", position: "+tm.x+", "+tm.y+", "+tm.z+", perspective: "+tm.perspective+ ", origin: "+ tm.xOrigin+ ","+ tm.yOrigin);
                    //record to the object's _gsTransform which we use so that tweens can control individual properties independently (we need all the properties to accurately recompose the matrix in the setRatio() method)
                    //if we're supposed to apply transforms to the SVG element's "transform" attribute, make sure there aren't any CSS transforms applied or they'll override the attribute ones. Also clear the transform attribute if we're using CSS, just to be clean.
                    return d && (a._gsTransform = n, n.svg && (xa && a.style[za] ? b.delayedCall(.001, function() { //if we apply this right away (before anything has rendered), we risk there being no transforms for a brief moment and it also interferes with adjusting the transformOrigin in a tween with immediateRender:true (it'd try reading the matrix and it wouldn't have the appropriate data in place because we just removed it).
                        Ra(a.style, za)
                    }) : !xa && a.getAttribute("transform") && b.delayedCall(.001, function() {
                        a.removeAttribute("transform")
                    }))), n
                },
                //for setting 2D transforms in IE6, IE7, and IE8 (must use a "filter" to emulate the behavior of modern day browser transforms)
                Oa = function(a) {
                    var b, c, d = this.data, //refers to the element's _gsTransform object
                        e = -d.rotation * I,
                        f = e + d.skewX * I,
                        g = 1e5,
                        h = (Math.cos(e) * d.scaleX * g | 0) / g,
                        i = (Math.sin(e) * d.scaleX * g | 0) / g,
                        j = (Math.sin(f) * -d.scaleY * g | 0) / g,
                        k = (Math.cos(f) * d.scaleY * g | 0) / g,
                        l = this.t.style,
                        m = this.t.currentStyle;
                    if (m) {
                        c = i, //just for swapping the variables an inverting them (reused "val" to avoid creating another variable in memory). IE's filter matrix uses a non-standard matrix configuration (angle goes the opposite way, and b and c are reversed and inverted)
                            i = -j, j = -c, b = m.filter, l.filter = ""; //remove filters so that we can accurately measure offsetWidth/offsetHeight
                        var n, o, q = this.t.offsetWidth,
                            r = this.t.offsetHeight,
                            s = "absolute" !== m.position,
                            t = "progid:DXImageTransform.Microsoft.Matrix(M11=" + h + ", M12=" + i + ", M21=" + j + ", M22=" + k,
                            w = d.x + q * d.xPercent / 100,
                            x = d.y + r * d.yPercent / 100;
                        //we must set the margins AFTER applying the filter in order to avoid some bugs in IE8 that could (in rare scenarios) cause them to be ignored intermittently (vibration).
                        if (
                            //if transformOrigin is being used, adjust the offset x and y
                            null != d.ox && (n = (d.oxp ? q * d.ox * .01 : d.ox) - q / 2, o = (d.oyp ? r * d.oy * .01 : d.oy) - r / 2, w += n - (n * h + o * i), x += o - (n * j + o * k)), s ? (n = q / 2, o = r / 2, t += ", Dx=" + (n - (n * h + o * i) + w) + ", Dy=" + (o - (n * j + o * k) + x) + ")") : t += ", sizingMethod='auto expand')", -1 !== b.indexOf("DXImageTransform.Microsoft.Matrix(") ? l.filter = b.replace(F, t) : l.filter = t + " " + b,
                            //at the end or beginning of the tween, if the matrix is normal (1, 0, 0, 1) and opacity is 100 (or doesn't exist), remove the filter to improve browser performance.
                            0 !== a && 1 !== a || 1 === h && 0 === i && 0 === j && 1 === k && (s && -1 === t.indexOf("Dx=0, Dy=0") || v.test(b) && 100 !== parseFloat(RegExp.$1) || -1 === b.indexOf(b.indexOf("Alpha")) && l.removeAttribute("filter")), !s) {
                            var //in Internet Explorer 7 and before, the box model is broken, causing the browser to treat the width/height of the actual rotated filtered image as the width/height of the box itself, but Microsoft corrected that in IE8. We must use a negative offset in IE8 on the right/bottom
                                y, z, A, B = 8 > p ? 1 : -1;
                            for (n = d.ieOffsetX || 0, o = d.ieOffsetY || 0, d.ieOffsetX = Math.round((q - ((0 > h ? -h : h) * q + (0 > i ? -i : i) * r)) / 2 + w), d.ieOffsetY = Math.round((r - ((0 > k ? -k : k) * r + (0 > j ? -j : j) * q)) / 2 + x), ta = 0; 4 > ta; ta++) z = ca[ta], y = m[z], c = -1 !== y.indexOf("px") ? parseFloat(y) : Z(this.t, z, parseFloat(y), y.replace(u, "")) || 0, A = c !== d[z] ? 2 > ta ? -d.ieOffsetX : -d.ieOffsetY : 2 > ta ? n - d.ieOffsetX : o - d.ieOffsetY, l[z] = (d[z] = Math.round(c - A * (0 === ta || 2 === ta ? 1 : B))) + "px"
                        }
                    }
                },
                /* translates a super small decimal to a string WITHOUT scientific notation
                			_safeDecimal = function(n) {
                				var s = (n < 0 ? -n : n) + "",
                					a = s.split("e-");
                				return (n < 0 ? "-0." : "0.") + new Array(parseInt(a[1], 10) || 0).join("0") + a[0].split(".").join("");
                			},
                			*/
                Pa = P.set3DTransformRatio = P.setTransformRatio = function(a) {
                    var b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z = this.data, //refers to the element's _gsTransform object
                        A = this.t.style,
                        B = z.rotation,
                        C = z.rotationX,
                        D = z.rotationY,
                        E = z.scaleX,
                        F = z.scaleY,
                        G = z.scaleZ,
                        H = z.x,
                        J = z.y,
                        K = z.z,
                        L = z.svg,
                        M = z.perspective,
                        N = z.force3D;
                    //check to see if we should render as 2D (and SVGs must use 2D when _useSVGTransformAttr is true)
                    if (((1 === a || 0 === a) && "auto" === N && (this.tween._totalTime === this.tween._totalDuration || !this.tween._totalTime) || !N) && !K && !M && !D && !C && 1 === G || xa && L || !Ca) //on the final render (which could be 0 for a from tween), if there are no 3D aspects, render in 2D to free up memory and improve performance especially on mobile devices. Check the tween's totalTime/totalDuration too in order to make sure it doesn't happen between repeats if it's a repeating tween.
                    //2D
                    //by default, we compensate skewing on the other axis to make it look more natural, but you can set the skewType to "simple" to use the uncompensated skewing that CSS does
                    //The SVG spec doesn't support percentage-based translation in the "transform" attribute, so we merge it into the matrix to simulate it.
                    //some browsers have a hard time with very small values like 2.4492935982947064e-16 (notice the "e-" towards the end) and would render the object slightly off. So we round to 5 decimal places.
                        return void(B || z.skewX || L ? (B *= I, x = z.skewX * I, y = 1e5, b = Math.cos(B) * E, e = Math.sin(B) * E, c = Math.sin(B - x) * -F, f = Math.cos(B - x) * F, x && "simple" === z.skewType && (s = Math.tan(x), s = Math.sqrt(1 + s * s), c *= s, f *= s, z.skewY && (b *= s, e *= s)), L && (H += z.xOrigin - (z.xOrigin * b + z.yOrigin * c) + z.xOffset, J += z.yOrigin - (z.xOrigin * e + z.yOrigin * f) + z.yOffset, xa && (z.xPercent || z.yPercent) && (p = this.t.getBBox(), H += .01 * z.xPercent * p.width, J += .01 * z.yPercent * p.height), p = 1e-6, p > H && H > -p && (H = 0), p > J && J > -p && (J = 0)), u = (b * y | 0) / y + "," + (e * y | 0) / y + "," + (c * y | 0) / y + "," + (f * y | 0) / y + "," + H + "," + J + ")", L && xa ? this.t.setAttribute("transform", "matrix(" + u) : A[za] = (z.xPercent || z.yPercent ? "translate(" + z.xPercent + "%," + z.yPercent + "%) matrix(" : "matrix(") + u) : A[za] = (z.xPercent || z.yPercent ? "translate(" + z.xPercent + "%," + z.yPercent + "%) matrix(" : "matrix(") + E + ",0,0," + F + "," + H + "," + J + ")");
                    if (n && (p = 1e-4, p > E && E > -p && (E = G = 2e-5), p > F && F > -p && (F = G = 2e-5), !M || z.z || z.rotationX || z.rotationY || (M = 0)), B || z.skewX) B *= I, q = b = Math.cos(B), r = e = Math.sin(B), z.skewX && (B -= z.skewX * I, q = Math.cos(B), r = Math.sin(B), "simple" === z.skewType && (s = Math.tan(z.skewX * I), s = Math.sqrt(1 + s * s), q *= s, r *= s, z.skewY && (b *= s, e *= s))), c = -r, f = q;
                    else {
                        if (!(D || C || 1 !== G || M || L)) //if we're only translating and/or 2D scaling, this is faster...
                            return void(A[za] = (z.xPercent || z.yPercent ? "translate(" + z.xPercent + "%," + z.yPercent + "%) translate3d(" : "translate3d(") + H + "px," + J + "px," + K + "px)" + (1 !== E || 1 !== F ? " scale(" + E + "," + F + ")" : ""));
                        b = f = 1, c = e = 0
                    }
                    j = 1, d = g = h = i = k = l = 0, m = M ? -1 / M : 0, o = z.zOrigin, p = 1e-6, v = ",", w = "0", B = D * I, B && (q = Math.cos(B), r = Math.sin(B), h = -r, k = m * -r, d = b * r, g = e * r, j = q, m *= q, b *= q, e *= q), B = C * I, B && (q = Math.cos(B), r = Math.sin(B), s = c * q + d * r, t = f * q + g * r, i = j * r, l = m * r, d = c * -r + d * q, g = f * -r + g * q, j *= q, m *= q, c = s, f = t), 1 !== G && (d *= G, g *= G, j *= G, m *= G), 1 !== F && (c *= F, f *= F, i *= F, l *= F), 1 !== E && (b *= E, e *= E, h *= E, k *= E), (o || L) && (o && (H += d * -o, J += g * -o, K += j * -o + o), L && (H += z.xOrigin - (z.xOrigin * b + z.yOrigin * c) + z.xOffset, J += z.yOrigin - (z.xOrigin * e + z.yOrigin * f) + z.yOffset), p > H && H > -p && (H = w), p > J && J > -p && (J = w), p > K && K > -p && (K = 0)), u = z.xPercent || z.yPercent ? "translate(" + z.xPercent + "%," + z.yPercent + "%) matrix3d(" : "matrix3d(", u += (p > b && b > -p ? w : b) + v + (p > e && e > -p ? w : e) + v + (p > h && h > -p ? w : h), u += v + (p > k && k > -p ? w : k) + v + (p > c && c > -p ? w : c) + v + (p > f && f > -p ? w : f), C || D || 1 !== G ? (u += v + (p > i && i > -p ? w : i) + v + (p > l && l > -p ? w : l) + v + (p > d && d > -p ? w : d), u += v + (p > g && g > -p ? w : g) + v + (p > j && j > -p ? w : j) + v + (p > m && m > -p ? w : m) + v) : u += ",0,0,0,0,1,0,", u += H + v + J + v + K + v + (M ? 1 + -K / M : 1) + ")", A[za] = u
                };
            j = Da.prototype, j.x = j.y = j.z = j.skewX = j.skewY = j.rotation = j.rotationX = j.rotationY = j.zOrigin = j.xPercent = j.yPercent = j.xOffset = j.yOffset = 0, j.scaleX = j.scaleY = j.scaleZ = 1, va("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin", {
                parser: function(a, b, c, d, f, h, i) {
                    if (d._lastParsedTransform === i) return f;
                    d._lastParsedTransform = i;
                    var j, k, l, m, n, o, p, q, r, s, t = a._gsTransform,
                        u = a.style,
                        v = 1e-6,
                        w = ya.length,
                        x = i,
                        y = {},
                        z = "transformOrigin";
                    if (i.display ? (l = Y(a, "display"), u.display = "block", j = Na(a, e, !0, i.parseTransform), u.display = l) : j = Na(a, e, !0, i.parseTransform), d._transform = j, "string" == typeof x.transform && za) l = N.style, l[za] = x.transform, l.display = "block", l.position = "absolute", L.body.appendChild(N), k = Na(N, null, !1), j.svg && (q = j.xOrigin, r = j.yOrigin, k.x -= j.xOffset, k.y -= j.yOffset, (x.transformOrigin || x.svgOrigin) && (m = {}, Ia(a, ea(x.transformOrigin), m, x.svgOrigin, x.smoothOrigin, !0), q = m.xOrigin, r = m.yOrigin, k.x -= m.xOffset - j.xOffset, k.y -= m.yOffset - j.yOffset), (q || r) && (s = Ma(N), k.x -= q - (q * s[0] + r * s[2]), k.y -= r - (q * s[1] + r * s[3]))), L.body.removeChild(N), k.perspective || (k.perspective = j.perspective), null != x.xPercent && (k.xPercent = ga(x.xPercent, j.xPercent)), null != x.yPercent && (k.yPercent = ga(x.yPercent, j.yPercent));
                    else if ("object" == typeof x) {
                        if (k = {
                                scaleX: ga(null != x.scaleX ? x.scaleX : x.scale, j.scaleX),
                                scaleY: ga(null != x.scaleY ? x.scaleY : x.scale, j.scaleY),
                                scaleZ: ga(x.scaleZ, j.scaleZ),
                                x: ga(x.x, j.x),
                                y: ga(x.y, j.y),
                                z: ga(x.z, j.z),
                                xPercent: ga(x.xPercent, j.xPercent),
                                yPercent: ga(x.yPercent, j.yPercent),
                                perspective: ga(x.transformPerspective, j.perspective)
                            }, p = x.directionalRotation, null != p)
                            if ("object" == typeof p)
                                for (l in p) x[l] = p[l];
                            else x.rotation = p;
                            "string" == typeof x.x && -1 !== x.x.indexOf("%") && (k.x = 0, k.xPercent = ga(x.x, j.xPercent)), "string" == typeof x.y && -1 !== x.y.indexOf("%") && (k.y = 0, k.yPercent = ga(x.y, j.yPercent)), k.rotation = ha("rotation" in x ? x.rotation : "shortRotation" in x ? x.shortRotation + "_short" : "rotationZ" in x ? x.rotationZ : j.rotation - j.skewY, j.rotation - j.skewY, "rotation", y), Ca && (k.rotationX = ha("rotationX" in x ? x.rotationX : "shortRotationX" in x ? x.shortRotationX + "_short" : j.rotationX || 0, j.rotationX, "rotationX", y), k.rotationY = ha("rotationY" in x ? x.rotationY : "shortRotationY" in x ? x.shortRotationY + "_short" : j.rotationY || 0, j.rotationY, "rotationY", y)), k.skewX = ha(x.skewX, j.skewX - j.skewY), (k.skewY = ha(x.skewY, j.skewY)) && (k.skewX += k.skewY, k.rotation += k.skewY)
                    }
                    for (Ca && null != x.force3D && (j.force3D = x.force3D, o = !0), j.skewType = x.skewType || j.skewType || g.defaultSkewType, n = j.force3D || j.z || j.rotationX || j.rotationY || k.z || k.rotationX || k.rotationY || k.perspective, n || null == x.scale || (k.scaleZ = 1); --w > -1;) c = ya[w], m = k[c] - j[c], (m > v || -v > m || null != x[c] || null != K[c]) && (o = !0, f = new qa(j, c, j[c], m, f), c in y && (f.e = y[c]), f.xs0 = 0, f.plugin = h, d._overwriteProps.push(f.n));
                    return m = x.transformOrigin, j.svg && (m || x.svgOrigin) && (q = j.xOffset, r = j.yOffset, Ia(a, ea(m), k, x.svgOrigin, x.smoothOrigin), f = ra(j, "xOrigin", (t ? j : k).xOrigin, k.xOrigin, f, z), f = ra(j, "yOrigin", (t ? j : k).yOrigin, k.yOrigin, f, z), q === j.xOffset && r === j.yOffset || (f = ra(j, "xOffset", t ? q : j.xOffset, j.xOffset, f, z), f = ra(j, "yOffset", t ? r : j.yOffset, j.yOffset, f, z)), m = xa ? null : "0px 0px"), (m || Ca && n && j.zOrigin) && (za ? (o = !0, c = Ba, m = (m || Y(a, c, e, !1, "50% 50%")) + "", f = new qa(u, c, 0, 0, f, -1, z), f.b = u[c], f.plugin = h, Ca ? (l = j.zOrigin, m = m.split(" "), j.zOrigin = (m.length > 2 && (0 === l || "0px" !== m[2]) ? parseFloat(m[2]) : l) || 0, f.xs0 = f.e = m[0] + " " + (m[1] || "50%") + " 0px", f = new qa(j, "zOrigin", 0, 0, f, -1, f.n), f.b = l, f.xs0 = f.e = j.zOrigin) : f.xs0 = f.e = m) : ea(m + "", j)), o && (d._transformType = j.svg && xa || !n && 3 !== this._transformType ? 2 : 3), f
                },
                prefix: !0
            }), va("boxShadow", {
                defaultValue: "0px 0px 0px 0px #999",
                prefix: !0,
                color: !0,
                multi: !0,
                keyword: "inset"
            }), va("borderRadius", {
                defaultValue: "0px",
                parser: function(a, b, c, f, g, h) {
                    b = this.format(b);
                    var i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"],
                        z = a.style;
                    for (q = parseFloat(a.offsetWidth), r = parseFloat(a.offsetHeight), i = b.split(" "), j = 0; j < y.length; j++) this.p.indexOf("border") && (y[j] = W(y[j])), m = l = Y(a, y[j], e, !1, "0px"), -1 !== m.indexOf(" ") && (l = m.split(" "), m = l[0], l = l[1]), n = k = i[j], o = parseFloat(m), t = m.substr((o + "").length), u = "=" === n.charAt(1), u ? (p = parseInt(n.charAt(0) + "1", 10), n = n.substr(2), p *= parseFloat(n), s = n.substr((p + "").length - (0 > p ? 1 : 0)) || "") : (p = parseFloat(n), s = n.substr((p + "").length)), "" === s && (s = d[c] || t), s !== t && (v = Z(a, "borderLeft", o, t), w = Z(a, "borderTop", o, t), "%" === s ? (m = v / q * 100 + "%", l = w / r * 100 + "%") : "em" === s ? (x = Z(a, "borderLeft", 1, "em"), m = v / x + "em", l = w / x + "em") : (m = v + "px", l = w + "px"), u && (n = parseFloat(m) + p + s, k = parseFloat(l) + p + s)), g = sa(z, y[j], m + " " + l, n + " " + k, !1, "0px", g);
                    return g
                },
                prefix: !0,
                formatter: na("0px 0px 0px 0px", !1, !0)
            }), va("borderBottomLeftRadius,borderBottomRightRadius,borderTopLeftRadius,borderTopRightRadius", {
                defaultValue: "0px",
                parser: function(a, b, c, d, f, g) {
                    return sa(a.style, c, this.format(Y(a, c, e, !1, "0px 0px")), this.format(b), !1, "0px", f)
                },
                prefix: !0,
                formatter: na("0px 0px", !1, !0)
            }), va("backgroundPosition", {
                defaultValue: "0 0",
                parser: function(a, b, c, d, f, g) {
                    var h, i, j, k, l, m, n = "background-position",
                        o = e || X(a, null),
                        q = this.format((o ? p ? o.getPropertyValue(n + "-x") + " " + o.getPropertyValue(n + "-y") : o.getPropertyValue(n) : a.currentStyle.backgroundPositionX + " " + a.currentStyle.backgroundPositionY) || "0 0"),
                        r = this.format(b);
                    if (-1 !== q.indexOf("%") != (-1 !== r.indexOf("%")) && r.split(",").length < 2 && (m = Y(a, "backgroundImage").replace(B, ""), m && "none" !== m)) {
                        for (h = q.split(" "), i = r.split(" "), O.setAttribute("src", m), j = 2; --j > -1;) q = h[j], k = -1 !== q.indexOf("%"), k !== (-1 !== i[j].indexOf("%")) && (l = 0 === j ? a.offsetWidth - O.width : a.offsetHeight - O.height, h[j] = k ? parseFloat(q) / 100 * l + "px" : parseFloat(q) / l * 100 + "%");
                        q = h.join(" ")
                    }
                    return this.parseComplex(a.style, q, r, f, g)
                },
                formatter: ea
            }), va("backgroundSize", {
                defaultValue: "0 0",
                formatter: ea
            }), va("perspective", {
                defaultValue: "0px",
                prefix: !0
            }), va("perspectiveOrigin", {
                defaultValue: "50% 50%",
                prefix: !0
            }), va("transformStyle", {
                prefix: !0
            }), va("backfaceVisibility", {
                prefix: !0
            }), va("userSelect", {
                prefix: !0
            }), va("margin", {
                parser: oa("marginTop,marginRight,marginBottom,marginLeft")
            }), va("padding", {
                parser: oa("paddingTop,paddingRight,paddingBottom,paddingLeft")
            }), va("clip", {
                defaultValue: "rect(0px,0px,0px,0px)",
                parser: function(a, b, c, d, f, g) {
                    var h, i, j;
                    return 9 > p ? (i = a.currentStyle, j = 8 > p ? " " : ",", h = "rect(" + i.clipTop + j + i.clipRight + j + i.clipBottom + j + i.clipLeft + ")", b = this.format(b).split(",").join(j)) : (h = this.format(Y(a, this.p, e, !1, this.dflt)), b = this.format(b)), this.parseComplex(a.style, h, b, f, g)
                }
            }), va("textShadow", {
                defaultValue: "0px 0px 0px #999",
                color: !0,
                multi: !0
            }), va("autoRound,strictUnits", {
                parser: function(a, b, c, d, e) {
                    return e
                }
            }), va("border", {
                defaultValue: "0px solid #000",
                parser: function(a, b, c, d, f, g) {
                    return this.parseComplex(a.style, this.format(Y(a, "borderTopWidth", e, !1, "0px") + " " + Y(a, "borderTopStyle", e, !1, "solid") + " " + Y(a, "borderTopColor", e, !1, "#000")), this.format(b), f, g)
                },
                color: !0,
                formatter: function(a) {
                    var b = a.split(" ");
                    return b[0] + " " + (b[1] || "solid") + " " + (a.match(ma) || ["#000"])[0]
                }
            }), va("borderWidth", {
                parser: oa("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")
            }), va("float,cssFloat,styleFloat", {
                parser: function(a, b, c, d, e, f) {
                    var g = a.style,
                        h = "cssFloat" in g ? "cssFloat" : "styleFloat";
                    return new qa(g, h, 0, 0, e, -1, c, !1, 0, g[h], b)
                }
            });
            //opacity-related
            var Qa = function(a) {
                var b, c = this.t, //refers to the element's style property
                    d = c.filter || Y(this.data, "filter") || "",
                    e = this.s + this.c * a | 0;
                100 === e && (-1 === d.indexOf("atrix(") && -1 === d.indexOf("radient(") && -1 === d.indexOf("oader(") ? (c.removeAttribute("filter"), b = !Y(this.data, "filter")) : (c.filter = d.replace(x, ""), b = !0)), b || (this.xn1 && (c.filter = d = d || "alpha(opacity=" + e + ")"), -1 === d.indexOf("pacity") ? //only used if browser doesn't support the standard opacity style property (IE 7 and 8). We omit the "O" to avoid case-sensitivity issues
                    0 === e && this.xn1 || ( //bugs in IE7/8 won't render the filter properly if opacity is ADDED on the same frame/render as "visibility" changes (this.xn1 is 1 if this tween is an "autoAlpha" tween)
                        c.filter = d + " alpha(opacity=" + e + ")") : c.filter = d.replace(v, "opacity=" + e))
            };
            va("opacity,alpha,autoAlpha", {
                defaultValue: "1",
                parser: function(a, b, c, d, f, g) {
                    var h = parseFloat(Y(a, "opacity", e, !1, "1")),
                        i = a.style,
                        j = "autoAlpha" === c; //if visibility is initially set to "hidden", we should interpret that as intent to make opacity 0 (a convenience)
                    //we need to record whether or not this is an autoAlpha so that in the setRatio(), we know to duplicate the setting of the alpha in order to work around a bug in IE7 and IE8 that prevents changes to "visibility" from taking effect if the filter is changed to a different alpha(opacity) at the same time. Setting it to the SAME value first, then the new value works around the IE7/8 bug.
                    //helps correct an IE issue.
                    //we have to create the "visibility" PropTween after the opacity one in the linked list so that they run in the order that works properly in IE8 and earlier
                    return "string" == typeof b && "=" === b.charAt(1) && (b = ("-" === b.charAt(0) ? -1 : 1) * parseFloat(b.substr(2)) + h), j && 1 === h && "hidden" === Y(a, "visibility", e) && 0 !== b && (h = 0), R ? f = new qa(i, "opacity", h, b - h, f) : (f = new qa(i, "opacity", 100 * h, 100 * (b - h), f), f.xn1 = j ? 1 : 0, i.zoom = 1, f.type = 2, f.b = "alpha(opacity=" + f.s + ")", f.e = "alpha(opacity=" + (f.s + f.c) + ")", f.data = a, f.plugin = g, f.setRatio = Qa), j && (f = new qa(i, "visibility", 0, 0, f, -1, null, !1, 0, 0 !== h ? "inherit" : "hidden", 0 === b ? "hidden" : "inherit"), f.xs0 = "inherit", d._overwriteProps.push(f.n), d._overwriteProps.push(c)), f
                }
            });
            var Ra = function(a, b) {
                    b && (a.removeProperty ? ("ms" !== b.substr(0, 2) && "webkit" !== b.substr(0, 6) || ( //Microsoft and some Webkit browsers don't conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it's correct (otherwise it'd be "ms-transform" instead of "-ms-transform" for IE9, for example)
                            b = "-" + b), a.removeProperty(b.replace(z, "-$1").toLowerCase())) : //note: old versions of IE use "removeAttribute()" instead of "removeProperty()"
                        a.removeAttribute(b))
                },
                Sa = function(a) {
                    if (this.t._gsClassPT = this, 1 === a || 0 === a) {
                        this.t.setAttribute("class", 0 === a ? this.b : this.e);
                        for (var b = this.data, //first MiniPropTween
                                c = this.t.style; b;) b.v ? c[b.p] = b.v : Ra(c, b.p), b = b._next;
                        1 === a && this.t._gsClassPT === this && (this.t._gsClassPT = null)
                    } else this.t.getAttribute("class") !== this.e && this.t.setAttribute("class", this.e)
                };
            va("className", {
                parser: function(a, b, d, f, g, h, i) {
                    var j, k, l, m, n, o = a.getAttribute("class") || "", //don't use t.className because it doesn't work consistently on SVG elements; getAttribute("class") and setAttribute("class", value") is more reliable.
                        p = a.style.cssText;
                    if (g = f._classNamePT = new qa(a, d, 0, 0, g, 2), g.setRatio = Sa, g.pr = -11, c = !0, g.b = o, k = _(a, e), l = a._gsClassPT) { //first MiniPropTween which stores the inline styles - we need to force these so that the inline styles don't contaminate things. Otherwise, there's a small chance that a tween could start and the inline values match the destination values and they never get cleaned.
                        for (m = {}, n = l.data; n;) m[n.p] = 1, n = n._next;
                        l.setRatio(1)
                    } //we record the CSSPropTween as the xfirst so that we can handle overwriting propertly (if "className" gets overwritten, we must kill all the properties associated with the className part of the tween, so we can loop through from xfirst to the pt itself)
                    //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
                    return a._gsClassPT = g, g.e = "=" !== b.charAt(1) ? b : o.replace(new RegExp("(?:\\s|^)" + b.substr(2) + "(?![\\w-])"), "") + ("+" === b.charAt(0) ? " " + b.substr(2) : ""), a.setAttribute("class", g.e), j = aa(a, k, _(a), i, m), a.setAttribute("class", o), g.data = j.firstMPT, a.style.cssText = p, g = g.xfirst = f.parse(a, j.difs, g, h)
                }
            });
            var Ta = function(a) {
                if ((1 === a || 0 === a) && this.data._totalTime === this.data._totalDuration && "isFromStart" !== this.data.data) { //this.data refers to the tween. Only clear at the END of the tween (remember, from() tweens make the ratio go from 1 to 0, so we can't just check that and if the tween is the zero-duration one that's created internally to render the starting values in a from() tween, ignore that because otherwise, for example, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in).
                    var b, c, d, e, f, g = this.t.style,
                        h = i.transform.parse;
                    if ("all" === this.e) g.cssText = "", e = !0;
                    else
                        for (b = this.e.split(" ").join("").split(","), d = b.length; --d > -1;) c = b[d], i[c] && (i[c].parse === h ? e = !0 : c = "transformOrigin" === c ? Ba : i[c].p), Ra(g, c);
                    e && (Ra(g, za), f = this.t._gsTransform, f && (f.svg && (this.t.removeAttribute("data-svg-origin"), this.t.removeAttribute("transform")), delete this.t._gsTransform))
                }
            };
            for (va("clearProps", {
                    parser: function(a, b, d, e, f) {
                        return f = new qa(a, d, 0, 0, f, 2), f.setRatio = Ta, f.e = b, f.pr = -10, f.data = e._tween, c = !0, f
                    }
                }), j = "bezier,throwProps,physicsProps,physics2D".split(","), ta = j.length; ta--;) wa(j[ta]);
            j = g.prototype, j._firstPT = j._lastParsedTransform = j._transform = null, j._onInitTween = function(a, b, h) {
                if (!a.nodeType) return !1;
                this._target = a, this._tween = h, this._vars = b, k = b.autoRound, c = !1, d = b.suffixMap || g.suffixMap, e = X(a, ""), f = this._overwriteProps;
                var j, n, p, q, r, s, t, u, v, x = a.style;
                if (l && "" === x.zIndex && (j = Y(a, "zIndex", e), "auto" !== j && "" !== j || this._addLazySet(x, "zIndex", 0)), "string" == typeof b && (q = x.cssText, j = _(a, e), x.cssText = q + ";" + b, j = aa(a, j, _(a)).difs, !R && w.test(b) && (j.opacity = parseFloat(RegExp.$1)), b = j, x.cssText = q), b.className ? this._firstPT = n = i.className.parse(a, b.className, "className", this, null, null, b) : this._firstPT = n = this.parse(a, b, null), this._transformType) {
                    for (v = 3 === this._transformType, za ? m && (l = !0, "" === x.zIndex && (t = Y(a, "zIndex", e), "auto" !== t && "" !== t || this._addLazySet(x, "zIndex", 0)), o && this._addLazySet(x, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (v ? "visible" : "hidden"))) : x.zoom = 1, p = n; p && p._next;) p = p._next;
                    u = new qa(a, "transform", 0, 0, null, 2), this._linkCSSP(u, null, p), u.setRatio = za ? Pa : Oa, u.data = this._transform || Na(a, e, !0), u.tween = h, u.pr = -1, f.pop()
                }
                if (c) {
                    for (; n;) {
                        for (s = n._next, p = q; p && p.pr > n.pr;) p = p._next;
                        (n._prev = p ? p._prev : r) ? n._prev._next = n: q = n, (n._next = p) ? p._prev = n : r = n, n = s
                    }
                    this._firstPT = q
                }
                return !0
            }, j.parse = function(a, b, c, f) {
                var g, h, j, l, m, n, o, p, q, r, s = a.style;
                for (g in b) n = b[g], h = i[g], h ? c = h.parse(a, n, g, this, c, f, b) : (m = Y(a, g, e) + "", q = "string" == typeof n, "color" === g || "fill" === g || "stroke" === g || -1 !== g.indexOf("Color") || q && y.test(n) ? (q || (n = ka(n), n = (n.length > 3 ? "rgba(" : "rgb(") + n.join(",") + ")"), c = sa(s, g, m, n, !0, "transparent", c, 0, f)) : q && H.test(n) ? c = sa(s, g, m, n, !0, null, c, 0, f) : (j = parseFloat(m), o = j || 0 === j ? m.substr((j + "").length) : "", "" !== m && "auto" !== m || ("width" === g || "height" === g ? (j = da(a, g, e), o = "px") : "left" === g || "top" === g ? (j = $(a, g, e), o = "px") : (j = "opacity" !== g ? 0 : 1, o = "")), r = q && "=" === n.charAt(1), r ? (l = parseInt(n.charAt(0) + "1", 10), n = n.substr(2), l *= parseFloat(n), p = n.replace(u, "")) : (l = parseFloat(n), p = q ? n.replace(u, "") : ""), "" === p && (p = g in d ? d[g] : o), n = l || 0 === l ? (r ? l + j : l) + p : b[g], o !== p && "" !== p && (l || 0 === l) && j && (j = Z(a, g, j, o), "%" === p ? (j /= Z(a, g, 100, "%") / 100, b.strictUnits !== !0 && (m = j + "%")) : "em" === p || "rem" === p || "vw" === p || "vh" === p ? j /= Z(a, g, 1, p) : "px" !== p && (l = Z(a, g, l, p), p = "px"), r && (l || 0 === l) && (n = l + j + p)), r && (l += j), !j && 0 !== j || !l && 0 !== l ? void 0 !== s[g] && (n || n + "" != "NaN" && null != n) ? (c = new qa(s, g, l || j || 0, 0, c, -1, g, !1, 0, m, n), c.xs0 = "none" !== n || "display" !== g && -1 === g.indexOf("Style") ? n : m) : T("invalid " + g + " tween value: " + b[g]) : (c = new qa(s, g, j, l - j, c, 0, g, k !== !1 && ("px" === p || "zIndex" === g), 0, m, n), c.xs0 = p))), f && c && !c.plugin && (c.plugin = f);
                return c
            }, j.setRatio = function(a) {
                var b, c, d, e = this._firstPT,
                    f = 1e-6;
                if (1 !== a || this._tween._time !== this._tween._duration && 0 !== this._tween._time)
                    if (a || this._tween._time !== this._tween._duration && 0 !== this._tween._time || this._tween._rawPrevTime === -1e-6)
                        for (; e;) {
                            if (b = e.c * a + e.s, e.r ? b = Math.round(b) : f > b && b > -f && (b = 0), e.type)
                                if (1 === e.type)
                                    if (d = e.l, 2 === d) e.t[e.p] = e.xs0 + b + e.xs1 + e.xn1 + e.xs2;
                                    else if (3 === d) e.t[e.p] = e.xs0 + b + e.xs1 + e.xn1 + e.xs2 + e.xn2 + e.xs3;
                            else if (4 === d) e.t[e.p] = e.xs0 + b + e.xs1 + e.xn1 + e.xs2 + e.xn2 + e.xs3 + e.xn3 + e.xs4;
                            else if (5 === d) e.t[e.p] = e.xs0 + b + e.xs1 + e.xn1 + e.xs2 + e.xn2 + e.xs3 + e.xn3 + e.xs4 + e.xn4 + e.xs5;
                            else {
                                for (c = e.xs0 + b + e.xs1, d = 1; d < e.l; d++) c += e["xn" + d] + e["xs" + (d + 1)];
                                e.t[e.p] = c
                            } else -1 === e.type ? e.t[e.p] = e.xs0 : e.setRatio && e.setRatio(a);
                            else e.t[e.p] = b + e.xs0;
                            e = e._next
                        } else
                            for (; e;) 2 !== e.type ? e.t[e.p] = e.b : e.setRatio(a), e = e._next;
                    else
                        for (; e;) {
                            if (2 !== e.type)
                                if (e.r && -1 !== e.type)
                                    if (b = Math.round(e.s + e.c), e.type) {
                                        if (1 === e.type) {
                                            for (d = e.l, c = e.xs0 + b + e.xs1, d = 1; d < e.l; d++) c += e["xn" + d] + e["xs" + (d + 1)];
                                            e.t[e.p] = c
                                        }
                                    } else e.t[e.p] = b + e.xs0;
                            else e.t[e.p] = e.e;
                            else e.setRatio(a);
                            e = e._next
                        }
            }, j._enableTransforms = function(a) {
                this._transform = this._transform || Na(this._target, e, !0), this._transformType = this._transform.svg && xa || !a && 3 !== this._transformType ? 2 : 3
            };
            var Ua = function(a) {
                this.t[this.p] = this.e, this.data._linkCSSP(this, this._next, null, !0)
            }; /** @private Gives us a way to set a value on the first render (and only the first render). **/
            j._addLazySet = function(a, b, c) {
                    var d = this._firstPT = new qa(a, b, 0, 0, this._firstPT, 2);
                    d.e = c, d.setRatio = Ua, d.data = this
                }, /** @private **/
                j._linkCSSP = function(a, b, c, d) {
                    return a && (b && (b._prev = a), a._next && (a._next._prev = a._prev), a._prev ? a._prev._next = a._next : this._firstPT === a && (this._firstPT = a._next, d = !0), c ? c._next = a : d || null !== this._firstPT || (this._firstPT = a), a._next = b, a._prev = c), a
                },
                //we need to make sure that if alpha or autoAlpha is killed, opacity is too. And autoAlpha affects the "visibility" property.
                j._kill = function(b) {
                    var c, d, e, f = b;
                    if (b.autoAlpha || b.alpha) {
                        f = {};
                        for (d in b) //copy the lookup so that we're not changing the original which may be passed elsewhere.
                            f[d] = b[d];
                        f.opacity = 1, f.autoAlpha && (f.visibility = 1)
                    } //for className tweens, we need to kill any associated CSSPropTweens too; a linked list starts at the className's "xfirst".
                    return b.className && (c = this._classNamePT) && (e = c.xfirst, e && e._prev ? this._linkCSSP(e._prev, c._next, e._prev._prev) : e === this._firstPT && (this._firstPT = c._next), c._next && this._linkCSSP(c._next, c._next._next, e._prev), this._classNamePT = null), a.prototype._kill.call(this, f)
                };
            //used by cascadeTo() for gathering all the style properties of each child element into an array for comparison.
            var Va = function(a, b, c) {
                var d, e, f, g;
                if (a.slice)
                    for (e = a.length; --e > -1;) Va(a[e], b, c);
                else
                    for (d = a.childNodes, e = d.length; --e > -1;) f = d[e], g = f.type, f.style && (b.push(_(f)), c && c.push(f)), 1 !== g && 9 !== g && 11 !== g || !f.childNodes.length || Va(f, b, c)
            };
            /**
             * Typically only useful for className tweens that may affect child elements, this method creates a TweenLite
             * and then compares the style properties of all the target's child elements at the tween's start and end, and
             * if any are different, it also creates tweens for those and returns an array containing ALL of the resulting
             * tweens (so that you can easily add() them to a TimelineLite, for example). The reason this functionality is
             * wrapped into a separate static method of CSSPlugin instead of being integrated into all regular className tweens
             * is because it creates entirely new tweens that may have completely different targets than the original tween,
             * so if they were all lumped into the original tween instance, it would be inconsistent with the rest of the API
             * and it would create other problems. For example:
             *  - If I create a tween of elementA, that tween instance may suddenly change its target to include 50 other elements (unintuitive if I specifically defined the target I wanted)
             *  - We can't just create new independent tweens because otherwise, what happens if the original/parent tween is reversed or pause or dropped into a TimelineLite for tight control? You'd expect that tween's behavior to affect all the others.
             *  - Analyzing every style property of every child before and after the tween is an expensive operation when there are many children, so this behavior shouldn't be imposed on all className tweens by default, especially since it's probably rare that this extra functionality is needed.
             *
             * @param {Object} target object to be tweened
             * @param {number} Duration in seconds (or frames for frames-based tweens)
             * @param {Object} Object containing the end values, like {className:"newClass", ease:Linear.easeNone}
             * @return {Array} An array of TweenLite instances
             */
            return g.cascadeTo = function(a, c, d) {
                var e, f, g, h, i = b.to(a, c, d),
                    j = [i],
                    k = [],
                    l = [],
                    m = [],
                    n = b._internals.reservedProps;
                for (a = i._targets || i.target, Va(a, k, m), i.render(c, !0, !0), Va(a, l), i.render(0, !0, !0), i._enabled(!0), e = m.length; --e > -1;)
                    if (f = aa(m[e], k[e], l[e]), f.firstMPT) {
                        f = f.difs;
                        for (g in d) n[g] && (f[g] = d[g]);
                        h = {};
                        for (g in f) h[g] = k[e][g];
                        j.push(b.fromTo(m[e], c, h, f))
                    }
                return j
            }, a.activate([g]), g
        }, !0)
    }), _gsScope._gsDefine && _gsScope._gsQueue.pop()(),
    //export to AMD/RequireJS and CommonJS/Node (precursor to full modular build system coming at a later date)
    function(a) {
        "use strict";
        var b = function() {
            return (_gsScope.GreenSockGlobals || _gsScope)[a]
        };
        "function" == typeof define && define.amd ? //AMD
            define(["TweenLite"], b) : "undefined" != typeof module && module.exports && ( //node
                require("../TweenLite.js"), module.exports = b())
    }("CSSPlugin"),
    /*!
     * VERSION: 1.18.4
     * DATE: 2016-04-26
     * UPDATES AND DOCS AT: http://greensock.com
     *
     * @license Copyright (c) 2008-2016, GreenSock. All rights reserved.
     * This work is subject to the terms at http://greensock.com/standard-license or for
     * Club GreenSock members, the software agreement that was issued with your membership.
     * 
     * @author: Jack Doyle, jack@greensock.com
     */
    function(a, b) {
        "use strict";
        var c = a.GreenSockGlobals = a.GreenSockGlobals || a;
        if (!c.TweenLite) {
            var d, e, f, g, h, i = function(a) {
                    var b, d = a.split("."),
                        e = c;
                    for (b = 0; b < d.length; b++) e[d[b]] = e = e[d[b]] || {};
                    return e
                },
                j = i("com.greensock"),
                k = 1e-10,
                l = function(a) { //don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
                    var b, c = [],
                        d = a.length;
                    for (b = 0; b !== d; c.push(a[b++]));
                    return c
                },
                m = function() {},
                n = function() { //works around issues in iframe environments where the Array global isn't shared, thus if the object originates in a different window/iframe, "(obj instanceof Array)" will evaluate false. We added some speed optimizations to avoid Object.prototype.toString.call() unless it's absolutely necessary because it's VERY slow (like 20x slower)
                    var a = Object.prototype.toString,
                        b = a.call([]);
                    return function(c) {
                        return null != c && (c instanceof Array || "object" == typeof c && !!c.push && a.call(c) === b)
                    }
                }(),
                o = {},
                /**
                 * @constructor
                 * Defines a GreenSock class, optionally with an array of dependencies that must be instantiated first and passed into the definition.
                 * This allows users to load GreenSock JS files in any order even if they have interdependencies (like CSSPlugin extends TweenPlugin which is
                 * inside TweenLite.js, but if CSSPlugin is loaded first, it should wait to run its code until TweenLite.js loads and instantiates TweenPlugin
                 * and then pass TweenPlugin to CSSPlugin's definition). This is all done automatically and internally.
                 *
                 * Every definition will be added to a "com.greensock" global object (typically window, but if a window.GreenSockGlobals object is found,
                 * it will go there as of v1.7). For example, TweenLite will be found at window.com.greensock.TweenLite and since it's a global class that should be available anywhere,
                 * it is ALSO referenced at window.TweenLite. However some classes aren't considered global, like the base com.greensock.core.Animation class, so
                 * those will only be at the package like window.com.greensock.core.Animation. Again, if you define a GreenSockGlobals object on the window, everything
                 * gets tucked neatly inside there instead of on the window directly. This allows you to do advanced things like load multiple versions of GreenSock
                 * files and put them into distinct objects (imagine a banner ad uses a newer version but the main site uses an older one). In that case, you could
                 * sandbox the banner one like:
                 *
                 * <script>
                 *     var gs = window.GreenSockGlobals = {}; //the newer version we're about to load could now be referenced in a "gs" object, like gs.TweenLite.to(...). Use whatever alias you want as long as it's unique, "gs" or "banner" or whatever.
                 * </script>
                 * <script src="js/greensock/v1.7/TweenMax.js"></script>
                 * <script>
                 *     window.GreenSockGlobals = window._gsQueue = window._gsDefine = null; //reset it back to null (along with the special _gsQueue variable) so that the next load of TweenMax affects the window and we can reference things directly like TweenLite.to(...)
                 * </script>
                 * <script src="js/greensock/v1.6/TweenMax.js"></script>
                 * <script>
                 *     gs.TweenLite.to(...); //would use v1.7
                 *     TweenLite.to(...); //would use v1.6
                 * </script>
                 *
                 * @param {!string} ns The namespace of the class definition, leaving off "com.greensock." as that's assumed. For example, "TweenLite" or "plugins.CSSPlugin" or "easing.Back".
                 * @param {!Array.<string>} dependencies An array of dependencies (described as their namespaces minus "com.greensock." prefix). For example ["TweenLite","plugins.TweenPlugin","core.Animation"]
                 * @param {!function():Object} func The function that should be called and passed the resolved dependencies which will return the actual class for this definition.
                 * @param {boolean=} global If true, the class will be added to the global scope (typically window unless you define a window.GreenSockGlobals object)
                 */
                p = function(d, e, f, g) {
                    this.sc = o[d] ? o[d].sc : [], //subclasses
                        o[d] = this, this.gsClass = null, this.func = f;
                    var h = [];
                    this.check = function(j) {
                        for (var k, l, m, n, q, r = e.length, s = r; --r > -1;)(k = o[e[r]] || new p(e[r], [])).gsClass ? (h[r] = k.gsClass, s--) : j && k.sc.push(this);
                        if (0 === s && f)
                            for (l = ("com.greensock." + d).split("."), m = l.pop(), n = i(l.join("."))[m] = this.gsClass = f.apply(f, h), g && (c[m] = n, q = "undefined" != typeof module && module.exports, !q && "function" == typeof define && define.amd ? define((a.GreenSockAMDPath ? a.GreenSockAMDPath + "/" : "") + d.split(".").pop(), [], function() {
                                    return n
                                }) : d === b && q && (module.exports = n)), r = 0; r < this.sc.length; r++) this.sc[r].check()
                    }, this.check(!0)
                },
                //used to create Definition instances (which basically registers a class that has dependencies).
                q = a._gsDefine = function(a, b, c, d) {
                    return new p(a, b, c, d)
                },
                //a quick way to create a class that doesn't have any dependencies. Returns the class, but first registers it in the GreenSock namespace so that other classes can grab it (other classes might be dependent on the class).
                r = j._class = function(a, b, c) {
                    return b = b || function() {}, q(a, [], function() {
                        return b
                    }, c), b
                };
            q.globals = c;
            /*
             * ----------------------------------------------------------------
             * Ease
             * ----------------------------------------------------------------
             */
            var s = [0, 0, 1, 1],
                t = [],
                u = r("easing.Ease", function(a, b, c, d) {
                    this._func = a, this._type = c || 0, this._power = d || 0, this._params = b ? s.concat(b) : s
                }, !0),
                v = u.map = {},
                w = u.register = function(a, b, c, d) {
                    for (var e, f, g, h, i = b.split(","), k = i.length, l = (c || "easeIn,easeOut,easeInOut").split(","); --k > -1;)
                        for (f = i[k], e = d ? r("easing." + f, null, !0) : j.easing[f] || {}, g = l.length; --g > -1;) h = l[g], v[f + "." + h] = v[h + f] = e[h] = a.getRatio ? a : a[h] || new a
                };
            for (f = u.prototype, f._calcEnd = !1, f.getRatio = function(a) {
                    if (this._func) return this._params[0] = a, this._func.apply(null, this._params);
                    var b = this._type,
                        c = this._power,
                        d = 1 === b ? 1 - a : 2 === b ? a : .5 > a ? 2 * a : 2 * (1 - a);
                    return 1 === c ? d *= d : 2 === c ? d *= d * d : 3 === c ? d *= d * d * d : 4 === c && (d *= d * d * d * d), 1 === b ? 1 - d : 2 === b ? d : .5 > a ? d / 2 : 1 - d / 2
                },
                //create all the standard eases like Linear, Quad, Cubic, Quart, Quint, Strong, Power0, Power1, Power2, Power3, and Power4 (each with easeIn, easeOut, and easeInOut)
                d = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"], e = d.length; --e > -1;) f = d[e] + ",Power" + e, w(new u(null, null, 1, e), f, "easeOut", !0), w(new u(null, null, 2, e), f, "easeIn" + (0 === e ? ",easeNone" : "")), w(new u(null, null, 3, e), f, "easeInOut");
            v.linear = j.easing.Linear.easeIn, v.swing = j.easing.Quad.easeInOut; //for jQuery folks
            /*
             * ----------------------------------------------------------------
             * EventDispatcher
             * ----------------------------------------------------------------
             */
            var x = r("events.EventDispatcher", function(a) {
                this._listeners = {}, this._eventTarget = a || this
            });
            f = x.prototype, f.addEventListener = function(a, b, c, d, e) {
                e = e || 0;
                var f, i, j = this._listeners[a],
                    k = 0;
                for (null == j && (this._listeners[a] = j = []), i = j.length; --i > -1;) f = j[i], f.c === b && f.s === c ? j.splice(i, 1) : 0 === k && f.pr < e && (k = i + 1);
                j.splice(k, 0, {
                    c: b,
                    s: c,
                    up: d,
                    pr: e
                }), this !== g || h || g.wake()
            }, f.removeEventListener = function(a, b) {
                var c, d = this._listeners[a];
                if (d)
                    for (c = d.length; --c > -1;)
                        if (d[c].c === b) return void d.splice(c, 1)
            }, f.dispatchEvent = function(a) {
                var b, c, d, e = this._listeners[a];
                if (e)
                    for (b = e.length, c = this._eventTarget; --b > -1;) d = e[b], d && (d.up ? d.c.call(d.s || c, {
                        type: a,
                        target: c
                    }) : d.c.call(d.s || c))
            };
            /*
             * ----------------------------------------------------------------
             * Ticker
             * ----------------------------------------------------------------
             */
            var y = a.requestAnimationFrame,
                z = a.cancelAnimationFrame,
                A = Date.now || function() {
                    return (new Date).getTime()
                },
                B = A();
            for (
                //now try to determine the requestAnimationFrame and cancelAnimationFrame functions and if none are found, we'll use a setTimeout()/clearTimeout() polyfill.
                d = ["ms", "moz", "webkit", "o"], e = d.length; --e > -1 && !y;) y = a[d[e] + "RequestAnimationFrame"], z = a[d[e] + "CancelAnimationFrame"] || a[d[e] + "CancelRequestAnimationFrame"];
            r("Ticker", function(a, b) {
                var //helps reduce gc burden
                    c, d, e, f, i, j = this,
                    l = A(),
                    n = b !== !1 && y ? "auto" : !1,
                    o = 500,
                    p = 33,
                    q = "tick",
                    r = function(a) {
                        var b, g, h = A() - B;
                        h > o && (l += h - p), B += h, j.time = (B - l) / 1e3, b = j.time - i, (!c || b > 0 || a === !0) && (j.frame++, i += b + (b >= f ? .004 : f - b), g = !0), a !== !0 && (e = d(r)), g && j.dispatchEvent(q)
                    };
                x.call(j), j.time = j.frame = 0, j.tick = function() {
                        r(!0)
                    }, j.lagSmoothing = function(a, b) {
                        o = a || 1 / k, p = Math.min(b, o, 0)
                    }, j.sleep = function() {
                        null != e && (n && z ? z(e) : clearTimeout(e), d = m, e = null, j === g && (h = !1))
                    }, j.wake = function(a) {
                        null !== e ? j.sleep() : a ? l += -B + (B = A()) : j.frame > 10 && ( //don't trigger lagSmoothing if we're just waking up, and make sure that at least 10 frames have elapsed because of the iOS bug that we work around below with the 1.5-second setTimout().
                            B = A() - o + 5), d = 0 === c ? m : n && y ? y : function(a) {
                            return setTimeout(a, 1e3 * (i - j.time) + 1 | 0)
                        }, j === g && (h = !0), r(2)
                    }, j.fps = function(a) {
                        return arguments.length ? (c = a, f = 1 / (c || 60), i = this.time + f, void j.wake()) : c
                    }, j.useRAF = function(a) {
                        return arguments.length ? (j.sleep(), n = a, void j.fps(c)) : n
                    }, j.fps(a),
                    //a bug in iOS 6 Safari occasionally prevents the requestAnimationFrame from working initially, so we use a 1.5-second timeout that automatically falls back to setTimeout() if it senses this condition.
                    setTimeout(function() {
                        "auto" === n && j.frame < 5 && "hidden" !== document.visibilityState && j.useRAF(!1)
                    }, 1500)
            }), f = j.Ticker.prototype = new j.events.EventDispatcher, f.constructor = j.Ticker;
            /*
             * ----------------------------------------------------------------
             * Animation
             * ----------------------------------------------------------------
             */
            var C = r("core.Animation", function(a, b) {
                if (this.vars = b = b || {}, this._duration = this._totalDuration = a || 0, this._delay = Number(b.delay) || 0, this._timeScale = 1, this._active = b.immediateRender === !0, this.data = b.data, this._reversed = b.reversed === !0, V) {
                    h || //some browsers (like iOS 6 Safari) shut down JavaScript execution when the tab is disabled and they [occasionally] neglect to start up requestAnimationFrame again when returning - this code ensures that the engine starts up again properly.
                        g.wake();
                    var c = this.vars.useFrames ? U : V;
                    c.add(this, c._time), this.vars.paused && this.paused(!0)
                }
            });
            g = C.ticker = new j.Ticker, f = C.prototype, f._dirty = f._gc = f._initted = f._paused = !1, f._totalTime = f._time = 0, f._rawPrevTime = -1, f._next = f._last = f._onUpdate = f._timeline = f.timeline = null, f._paused = !1;
            //some browsers (like iOS) occasionally drop the requestAnimationFrame event when the user switches to a different tab and then comes back again, so we use a 2-second setTimeout() to sense if/when that condition occurs and then wake() the ticker.
            var D = function() {
                h && A() - B > 2e3 && g.wake(), setTimeout(D, 2e3)
            };
            D(), f.play = function(a, b) {
                    return null != a && this.seek(a, b), this.reversed(!1).paused(!1)
                }, f.pause = function(a, b) {
                    return null != a && this.seek(a, b), this.paused(!0)
                }, f.resume = function(a, b) {
                    return null != a && this.seek(a, b), this.paused(!1)
                }, f.seek = function(a, b) {
                    return this.totalTime(Number(a), b !== !1)
                }, f.restart = function(a, b) {
                    return this.reversed(!1).paused(!1).totalTime(a ? -this._delay : 0, b !== !1, !0)
                }, f.reverse = function(a, b) {
                    return null != a && this.seek(a || this.totalDuration(), b), this.reversed(!0).paused(!1)
                }, f.render = function(a, b, c) {}, f.invalidate = function() {
                    return this._time = this._totalTime = 0, this._initted = this._gc = !1, this._rawPrevTime = -1, !this._gc && this.timeline || this._enabled(!0), this
                }, f.isActive = function() {
                    var a, b = this._timeline, //the 2 root timelines won't have a _timeline; they're always active.
                        c = this._startTime;
                    return !b || !this._gc && !this._paused && b.isActive() && (a = b.rawTime()) >= c && a < c + this.totalDuration() / this._timeScale
                }, f._enabled = function(a, b) {
                    return h || g.wake(), this._gc = !a, this._active = this.isActive(), b !== !0 && (a && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !a && this.timeline && this._timeline._remove(this, !0)), !1
                }, f._kill = function(a, b) {
                    return this._enabled(!1, !1)
                }, f.kill = function(a, b) {
                    return this._kill(a, b), this
                }, f._uncache = function(a) {
                    for (var b = a ? this : this.timeline; b;) b._dirty = !0, b = b.timeline;
                    return this
                }, f._swapSelfInParams = function(a) {
                    for (var b = a.length, c = a.concat(); --b > -1;) "{self}" === a[b] && (c[b] = this);
                    return c
                }, f._callback = function(a) {
                    var b = this.vars;
                    b[a].apply(b[a + "Scope"] || b.callbackScope || this, b[a + "Params"] || t)
                },
                //----Animation getters/setters --------------------------------------------------------
                f.eventCallback = function(a, b, c, d) {
                    if ("on" === (a || "").substr(0, 2)) {
                        var e = this.vars;
                        if (1 === arguments.length) return e[a];
                        null == b ? delete e[a] : (e[a] = b, e[a + "Params"] = n(c) && -1 !== c.join("").indexOf("{self}") ? this._swapSelfInParams(c) : c, e[a + "Scope"] = d), "onUpdate" === a && (this._onUpdate = b)
                    }
                    return this
                }, f.delay = function(a) {
                    return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + a - this._delay), this._delay = a, this) : this._delay
                }, f.duration = function(a) { //true in case it's a TweenMax or TimelineMax that has a repeat - we'll need to refresh the totalDuration.
                    return arguments.length ? (this._duration = this._totalDuration = a, this._uncache(!0), this._timeline.smoothChildTiming && this._time > 0 && this._time < this._duration && 0 !== a && this.totalTime(this._totalTime * (a / this._duration), !0), this) : (this._dirty = !1, this._duration)
                }, f.totalDuration = function(a) {
                    return this._dirty = !1, arguments.length ? this.duration(a) : this._totalDuration
                }, f.time = function(a, b) {
                    return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(a > this._duration ? this._duration : a, b)) : this._time
                }, f.totalTime = function(a, b, c) {
                    if (h || g.wake(), !arguments.length) return this._totalTime;
                    if (this._timeline) {
                        if (0 > a && !c && (a += this.totalDuration()), this._timeline.smoothChildTiming) {
                            this._dirty && this.totalDuration();
                            var d = this._totalDuration,
                                e = this._timeline;
                            //in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The startTime of that child would get pushed out, but one of the ancestors may have completed.
                            if (a > d && !c && (a = d), this._startTime = (this._paused ? this._pauseTime : e._time) - (this._reversed ? d - a : a) / this._timeScale, e._dirty || //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.
                                this._uncache(!1), e._timeline)
                                for (; e._timeline;) e._timeline._time !== (e._startTime + e._totalTime) / e._timeScale && e.totalTime(e._totalTime, !0), e = e._timeline
                        }
                        this._gc && this._enabled(!0, !1), this._totalTime === a && 0 !== this._duration || (I.length && X(), this.render(a, b, !1), I.length && //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.
                            X())
                    }
                    return this
                }, f.progress = f.totalProgress = function(a, b) {
                    var c = this.duration();
                    return arguments.length ? this.totalTime(c * a, b) : c ? this._time / c : this.ratio
                }, f.startTime = function(a) {
                    return arguments.length ? (a !== this._startTime && (this._startTime = a, this.timeline && this.timeline._sortChildren && this.timeline.add(this, a - this._delay)), this) : this._startTime
                }, f.endTime = function(a) {
                    return this._startTime + (0 != a ? this.totalDuration() : this.duration()) / this._timeScale
                }, f.timeScale = function(a) {
                    if (!arguments.length) return this._timeScale; //can't allow zero because it'll throw the math off
                    if (a = a || k, this._timeline && this._timeline.smoothChildTiming) {
                        var b = this._pauseTime,
                            c = b || 0 === b ? b : this._timeline.totalTime();
                        this._startTime = c - (c - this._startTime) * this._timeScale / a
                    }
                    return this._timeScale = a, this._uncache(!1)
                }, f.reversed = function(a) {
                    return arguments.length ? (a != this._reversed && (this._reversed = a, this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, !0)), this) : this._reversed
                }, f.paused = function(a) {
                    if (!arguments.length) return this._paused;
                    var b, c, d = this._timeline;
                    return a != this._paused && d && (h || a || g.wake(), b = d.rawTime(), c = b - this._pauseTime, !a && d.smoothChildTiming && (this._startTime += c, this._uncache(!1)), this._pauseTime = a ? b : null, this._paused = a, this._active = this.isActive(), !a && 0 !== c && this._initted && this.duration() && (b = d.smoothChildTiming ? this._totalTime : (b - this._startTime) / this._timeScale, this.render(b, b === this._totalTime, !0))), this._gc && !a && this._enabled(!0, !1), this
                };
            /*
             * ----------------------------------------------------------------
             * SimpleTimeline
             * ----------------------------------------------------------------
             */
            var E = r("core.SimpleTimeline", function(a) {
                C.call(this, 0, a), this.autoRemoveChildren = this.smoothChildTiming = !0
            });
            f = E.prototype = new C, f.constructor = E, f.kill()._gc = !1, f._first = f._last = f._recent = null, f._sortChildren = !1, f.add = f.insert = function(a, b, c, d) {
                var e, f;
                if (a._startTime = Number(b || 0) + a._delay, a._paused && this !== a._timeline && ( //we only adjust the _pauseTime if it wasn't in this timeline already. Remember, sometimes a tween will be inserted again into the same timeline when its startTime is changed so that the tweens in the TimelineLite/Max are re-ordered properly in the linked list (so everything renders in the proper order).
                        a._pauseTime = a._startTime + (this.rawTime() - a._startTime) / a._timeScale), a.timeline && a.timeline._remove(a, !0), a.timeline = a._timeline = this, a._gc && a._enabled(!0, !0), e = this._last, this._sortChildren)
                    for (f = a._startTime; e && e._startTime > f;) e = e._prev;
                return e ? (a._next = e._next, e._next = a) : (a._next = this._first, this._first = a), a._next ? a._next._prev = a : this._last = a, a._prev = e, this._recent = a, this._timeline && this._uncache(!0), this
            }, f._remove = function(a, b) {
                return a.timeline === this && (b || a._enabled(!1, !0), a._prev ? a._prev._next = a._next : this._first === a && (this._first = a._next), a._next ? a._next._prev = a._prev : this._last === a && (this._last = a._prev), a._next = a._prev = a.timeline = null, a === this._recent && (this._recent = this._last), this._timeline && this._uncache(!0)), this
            }, f.render = function(a, b, c) {
                var d, e = this._first;
                for (this._totalTime = this._time = this._rawPrevTime = a; e;) d = e._next, (e._active || a >= e._startTime && !e._paused) && (e._reversed ? e.render((e._dirty ? e.totalDuration() : e._totalDuration) - (a - e._startTime) * e._timeScale, b, c) : e.render((a - e._startTime) * e._timeScale, b, c)), e = d
            }, f.rawTime = function() {
                return h || g.wake(), this._totalTime
            };
            /*
             * ----------------------------------------------------------------
             * TweenLite
             * ----------------------------------------------------------------
             */
            var F = r("TweenLite", function(b, c, d) { //speed optimization (avoid prototype lookup on this "hot" method)
                    if (C.call(this, c, d), this.render = F.prototype.render, null == b) throw "Cannot tween a null target.";
                    this.target = b = "string" != typeof b ? b : F.selector(b) || b;
                    var e, f, g, h = b.jquery || b.length && b !== a && b[0] && (b[0] === a || b[0].nodeType && b[0].style && !b.nodeType),
                        i = this.vars.overwrite;
                    if (this._overwrite = i = null == i ? T[F.defaultOverwrite] : "number" == typeof i ? i >> 0 : T[i], (h || b instanceof Array || b.push && n(b)) && "number" != typeof b[0])
                        for (this._targets = g = l(b), //don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
                            this._propLookup = [], this._siblings = [], e = 0; e < g.length; e++) f = g[e], f ? "string" != typeof f ? f.length && f !== a && f[0] && (f[0] === a || f[0].nodeType && f[0].style && !f.nodeType) ? (g.splice(e--, 1), this._targets = g = g.concat(l(f))) : (this._siblings[e] = Y(f, this, !1), 1 === i && this._siblings[e].length > 1 && $(f, this, null, 1, this._siblings[e])) : (f = g[e--] = F.selector(f), "string" == typeof f && g.splice(e + 1, 1)) : g.splice(e--, 1);
                    else this._propLookup = {}, this._siblings = Y(b, this, !1), 1 === i && this._siblings.length > 1 && $(b, this, null, 1, this._siblings);
                    (this.vars.immediateRender || 0 === c && 0 === this._delay && this.vars.immediateRender !== !1) && (this._time = -k, //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)
                        this.render(Math.min(0, -this._delay)))
                }, !0),
                G = function(b) {
                    return b && b.length && b !== a && b[0] && (b[0] === a || b[0].nodeType && b[0].style && !b.nodeType)
                },
                H = function(a, b) {
                    var c, d = {};
                    for (c in a) S[c] || c in b && "transform" !== c && "x" !== c && "y" !== c && "width" !== c && "height" !== c && "className" !== c && "border" !== c || !(!P[c] || P[c] && P[c]._autoCSS) || ( //note: <img> elements contain read-only "x" and "y" properties. We should also prioritize editing css width/height rather than the element's properties.
                        d[c] = a[c], delete a[c]);
                    a.css = d
                };
            f = F.prototype = new C, f.constructor = F, f.kill()._gc = !1,
                //----TweenLite defaults, overwrite management, and root updates ----------------------------------------------------
                f.ratio = 0, f._firstPT = f._targets = f._overwrittenProps = f._startAt = null, f._notifyPluginsOfEnabled = f._lazy = !1, F.version = "1.18.4", F.defaultEase = f._ease = new u(null, null, 1, 1), F.defaultOverwrite = "auto", F.ticker = g, F.autoSleep = 120, F.lagSmoothing = function(a, b) {
                    g.lagSmoothing(a, b)
                }, F.selector = a.$ || a.jQuery || function(b) {
                    var c = a.$ || a.jQuery;
                    return c ? (F.selector = c, c(b)) : "undefined" == typeof document ? b : document.querySelectorAll ? document.querySelectorAll(b) : document.getElementById("#" === b.charAt(0) ? b.substr(1) : b)
                };
            var I = [],
                J = {},
                K = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
                //_nonNumbersExp = /(?:([\-+](?!(\d|=)))|[^\d\-+=e]|(e(?![\-+][\d])))+/ig,
                L = function(a) {
                    for (var b, c = this._firstPT, d = 1e-6; c;) b = c.blob ? a ? this.join("") : this.start : c.c * a + c.s, c.r ? b = Math.round(b) : d > b && b > -d && (b = 0), c.f ? c.fp ? c.t[c.p](c.fp, b) : c.t[c.p](b) : c.t[c.p] = b, c = c._next
                },
                //compares two strings (start/end), finds the numbers that are different and spits back an array representing the whole value but with the changing values isolated as elements. For example, "rgb(0,0,0)" and "rgb(100,50,0)" would become ["rgb(", 0, ",", 50, ",0)"]. Notice it merges the parts that are identical (performance optimization). The array also has a linked list of PropTweens attached starting with _firstPT that contain the tweening data (t, p, s, c, f, etc.). It also stores the starting value as a "start" property so that we can revert to it if/when necessary, like when a tween rewinds fully. If the quantity of numbers differs between the start and end, it will always prioritize the end value(s). The pt parameter is optional - it's for a PropTween that will be appended to the end of the linked list and is typically for actually setting the value after all of the elements have been updated (with array.join("")).
                M = function(a, b, c, d) {
                    var e, f, g, h, i, j, k, l = [a, b],
                        m = 0,
                        n = "",
                        o = 0;
                    for (l.start = a, c && (c(l), a = l[0], b = l[1]), l.length = 0, e = a.match(K) || [], f = b.match(K) || [], d && (d._next = null, d.blob = 1, l._firstPT = d), i = f.length, h = 0; i > h; h++) k = f[h], j = b.substr(m, b.indexOf(k, m) - m), n += j || !h ? j : ",", m += j.length, o ? o = (o + 1) % 5 : "rgba(" === j.substr(-5) && (o = 1), k === e[h] || e.length <= h ? n += k : (n && (l.push(n), n = ""), g = parseFloat(e[h]), l.push(g), l._firstPT = {
                        _next: l._firstPT,
                        t: l,
                        p: l.length - 1,
                        s: g,
                        c: ("=" === k.charAt(1) ? parseInt(k.charAt(0) + "1", 10) * parseFloat(k.substr(2)) : parseFloat(k) - g) || 0,
                        f: 0,
                        r: o && 4 > o
                    }), m += k.length;
                    return n += b.substr(m), n && l.push(n), l.setRatio = L, l
                },
                //note: "funcParam" is only necessary for function-based getters/setters that require an extra parameter like getAttribute("width") and setAttribute("width", value). In this example, funcParam would be "width". Used by AttrPlugin for example.
                N = function(a, b, c, d, e, f, g, h) {
                    var i, j, k = "get" === c ? a[b] : c,
                        l = typeof a[b],
                        m = "string" == typeof d && "=" === d.charAt(1),
                        n = {
                            t: a,
                            p: b,
                            s: k,
                            f: "function" === l,
                            pg: 0,
                            n: e || b,
                            r: f,
                            pr: 0,
                            c: m ? parseInt(d.charAt(0) + "1", 10) * parseFloat(d.substr(2)) : parseFloat(d) - k || 0
                        };
                    //a blob (string that has multiple numbers in it)
                    //only add it to the linked list if there's a change.
                    return "number" !== l && ("function" === l && "get" === c && (j = b.indexOf("set") || "function" != typeof a["get" + b.substr(3)] ? b : "get" + b.substr(3), n.s = k = g ? a[j](g) : a[j]()), "string" == typeof k && (g || isNaN(k)) ? (n.fp = g, i = M(k, d, h || F.defaultStringFilter, n), n = {
                        t: i,
                        p: "setRatio",
                        s: 0,
                        c: 1,
                        f: 2,
                        pg: 0,
                        n: e || b,
                        pr: 0
                    }) : m || (n.s = parseFloat(k), n.c = parseFloat(d) - n.s || 0)), n.c ? ((n._next = this._firstPT) && (n._next._prev = n), this._firstPT = n, n) : void 0
                },
                O = F._internals = {
                    isArray: n,
                    isSelector: G,
                    lazyTweens: I,
                    blobDif: M
                }, //gives us a way to expose certain private values to other GreenSock classes without contaminating tha main TweenLite object.
                P = F._plugins = {},
                Q = O.tweenLookup = {},
                R = 0,
                S = O.reservedProps = {
                    ease: 1,
                    delay: 1,
                    overwrite: 1,
                    onComplete: 1,
                    onCompleteParams: 1,
                    onCompleteScope: 1,
                    useFrames: 1,
                    runBackwards: 1,
                    startAt: 1,
                    onUpdate: 1,
                    onUpdateParams: 1,
                    onUpdateScope: 1,
                    onStart: 1,
                    onStartParams: 1,
                    onStartScope: 1,
                    onReverseComplete: 1,
                    onReverseCompleteParams: 1,
                    onReverseCompleteScope: 1,
                    onRepeat: 1,
                    onRepeatParams: 1,
                    onRepeatScope: 1,
                    easeParams: 1,
                    yoyo: 1,
                    immediateRender: 1,
                    repeat: 1,
                    repeatDelay: 1,
                    data: 1,
                    paused: 1,
                    reversed: 1,
                    autoCSS: 1,
                    lazy: 1,
                    onOverwrite: 1,
                    callbackScope: 1,
                    stringFilter: 1
                },
                T = {
                    none: 0,
                    all: 1,
                    auto: 2,
                    concurrent: 3,
                    allOnStart: 4,
                    preexisting: 5,
                    "true": 1,
                    "false": 0
                },
                U = C._rootFramesTimeline = new E,
                V = C._rootTimeline = new E,
                W = 30,
                X = O.lazyRender = function() {
                    var a, b = I.length;
                    for (J = {}; --b > -1;) a = I[b], a && a._lazy !== !1 && (a.render(a._lazy[0], a._lazy[1], !0), a._lazy = !1);
                    I.length = 0
                };
            V._startTime = g.time, U._startTime = g.frame, V._active = U._active = !0, setTimeout(X, 1), //on some mobile devices, there isn't a "tick" before code runs which means any lazy renders wouldn't run before the next official "tick".
                C._updateRoot = F.render = function() {
                    var a, b, c;
                    if (I.length && //if code is run outside of the requestAnimationFrame loop, there may be tweens queued AFTER the engine refreshed, so we need to ensure any pending renders occur before we refresh again.
                        X(), V.render((g.time - V._startTime) * V._timeScale, !1, !1), U.render((g.frame - U._startTime) * U._timeScale, !1, !1), I.length && X(), g.frame >= W) { //dump garbage every 120 frames or whatever the user sets TweenLite.autoSleep to
                        W = g.frame + (parseInt(F.autoSleep, 10) || 120);
                        for (c in Q) {
                            for (b = Q[c].tweens, a = b.length; --a > -1;) b[a]._gc && b.splice(a, 1);
                            0 === b.length && delete Q[c]
                        }
                        if (c = V._first, (!c || c._paused) && F.autoSleep && !U._first && 1 === g._listeners.tick.length) {
                            for (; c && c._paused;) c = c._next;
                            c || g.sleep()
                        }
                    }
                }, g.addEventListener("tick", C._updateRoot);
            var Y = function(a, b, c) {
                    var d, e, f = a._gsTweenID;
                    if (Q[f || (a._gsTweenID = f = "t" + R++)] || (Q[f] = {
                            target: a,
                            tweens: []
                        }), b && (d = Q[f].tweens, d[e = d.length] = b, c))
                        for (; --e > -1;) d[e] === b && d.splice(e, 1);
                    return Q[f].tweens
                },
                Z = function(a, b, c, d) {
                    var e, f, g = a.vars.onOverwrite;
                    return g && (e = g(a, b, c, d)), g = F.onOverwrite, g && (f = g(a, b, c, d)), e !== !1 && f !== !1
                },
                $ = function(a, b, c, d, e) {
                    var f, g, h, i;
                    if (1 === d || d >= 4) {
                        for (i = e.length, f = 0; i > f; f++)
                            if ((h = e[f]) !== b) h._gc || h._kill(null, a, b) && (g = !0);
                            else if (5 === d) break;
                        return g
                    }
                    //NOTE: Add 0.0000000001 to overcome floating point errors that can cause the startTime to be VERY slightly off (when a tween's time() is set for example)
                    var j, l = b._startTime + k,
                        m = [],
                        n = 0,
                        o = 0 === b._duration;
                    for (f = e.length; --f > -1;)(h = e[f]) === b || h._gc || h._paused || (h._timeline !== b._timeline ? (j = j || _(b, 0, o), 0 === _(h, j, o) && (m[n++] = h)) : h._startTime <= l && h._startTime + h.totalDuration() / h._timeScale > l && ((o || !h._initted) && l - h._startTime <= 2e-10 || (m[n++] = h)));
                    for (f = n; --f > -1;)
                        if (h = m[f], 2 === d && h._kill(c, a, b) && (g = !0), 2 !== d || !h._firstPT && h._initted) {
                            if (2 !== d && !Z(h, b)) continue;
                            h._enabled(!1, !1) && ( //if all property tweens have been overwritten, kill the tween.
                                g = !0)
                        }
                    return g
                },
                _ = function(a, b, c) {
                    for (var d = a._timeline, e = d._timeScale, f = a._startTime; d._timeline;) {
                        if (f += d._startTime, e *= d._timeScale, d._paused) return -100;
                        d = d._timeline
                    }
                    return f /= e, f > b ? f - b : c && f === b || !a._initted && 2 * k > f - b ? k : (f += a.totalDuration() / a._timeScale / e) > b + k ? 0 : f - b - k
                };
            //---- TweenLite instance methods -----------------------------------------------------------------------------
            f._init = function() {
                    var a, b, c, d, e, f = this.vars,
                        g = this._overwrittenProps,
                        h = this._duration,
                        i = !!f.immediateRender,
                        j = f.ease;
                    if (f.startAt) {
                        this._startAt && (this._startAt.render(-1, !0), //if we've run a startAt previously (when the tween instantiated), we should revert it so that the values re-instantiate correctly particularly for relative tweens. Without this, a TweenLite.fromTo(obj, 1, {x:"+=100"}, {x:"-=100"}), for example, would actually jump to +=200 because the startAt would run twice, doubling the relative change.
                            this._startAt.kill()), e = {};
                        for (d in f.startAt) //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, 1, from, to).fromTo(e, 1, to, from);
                            e[d] = f.startAt[d];
                        if (e.overwrite = !1, e.immediateRender = !0, e.lazy = i && f.lazy !== !1, e.startAt = e.delay = null, //no nesting of startAt objects allowed (otherwise it could cause an infinite loop).
                            this._startAt = F.to(this.target, 0, e), i)
                            if (this._time > 0) this._startAt = null;
                            else if (0 !== h) return
                    } else if (f.runBackwards && 0 !== h)
                    //from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)
                        if (this._startAt) this._startAt.render(-1, !0), this._startAt.kill(), this._startAt = null;
                        else {
                            0 !== this._time && (i = !1), c = {};
                            for (d in f) //copy props into a new object and skip any reserved props, otherwise onComplete or onUpdate or onStart could fire. We should, however, permit autoCSS to go through.
                                S[d] && "autoCSS" !== d || (c[d] = f[d]);
                            if (c.overwrite = 0, c.data = "isFromStart", //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
                                c.lazy = i && f.lazy !== !1, c.immediateRender = i, //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
                                this._startAt = F.to(this.target, 0, c), i) {
                                if (0 === this._time) return
                            } else this._startAt._init(), //ensures that the initial values are recorded
                                this._startAt._enabled(!1), //no need to have the tween render on the next cycle. Disable it because we'll always manually control the renders of the _startAt tween.
                                this.vars.immediateRender && (this._startAt = null)
                        }
                    if (this._ease = j = j ? j instanceof u ? j : "function" == typeof j ? new u(j, f.easeParams) : v[j] || F.defaultEase : F.defaultEase, f.easeParams instanceof Array && j.config && (this._ease = j.config.apply(j, f.easeParams)), this._easeType = this._ease._type, this._easePower = this._ease._power, this._firstPT = null, this._targets)
                        for (a = this._targets.length; --a > -1;) this._initProps(this._targets[a], this._propLookup[a] = {}, this._siblings[a], g ? g[a] : null) && (b = !0);
                    else b = this._initProps(this.target, this._propLookup, this._siblings, g);
                    if (b && F._onPluginEvent("_onInitAllProps", this), g && (this._firstPT || "function" != typeof this.target && //if all tweening properties have been overwritten, kill the tween. If the target is a function, it's probably a delayedCall so let it live.
                            this._enabled(!1, !1)), f.runBackwards)
                        for (c = this._firstPT; c;) c.s += c.c, c.c = -c.c, c = c._next;
                    this._onUpdate = f.onUpdate, this._initted = !0
                }, f._initProps = function(b, c, d, e) {
                    var f, g, h, i, j, k;
                    if (null == b) return !1;
                    J[b._gsTweenID] && X(), this.vars.css || b.style && b !== a && b.nodeType && P.css && this.vars.autoCSS !== !1 && //it's so common to use TweenLite/Max to animate the css of DOM elements, we assume that if the target is a DOM element, that's what is intended (a convenience so that users don't have to wrap things in css:{}, although we still recommend it for a slight performance boost and better specificity). Note: we cannot check "nodeType" on the window inside an iframe.
                        H(this.vars, b);
                    for (f in this.vars)
                        if (k = this.vars[f], S[f]) k && (k instanceof Array || k.push && n(k)) && -1 !== k.join("").indexOf("{self}") && (this.vars[f] = k = this._swapSelfInParams(k, this));
                        else if (P[f] && (i = new P[f])._onInitTween(b, this.vars[f], this)) {
                        for (
                            //t - target 		[object]
                            //p - property 		[string]
                            //s - start			[number]
                            //c - change		[number]
                            //f - isFunction	[boolean]
                            //n - name			[string]
                            //pg - isPlugin 	[boolean]
                            //pr - priority		[number]
                            this._firstPT = j = {
                                _next: this._firstPT,
                                t: i,
                                p: "setRatio",
                                s: 0,
                                c: 1,
                                f: 1,
                                n: f,
                                pg: 1,
                                pr: i._priority
                            }, g = i._overwriteProps.length; --g > -1;) c[i._overwriteProps[g]] = this._firstPT;
                        (i._priority || i._onInitAllProps) && (h = !0), (i._onDisable || i._onEnable) && (this._notifyPluginsOfEnabled = !0), j._next && (j._next._prev = j)
                    } else c[f] = N.call(this, b, f, "get", k, f, 0, null, this.vars.stringFilter); //zero duration tweens don't lazy render by default; everything else does.
                    return e && this._kill(e, b) ? this._initProps(b, c, d, e) : this._overwrite > 1 && this._firstPT && d.length > 1 && $(b, this, c, this._overwrite, d) ? (this._kill(c, b), this._initProps(b, c, d, e)) : (this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration) && (J[b._gsTweenID] = !0), h)
                }, f.render = function(a, b, c) {
                    var d, e, f, g, h = this._time,
                        i = this._duration,
                        j = this._rawPrevTime;
                    if (a >= i - 1e-7) //to work around occasional floating point math artifacts.
                        this._totalTime = this._time = i, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1, this._reversed || (d = !0, e = "onComplete", c = c || this._timeline.autoRemoveChildren), 0 === i && (this._initted || !this.vars.lazy || c) && ( //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
                        this._startTime === this._timeline._duration && ( //if a zero-duration tween is at the VERY end of a timeline and that timeline renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete even though technically the playhead didn't pass over it again. It's a very specific edge case we must accommodate.
                            a = 0), (0 > j || 0 >= a && a >= -1e-7 || j === k && "isPause" !== this.data) && j !== a && (c = !0, j > k && (e = "onReverseComplete")), this._rawPrevTime = g = !b || a || j === a ? a : k);
                    else if (1e-7 > a) //to work around occasional floating point math artifacts, round super small values to 0.
                        this._totalTime = this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== h || 0 === i && j > 0) && (e = "onReverseComplete", d = this._reversed), 0 > a && (this._active = !1, 0 === i && (this._initted || !this.vars.lazy || c) && (j >= 0 && (j !== k || "isPause" !== this.data) && (c = !0), this._rawPrevTime = g = !b || a || j === a ? a : k)), this._initted || ( //if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
                        c = !0);
                    else if (this._totalTime = this._time = a, this._easeType) {
                        var l = a / i,
                            m = this._easeType,
                            n = this._easePower;
                        (1 === m || 3 === m && l >= .5) && (l = 1 - l), 3 === m && (l *= 2), 1 === n ? l *= l : 2 === n ? l *= l * l : 3 === n ? l *= l * l * l : 4 === n && (l *= l * l * l * l), 1 === m ? this.ratio = 1 - l : 2 === m ? this.ratio = l : .5 > a / i ? this.ratio = l / 2 : this.ratio = 1 - l / 2
                    } else this.ratio = this._ease.getRatio(a / i);
                    if (this._time !== h || c) {
                        if (!this._initted) {
                            if (this._init(), !this._initted || this._gc) //immediateRender tweens typically won't initialize until the playhead advances (_time is greater than 0) in order to ensure that overwriting occurs properly. Also, if all of the tweening properties have been overwritten (which would cause _gc to be true, as set in _init()), we shouldn't continue otherwise an onStart callback could be called for example.
                                return;
                            if (!c && this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration)) return this._time = this._totalTime = h, this._rawPrevTime = j, I.push(this), void(this._lazy = [a, b]);
                            //_ease is initially set to defaultEase, so now that init() has run, _ease is set properly and we need to recalculate the ratio. Overall this is faster than using conditional logic earlier in the method to avoid having to set ratio twice because we only init() once but renderTime() gets called VERY frequently.
                            this._time && !d ? this.ratio = this._ease.getRatio(this._time / i) : d && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1))
                        }
                        for (this._lazy !== !1 && (this._lazy = !1), this._active || !this._paused && this._time !== h && a >= 0 && (this._active = !0), 0 === h && (this._startAt && (a >= 0 ? this._startAt.render(a, b, c) : e || (e = "_dummyGS")), this.vars.onStart && (0 === this._time && 0 !== i || b || this._callback("onStart"))), f = this._firstPT; f;) f.f ? f.t[f.p](f.c * this.ratio + f.s) : f.t[f.p] = f.c * this.ratio + f.s, f = f._next;
                        this._onUpdate && (0 > a && this._startAt && a !== -1e-4 && //if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
                            this._startAt.render(a, b, c), b || (this._time !== h || d || c) && this._callback("onUpdate")), e && (this._gc && !c || ( //check _gc because there's a chance that kill() could be called in an onUpdate
                            0 > a && this._startAt && !this._onUpdate && a !== -1e-4 && //-0.0001 is a special value that we use when looping back to the beginning of a repeated TimelineMax, in which case we shouldn't render the _startAt values.
                            this._startAt.render(a, b, c), d && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !b && this.vars[e] && this._callback(e), 0 === i && this._rawPrevTime === k && g !== k && ( //the onComplete or onReverseComplete could trigger movement of the playhead and for zero-duration tweens (which must discern direction) that land directly back on their start time, we don't want to fire again on the next render. Think of several addPause()'s in a timeline that forces the playhead to a certain spot, but what if it's already paused and another tween is tweening the "time" of the timeline? Each time it moves [forward] past that spot, it would move back, and since suppressEvents is true, it'd reset _rawPrevTime to _tinyNum so that when it begins again, the callback would fire (so ultimately it could bounce back and forth during that tween). Again, this is a very uncommon scenario, but possible nonetheless.
                                this._rawPrevTime = 0)))
                    }
                }, f._kill = function(a, b, c) {
                    if ("all" === a && (a = null), null == a && (null == b || b === this.target)) return this._lazy = !1, this._enabled(!1, !1);
                    b = "string" != typeof b ? b || this._targets || this.target : F.selector(b) || b;
                    var d, e, f, g, h, i, j, k, l, m = c && this._time && c._startTime === this._startTime && this._timeline === c._timeline;
                    if ((n(b) || G(b)) && "number" != typeof b[0])
                        for (d = b.length; --d > -1;) this._kill(a, b[d], c) && (i = !0);
                    else {
                        if (this._targets) {
                            for (d = this._targets.length; --d > -1;)
                                if (b === this._targets[d]) {
                                    h = this._propLookup[d] || {}, this._overwrittenProps = this._overwrittenProps || [], e = this._overwrittenProps[d] = a ? this._overwrittenProps[d] || {} : "all";
                                    break
                                }
                        } else {
                            if (b !== this.target) return !1;
                            h = this._propLookup, e = this._overwrittenProps = a ? this._overwrittenProps || {} : "all"
                        }
                        if (h) { //_tempKill is a super-secret way to delete a particular tweening property but NOT have it remembered as an official overwritten property (like in BezierPlugin)
                            if (j = a || h, k = a !== e && "all" !== e && a !== h && ("object" != typeof a || !a._tempKill), c && (F.onOverwrite || this.vars.onOverwrite)) {
                                for (f in j) h[f] && (l || (l = []), l.push(f));
                                if ((l || !a) && !Z(this, c, b, l)) //if the onOverwrite returned false, that means the user wants to override the overwriting (cancel it).
                                    return !1
                            }
                            for (f in j)(g = h[f]) && (m && ( //if another tween overwrites this one and they both start at exactly the same time, yet this tween has already rendered once (for example, at 0.001) because it's first in the queue, we should revert the values to where they were at 0 so that the starting values aren't contaminated on the overwriting tween.
                                g.f ? g.t[g.p](g.s) : g.t[g.p] = g.s, i = !0), g.pg && g.t._kill(j) && (i = !0), g.pg && 0 !== g.t._overwriteProps.length || (g._prev ? g._prev._next = g._next : g === this._firstPT && (this._firstPT = g._next), g._next && (g._next._prev = g._prev), g._next = g._prev = null), delete h[f]), k && (e[f] = 1);
                            !this._firstPT && this._initted && //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.
                                this._enabled(!1, !1)
                        }
                    }
                    return i
                }, f.invalidate = function() { //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)
                    return this._notifyPluginsOfEnabled && F._onPluginEvent("_onDisable", this), this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null, this._notifyPluginsOfEnabled = this._active = this._lazy = !1, this._propLookup = this._targets ? {} : [], C.prototype.invalidate.call(this), this.vars.immediateRender && (this._time = -k, this.render(Math.min(0, -this._delay))), this
                }, f._enabled = function(a, b) {
                    if (h || g.wake(), a && this._gc) {
                        var c, d = this._targets;
                        if (d)
                            for (c = d.length; --c > -1;) this._siblings[c] = Y(d[c], this, !0);
                        else this._siblings = Y(this.target, this, !0)
                    }
                    return C.prototype._enabled.call(this, a, b), this._notifyPluginsOfEnabled && this._firstPT ? F._onPluginEvent(a ? "_onEnable" : "_onDisable", this) : !1
                },
                //----TweenLite static methods -----------------------------------------------------
                F.to = function(a, b, c) {
                    return new F(a, b, c)
                }, F.from = function(a, b, c) {
                    return c.runBackwards = !0, c.immediateRender = 0 != c.immediateRender, new F(a, b, c)
                }, F.fromTo = function(a, b, c, d) {
                    return d.startAt = c, d.immediateRender = 0 != d.immediateRender && 0 != c.immediateRender, new F(a, b, d)
                }, F.delayedCall = function(a, b, c, d, e) {
                    return new F(b, 0, {
                        delay: a,
                        onComplete: b,
                        onCompleteParams: c,
                        callbackScope: d,
                        onReverseComplete: b,
                        onReverseCompleteParams: c,
                        immediateRender: !1,
                        lazy: !1,
                        useFrames: e,
                        overwrite: 0
                    })
                }, F.set = function(a, b) {
                    return new F(a, 0, b)
                }, F.getTweensOf = function(a, b) {
                    if (null == a) return [];
                    a = "string" != typeof a ? a : F.selector(a) || a;
                    var c, d, e, f;
                    if ((n(a) || G(a)) && "number" != typeof a[0]) {
                        for (c = a.length, d = []; --c > -1;) d = d.concat(F.getTweensOf(a[c], b));
                        //now get rid of any duplicates (tweens of arrays of objects could cause duplicates)
                        for (c = d.length; --c > -1;)
                            for (f = d[c], e = c; --e > -1;) f === d[e] && d.splice(c, 1)
                    } else
                        for (d = Y(a).concat(), c = d.length; --c > -1;)(d[c]._gc || b && !d[c].isActive()) && d.splice(c, 1);
                    return d
                }, F.killTweensOf = F.killDelayedCallsTo = function(a, b, c) {
                    "object" == typeof b && (c = b, b = !1);
                    for (var d = F.getTweensOf(a, b), e = d.length; --e > -1;) d[e]._kill(c, a)
                };
            /*
             * ----------------------------------------------------------------
             * TweenPlugin   (could easily be split out as a separate file/class, but included for ease of use (so that people don't need to include another script call before loading plugins which is easy to forget)
             * ----------------------------------------------------------------
             */
            var aa = r("plugins.TweenPlugin", function(a, b) {
                this._overwriteProps = (a || "").split(","), this._propName = this._overwriteProps[0], this._priority = b || 0, this._super = aa.prototype
            }, !0);
            if (f = aa.prototype, aa.version = "1.18.0", aa.API = 2, f._firstPT = null, f._addTween = N, f.setRatio = L, f._kill = function(a) {
                    var b, c = this._overwriteProps,
                        d = this._firstPT;
                    if (null != a[this._propName]) this._overwriteProps = [];
                    else
                        for (b = c.length; --b > -1;) null != a[c[b]] && c.splice(b, 1);
                    for (; d;) null != a[d.n] && (d._next && (d._next._prev = d._prev), d._prev ? (d._prev._next = d._next, d._prev = null) : this._firstPT === d && (this._firstPT = d._next)), d = d._next;
                    return !1
                }, f._roundProps = function(a, b) {
                    for (var c = this._firstPT; c;)(a[this._propName] || null != c.n && a[c.n.split(this._propName + "_").join("")]) && (c.r = b), c = c._next
                }, F._onPluginEvent = function(a, b) {
                    var c, d, e, f, g, h = b._firstPT;
                    if ("_onInitAllProps" === a) {
                        for (; h;) {
                            for (g = h._next, d = e; d && d.pr > h.pr;) d = d._next;
                            (h._prev = d ? d._prev : f) ? h._prev._next = h: e = h, (h._next = d) ? d._prev = h : f = h, h = g
                        }
                        h = b._firstPT = e
                    }
                    for (; h;) h.pg && "function" == typeof h.t[a] && h.t[a]() && (c = !0), h = h._next;
                    return c
                }, aa.activate = function(a) {
                    for (var b = a.length; --b > -1;) a[b].API === aa.API && (P[(new a[b])._propName] = a[b]);
                    return !0
                }, q.plugin = function(a) {
                    if (!(a && a.propName && a.init && a.API)) throw "illegal plugin definition.";
                    var b, c = a.propName,
                        d = a.priority || 0,
                        e = a.overwriteProps,
                        f = {
                            init: "_onInitTween",
                            set: "setRatio",
                            kill: "_kill",
                            round: "_roundProps",
                            initAll: "_onInitAllProps"
                        },
                        g = r("plugins." + c.charAt(0).toUpperCase() + c.substr(1) + "Plugin", function() {
                            aa.call(this, c, d), this._overwriteProps = e || []
                        }, a.global === !0),
                        h = g.prototype = new aa(c);
                    h.constructor = g, g.API = a.API;
                    for (b in f) "function" == typeof a[b] && (h[f[b]] = a[b]);
                    return g.version = a.version, aa.activate([g]), g
                }, d = a._gsQueue) {
                for (e = 0; e < d.length; e++) d[e]();
                for (f in o) o[f].func || a.console.log("GSAP encountered missing dependency: com.greensock." + f)
            }
            h = !1
        }
    }("undefined" != typeof module && module.exports && "undefined" != typeof global ? global : this || window, "TweenLite"),
    function(a, b, c) {
        "use strict";
        /* PLUGIN DEFINITION
         * ========================= */
        a.fn.backstretch = function(d, f) {
                // We need at least one image or method name
                /*
                 * Scroll the page one pixel to get the right window height on iOS
                 * Pretty harmless for everyone else
                 */
                return d !== c && 0 !== d.length || a.error("No images were supplied for Backstretch"), 0 === a(b).scrollTop() && b.scrollTo(0, 0), this.each(function() {
                    var b = a(this),
                        c = b.data("backstretch");
                    // Do we already have an instance attached to this element?
                    if (c) {
                        // Is this a method they're trying to execute?
                        if ("string" == typeof d && "function" == typeof c[d])
                        // No need to do anything further
                        // Call the method
                            return void c[d](f);
                        // Merge the old options with the new
                        f = a.extend(c.options, f),
                            // Remove the old instance
                            c.destroy(!0)
                    }
                    c = new e(this, d, f), b.data("backstretch", c)
                })
            },
            // If no element is supplied, we'll attach to body
            a.backstretch = function(b, c) {
                // Return the instance
                return a("body").backstretch(b, c).data("backstretch")
            },
            // Custom selector
            a.expr[":"].backstretch = function(b) {
                return a(b).data("backstretch") !== c
            },
            /* DEFAULTS
             * ========================= */
            a.fn.backstretch.defaults = {
                centeredX: !0,
                centeredY: !0,
                duration: 5e3,
                fade: 0
            };
        /* STYLES
         * 
         * Baked-in styles that we'll apply to our elements.
         * In an effort to keep the plugin simple, these are not exposed as options.
         * That said, anyone can override these in their own stylesheet.
         * ========================= */
        var d = {
                wrap: {
                    left: 0,
                    top: 0,
                    overflow: "hidden",
                    margin: 0,
                    padding: 0,
                    height: "100%",
                    width: "100%",
                    zIndex: -999999
                },
                img: {
                    position: "absolute",
                    display: "none",
                    margin: 0,
                    padding: 0,
                    border: "none",
                    width: "auto",
                    height: "auto",
                    maxHeight: "none",
                    maxWidth: "none",
                    zIndex: -999999
                }
            },
            e = function(c, e, g) {
                this.options = a.extend({}, a.fn.backstretch.defaults, g || {}),
                    /* In its simplest form, we allow Backstretch to be called on an image path.
                     * e.g. $.backstretch('/path/to/image.jpg')
                     * So, we need to turn this back into an array.
                     */
                    this.images = a.isArray(e) ? e : [e],
                    // Preload images
                    a.each(this.images, function() {
                        a("<img />")[0].src = this
                    }),
                    // Convenience reference to know if the container is body.
                    this.isBody = c === document.body,
                    /* We're keeping track of a few different elements
                     *
                     * Container: the element that Backstretch was called on.
                     * Wrap: a DIV that we place the image into, so we can hide the overflow.
                     * Root: Convenience reference to help calculate the correct height.
                     */
                    this.$container = a(c), this.$root = this.isBody ? a(f ? b : document) : this.$container;
                // Don't create a new wrap if one already exists (from a previous instance of Backstretch)
                var h = this.$container.children(".backstretch").first();
                // Non-body elements need some style adjustments
                if (this.$wrap = h.length ? h : a('<div class="backstretch"></div>').css(d.wrap).appendTo(this.$container), !this.isBody) {
                    // If the container is statically positioned, we need to make it relative,
                    // and if no zIndex is defined, we should set it to zero.
                    var i = this.$container.css("position"),
                        j = this.$container.css("zIndex");
                    this.$container.css({
                            position: "static" === i ? "relative" : i,
                            zIndex: "auto" === j ? 0 : j,
                            background: "none"
                        }),
                        // Needs a higher z-index
                        this.$wrap.css({
                            zIndex: -999998
                        })
                }
                // Fixed or absolute positioning?
                this.$wrap.css({
                        position: this.isBody && f ? "fixed" : "absolute"
                    }),
                    // Set the first image
                    this.index = 0, this.show(this.index),
                    // Listen for resize
                    a(b).on("resize.backstretch", a.proxy(this.resize, this)).on("orientationchange.backstretch", a.proxy(function() {
                        // Need to do this in order to get the right window height
                        this.isBody && 0 === b.pageYOffset && (b.scrollTo(0, 1), this.resize())
                    }, this))
            };
        /* PUBLIC METHODS
         * ========================= */
        e.prototype = {
            resize: function() {
                try {
                    var a, c = {
                            left: 0,
                            top: 0
                        },
                        d = this.isBody ? this.$root.width() : this.$root.innerWidth(),
                        e = d,
                        f = this.isBody ? b.innerHeight ? b.innerHeight : this.$root.height() : this.$root.innerHeight(),
                        g = e / this.$img.data("ratio");
                    // Make adjustments based on image ratio
                    g >= f ? (a = (g - f) / 2, this.options.centeredY && (c.top = "-" + a + "px")) : (g = f, e = g * this.$img.data("ratio"), a = (e - d) / 2, this.options.centeredX && (c.left = "-" + a + "px")), this.$wrap.css({
                        width: d,
                        height: f
                    }).find("img:not(.deleteable)").css({
                        width: e,
                        height: g
                    }).css(c)
                } catch (h) {}
                return this
            },
            show: function(b) {
                // Validate index
                if (!(Math.abs(b) > this.images.length - 1)) {
                    // Vars
                    var c = this,
                        e = c.$wrap.find("img").addClass("deleteable"),
                        f = {
                            relatedTarget: c.$container[0]
                        };
                    // Trigger the "before" event
                    // Set the new index
                    // Pause the slideshow
                    // New image
                    // Hack for IE img onload event
                    return c.$container.trigger(a.Event("backstretch.before", f), [c, b]), this.index = b, clearInterval(c.interval), c.$img = a("<img />").css(d.img).bind("load", function(d) {
                        var g = this.width || a(d.target).width(),
                            h = this.height || a(d.target).height();
                        // Save the ratio
                        a(this).data("ratio", g / h),
                            // Show the image, then delete the old one
                            // "speed" option has been deprecated, but we want backwards compatibilty
                            a(this).fadeIn(c.options.speed || c.options.fade, function() {
                                e.remove(),
                                    // Resume the slideshow
                                    c.paused || c.cycle(),
                                    // Trigger the "after" and "show" events
                                    // "show" is being deprecated
                                    a(["after", "show"]).each(function() {
                                        c.$container.trigger(a.Event("backstretch." + this, f), [c, b])
                                    })
                            }),
                            // Resize
                            c.resize()
                    }).appendTo(c.$wrap), c.$img.attr("src", c.images[b]), c
                }
            },
            next: function() {
                // Next slide
                return this.show(this.index < this.images.length - 1 ? this.index + 1 : 0)
            },
            prev: function() {
                // Previous slide
                return this.show(0 === this.index ? this.images.length - 1 : this.index - 1)
            },
            pause: function() {
                // Pause the slideshow
                return this.paused = !0, this
            },
            resume: function() {
                // Resume the slideshow
                return this.paused = !1, this.next(), this
            },
            cycle: function() {
                // Start/resume the slideshow
                // Clear the interval, just in case
                return this.images.length > 1 && (clearInterval(this.interval), this.interval = setInterval(a.proxy(function() {
                    // Check for paused slideshow
                    this.paused || this.next()
                }, this), this.options.duration)), this
            },
            destroy: function(c) {
                // Stop the resize events
                a(b).off("resize.backstretch orientationchange.backstretch"),
                    // Clear the interval
                    clearInterval(this.interval),
                    // Remove Backstretch
                    c || this.$wrap.remove(), this.$container.removeData("backstretch")
            }
        };
        /* SUPPORTS FIXED POSITION?
         *
         * Based on code from jQuery Mobile 1.1.0
         * http://jquerymobile.com/
         *
         * In a nutshell, we need to figure out if fixed positioning is supported.
         * Unfortunately, this is very difficult to do on iOS, and usually involves
         * injecting content, scrolling the page, etc.. It's ugly.
         * jQuery Mobile uses this workaround. It's not ideal, but works.
         *
         * Modified to detect IE6
         * ========================= */
        var f = function() {
            var a = navigator.userAgent,
                c = navigator.platform,
                d = a.match(/AppleWebKit\/([0-9]+)/),
                e = !!d && d[1],
                f = a.match(/Fennec\/([0-9]+)/),
                g = !!f && f[1],
                h = a.match(/Opera Mobi\/([0-9]+)/),
                i = !!h && h[1],
                j = a.match(/MSIE ([0-9]+)/),
                k = !!j && j[1];
            // iOS 4.3 and older : Platform is iPhone/Pad/Touch and Webkit version is less than 534 (ios5)
            // Opera Mini
            //Android lte 2.1: Platform is Android and Webkit version is less than 533 (Android 2.2)
            // Firefox Mobile before 6.0 -
            // WebOS less than 3
            // MeeGo
            // IE6
            return !((c.indexOf("iPhone") > -1 || c.indexOf("iPad") > -1 || c.indexOf("iPod") > -1) && e && 534 > e || b.operamini && "[object OperaMini]" === {}.toString.call(b.operamini) || h && 7458 > i || a.indexOf("Android") > -1 && e && 533 > e || g && 6 > g || "palmGetResource" in b && e && 534 > e || a.indexOf("MeeGo") > -1 && a.indexOf("NokiaBrowser/8.5.0") > -1 || k && 6 >= k)
        }()
    }(jQuery, window),
    function(a, b, c, d) {
        "use strict";
        /**
         * contains all logic and the whole element handling
         * is packed in a private function outside class to reduce memory usage, because it will not be created on every plugin instance
         * @access private
         * @type {function}
         * @param {LazyPlugin} instance
         * @param {function} configuration
         * @param {object} items
         * @param {object} events
         * @return void
         */
        function e(c, d, e, f) {
            /**
             * initialize plugin
             * bind loading to events or set delay time to load all items at once
             * @access private
             * @return void
             */
            function g() {
                t = b.devicePixelRatio > 1, h(e), d("delay") >= 0 && setTimeout(function() {
                    i(!0)
                }, d("delay")), (d("delay") < 0 || d("combined")) && (f.e = n(d("throttle"), function(a) {
                    "resize" === a.type && (r = s = -1), i(a.all)
                }), f.a = function(a) {
                    h(a), e.push.apply(e, a)
                }, f.g = function() {
                    return e
                }, i(), a(d("appendScroll")).on("scroll." + c.name + " resize." + c.name, f.e))
            }
            /**
             * prepare items before handle them
             * @access private
             * @param {Array|object|jQuery} items
             * @return void
             */
            function h(b) {
                // set default image and/or placeholder to elements if configured
                if (b = a(b).filter(function() {
                        return !a(this).data(d("handledName")) && (a(this).attr(d("attribute")) || a(this).attr(d("loaderAttribute")))
                    }).data("plugin_" + c.name, c), d("defaultImage") || d("placeholder"))
                    for (var e = 0; e < b.length; e++) {
                        var f = a(b[e]),
                            g = b[e].tagName.toLowerCase(),
                            h = "background-image";
                        // set default image on every element without source
                        "img" == g && d("defaultImage") && !f.attr("src") ? f.attr("src", d("defaultImage")) : "img" == g || !d("placeholder") || f.css(h) && "none" != f.css(h) || f.css(h, "url(" + d("placeholder") + ")")
                    }
            }
            /**
             * the 'lazy magic' - check all items
             * @access private
             * @param {boolean} [allItems]
             * @return void
             */
            function i(b) {
                // skip if no items where left
                if (!e.length)
                // destroy instance if option is enabled
                // noinspection JSUnresolvedFunction
                    return void(d("autoDestroy") && c.destroy());
                // loop all available items
                for (var f = !1,
                        // get image base once, not on every image loop
                        g = d("imageBase") ? d("imageBase") : "", h = 0; h < e.length; h++)(function(c) {
                    // item is at least in loadable area
                    if (k(c) || b) {
                        var e, h = a(c),
                            i = c.tagName.toLowerCase(),
                            l = h.attr(d("attribute"));
                        // is not already handled 
                        h.data(d("handledName")) || d("visibleOnly") && !h.is(":visible") || !(l && ("img" == i && g + l != h.attr("src") || "img" != i && g + l != h.css("background-image")) || (e = h.attr(d("loaderAttribute")))) || (f = !0, h.data(d("handledName"), !0), j(h, i, g, e))
                    }
                })(e[h]);
                // when something was loaded remove them from remaining items
                f && (e = a(e).filter(function() {
                    return !a(this).data(d("handledName"))
                }))
            }
            /**
             * load the given element the lazy way
             * @access private
             * @param {object} element
             * @param {string} tag
             * @param {string} imageBase
             * @param {function} [customLoader]
             * @return void
             */
            function j(b, c, e, f) {
                // increment count of items waiting for after load
                ++q;
                // extended error callback for correct 'onFinishedAll' handling
                var g = function() {
                    p("onError", b), o()
                };
                // handle custom loader
                if (
                    // trigger function before loading image
                    p("beforeLoad", b), f)
                // bind error event to trigger callback and reduce waiting amount
                    b.off("error").one("error", g),
                    // bind after load callback to image
                    b.one("load", function() {
                        // remove attribute from element
                        d("removeAttribute") && b.removeAttr(d("loaderAttribute")),
                            // call after load event
                            p("afterLoad", b),
                            // remove item from waiting queue and possible trigger finished event
                            o()
                    }),
                    // trigger custom loader
                    p(f, b, function(a) {
                        a ? b.load() : b.error()
                    }) || b.error();
                else {
                    // create image object
                    var h = a(new Image);
                    // bind error event to trigger callback and reduce waiting amount
                    h.one("error", g),
                        // bind after load callback to image
                        h.one("load", function() {
                            // remove element from view
                            b.hide(),
                                // set image back to element
                                "img" == c ? b.attr("src", h.attr("src")) : b.css("background-image", "url(" + h.attr("src") + ")"),
                                // bring it back with some effect!
                                b[d("effect")](d("effectTime")),
                                // remove attribute from element
                                d("removeAttribute") && b.removeAttr(d("attribute") + " " + d("retinaAttribute")),
                                // call after load event
                                p("afterLoad", b),
                                // cleanup image object
                                h.remove(),
                                // remove item from waiting queue and possible trigger finished event
                                o()
                        }),
                        // set source
                        h.attr("src", e + b.attr(d(t && b.attr(d("retinaAttribute")) ? "retinaAttribute" : "attribute"))),
                        // call after load even on cached image
                        h.complete && h.load()
                }
            }
            /**
             * check if the given element is inside the current viewport or threshold
             * @access private
             * @param {object} element
             * @return {boolean}
             */
            function k(a) {
                var b = a.getBoundingClientRect(),
                    c = d("scrollDirection"),
                    e = d("threshold"),
                    f = m() + e > b.top && -e < b.bottom,
                    g = l() + e > b.left && -e < b.right;
                return "vertical" == c ? f : "horizontal" == c ? g : f && g
            }
            /**
             * receive the current viewed width of the browser
             * @access private
             * @return {number}
             */
            function l() {
                return r >= 0 ? r : r = a(b).width()
            }
            /**
             * receive the current viewed height of the browser
             * @access private
             * @return {number}
             */
            function m() {
                return s >= 0 ? s : s = a(b).height()
            }
            /**
             * helper function to throttle down event triggering
             * @access private
             * @param {number} delay
             * @param {function} callback
             * @return {function}
             */
            function n(a, b) {
                var e, f = 0;
                return function(g, h) {
                    function i() {
                        f = +new Date, b.call(c, g)
                    }
                    var j = +new Date - f;
                    e && clearTimeout(e), j > a || !d("enableThrottle") || h ? i() : e = setTimeout(i, a - j)
                }
            }
            /**
             * reduce count of awaiting elements to 'afterLoad' event and fire 'onFinishedAll' if reached zero
             * @access private
             * @return void
             */
            function o() {
                --q,
                // if no items were left trigger finished event
                e.size() || q || p("onFinishedAll")
            }
            /**
             * single implementation to handle callbacks, pass element and set 'this' to current instance
             * @access private
             * @param {string|function} callback
             * @param {object} [element]
             * @param {*} [args]
             * @return {boolean}
             */
            function p(a, b, e) {
                // jQuery's internal '$(arguments).slice(1)' are causing problems at least on old iPads
                // below is shorthand of 'Array.prototype.slice.call(arguments, 1)'
                return (a = d(a)) ? (a.apply(c, [].slice.call(arguments, 1)), !0) : !1
            }
            /**
             * a helper to trigger the 'onFinishedAll' callback after all other events
             * @access private
             * @type {number}
             */
            var q = 0,
                /**
                 * visible content width
                 * @access private
                 * @type {number}
                 */
                r = -1,
                /**
                 * visible content height
                 * @access private
                 * @type {number}
                 */
                s = -1,
                /**
                 * determine possible detected high pixel density
                 * @access private
                 * @type {boolean}
                 */
                t = !1;
            // set up lazy
            ! function() {
                // if event driven don't wait for page loading
                "event" == d("bind") ? g() : a(b).load(g)
            }()
        }
        /**
         * lazy plugin class constructor
         * @constructor
         * @access private
         * @param {object} elements
         * @param {object} settings
         * @return {object|LazyPlugin}
         */
        function f(b, c) {
            /**
             * this lazy plugin instance
             * @access private
             * @type {object|LazyPlugin}
             */
            var f = this,
                /**
                 * this lazy plugin instance configuration
                 * @access private
                 * @type {object}
                 */
                g = a.extend({}, f.configuration, c),
                /**
                 * instance generated event executed on container scroll or resize
                 * packed in an object to be referenceable and short named because properties will not be minified
                 * @access private
                 * @type {object}
                 */
                h = {};
            // noinspection JSUnresolvedFunction
            // noinspection JSUndefinedPropertyAssignment
            /**
             * wrapper to get or set an entry from plugin instance configuration
             * much smaller on minify as direct access
             * @access private
             * @type {function}
             * @param {string} entryName
             * @param {*} [value]
             * @return {LazyPlugin|*}
             */
            // noinspection JSUndefinedPropertyAssignment
            /**
             * add additional items to current instance
             * @access public
             * @param {Array|object|string} items
             * @return {LazyPlugin}
             */
            // noinspection JSUndefinedPropertyAssignment
            /**
             * get all left items of this instance
             * @access public
             * @returns {object}
             */
            // noinspection JSUndefinedPropertyAssignment
            /**
             * force lazy to load all items in loadable area right now
             * by default without throttle
             * @access public
             * @type {function}
             * @param {boolean} [useThrottle]
             * @return {LazyPlugin}
             */
            // noinspection JSUndefinedPropertyAssignment
            /**
             * force lazy to load all available items right now
             * this call ignores throttling
             * @access public
             * @type {function}
             * @return {LazyPlugin}
             */
            // noinspection JSUndefinedPropertyAssignment
            /**
             * destroy this plugin instance
             * @access public
             * @type {function}
             * @return undefined
             */
            // start using lazy and return all elements to be chainable or instance for further use
            // noinspection JSUnresolvedVariable
            return f.config = function(a, b) {
                return b === d ? g[a] : (g[a] = b, f)
            }, f.addItems = function(b) {
                return h.a && h.a("string" === a.type(b) ? a(b) : b), f
            }, f.getItems = function() {
                return h.g ? h.g() : {}
            }, f.update = function(a) {
                return h.e && h.e({}, !a), f
            }, f.loadAll = function() {
                return h.e && h.e({
                    all: !0
                }, !0), f
            }, f.destroy = function() {
                // unbind instance generated events
                // noinspection JSUnresolvedFunction
                // clear events
                return a(f.config("appendScroll")).off("." + f.name, h.e), h = {}, d
            }, e(f, f.config, b, h), f.config("chainable") ? b : f
        }
        // make lazy a bit more case-insensitive :)
        a.fn.Lazy = a.fn.lazy = function(a) {
                return new f(this, a)
            },
            // use jquery to extend class prototype without conflicts
            a.extend(f.prototype, {
                /**
                 * internal name used for bindings and namespaces
                 * @access public
                 * @var {string}
                 */
                name: "lazy",
                /**
                 * settings and configuration data
                 * @access public
                 * @type {object}
                 */
                configuration: {
                    // general
                    chainable: !0,
                    autoDestroy: !0,
                    bind: "load",
                    threshold: 500,
                    visibleOnly: !1,
                    appendScroll: b,
                    scrollDirection: "both",
                    imageBase: null,
                    defaultImage: "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==",
                    placeholder: null,
                    delay: -1,
                    combined: !1,
                    // attributes
                    attribute: "data-src",
                    retinaAttribute: "data-retina",
                    loaderAttribute: "data-loader",
                    removeAttribute: !0,
                    handledName: "handled",
                    // effect
                    effect: "show",
                    effectTime: 0,
                    // throttle
                    enableThrottle: !0,
                    throttle: 250,
                    // callbacks
                    beforeLoad: null,
                    afterLoad: null,
                    onError: null,
                    onFinishedAll: null
                }
            })
    }(jQuery, window, document),
    /*
         _ _      _       _
     * jQuery UI Core 1.11.4
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/category/ui-core/
     */
    function(a) {
        "function" == typeof define && define.amd ?
            // AMD. Register as an anonymous module.
            define(["jquery"], a) :
            // Browser globals
            a(jQuery)
    }(function(a) {
        // selectors
        function b(b, d) {
            var e, f, g, h = b.nodeName.toLowerCase();
            // the element and all of its ancestors must be visible
            return "area" === h ? (e = b.parentNode, f = e.name, b.href && f && "map" === e.nodeName.toLowerCase() ? (g = a("img[usemap='#" + f + "']")[0], !!g && c(g)) : !1) : (/^(input|select|textarea|button|object)$/.test(h) ? !b.disabled : "a" === h ? b.href || d : d) && c(b)
        }

        function c(b) {
            return a.expr.filters.visible(b) && !a(b).parents().addBack().filter(function() {
                return "hidden" === a.css(this, "visibility")
            }).length
        }
        // $.ui might exist from components with no dependencies, e.g., $.ui.position
        a.ui = a.ui || {}, a.extend(a.ui, {
                version: "1.11.4",
                keyCode: {
                    BACKSPACE: 8,
                    COMMA: 188,
                    DELETE: 46,
                    DOWN: 40,
                    END: 35,
                    ENTER: 13,
                    ESCAPE: 27,
                    HOME: 36,
                    LEFT: 37,
                    PAGE_DOWN: 34,
                    PAGE_UP: 33,
                    PERIOD: 190,
                    RIGHT: 39,
                    SPACE: 32,
                    TAB: 9,
                    UP: 38
                }
            }),
            // plugins
            a.fn.extend({
                scrollParent: function(b) {
                    var c = this.css("position"),
                        d = "absolute" === c,
                        e = b ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
                        f = this.parents().filter(function() {
                            var b = a(this);
                            return d && "static" === b.css("position") ? !1 : e.test(b.css("overflow") + b.css("overflow-y") + b.css("overflow-x"))
                        }).eq(0);
                    return "fixed" !== c && f.length ? f : a(this[0].ownerDocument || document)
                },
                uniqueId: function() {
                    var a = 0;
                    return function() {
                        return this.each(function() {
                            this.id || (this.id = "ui-id-" + ++a)
                        })
                    }
                }(),
                removeUniqueId: function() {
                    return this.each(function() {
                        /^ui-id-\d+$/.test(this.id) && a(this).removeAttr("id")
                    })
                }
            }), a.extend(a.expr[":"], {
                data: a.expr.createPseudo ? a.expr.createPseudo(function(b) {
                        return function(c) {
                            return !!a.data(c, b)
                        }
                    }) :
                    // support: jQuery <1.8
                    function(b, c, d) {
                        return !!a.data(b, d[3])
                    },
                focusable: function(c) {
                    return b(c, !isNaN(a.attr(c, "tabindex")))
                },
                tabbable: function(c) {
                    var d = a.attr(c, "tabindex"),
                        e = isNaN(d);
                    return (e || d >= 0) && b(c, !e)
                }
            }),
            // support: jQuery <1.8
            a("<a>").outerWidth(1).jquery || a.each(["Width", "Height"], function(b, c) {
                function d(b, c, d, f) {
                    return a.each(e, function() {
                        c -= parseFloat(a.css(b, "padding" + this)) || 0, d && (c -= parseFloat(a.css(b, "border" + this + "Width")) || 0), f && (c -= parseFloat(a.css(b, "margin" + this)) || 0)
                    }), c
                }
                var e = "Width" === c ? ["Left", "Right"] : ["Top", "Bottom"],
                    f = c.toLowerCase(),
                    g = {
                        innerWidth: a.fn.innerWidth,
                        innerHeight: a.fn.innerHeight,
                        outerWidth: a.fn.outerWidth,
                        outerHeight: a.fn.outerHeight
                    };
                a.fn["inner" + c] = function(b) {
                    return void 0 === b ? g["inner" + c].call(this) : this.each(function() {
                        a(this).css(f, d(this, b) + "px")
                    })
                }, a.fn["outer" + c] = function(b, e) {
                    return "number" != typeof b ? g["outer" + c].call(this, b) : this.each(function() {
                        a(this).css(f, d(this, b, !0, e) + "px")
                    })
                }
            }),
            // support: jQuery <1.8
            a.fn.addBack || (a.fn.addBack = function(a) {
                return this.add(null == a ? this.prevObject : this.prevObject.filter(a))
            }),
            // support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
            a("<a>").data("a-b", "a").removeData("a-b").data("a-b") && (a.fn.removeData = function(b) {
                return function(c) {
                    return arguments.length ? b.call(this, a.camelCase(c)) : b.call(this)
                }
            }(a.fn.removeData)),
            // deprecated
            a.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase()), a.fn.extend({
                focus: function(b) {
                    return function(c, d) {
                        return "number" == typeof c ? this.each(function() {
                            var b = this;
                            setTimeout(function() {
                                a(b).focus(), d && d.call(b)
                            }, c)
                        }) : b.apply(this, arguments)
                    }
                }(a.fn.focus),
                disableSelection: function() {
                    var a = "onselectstart" in document.createElement("div") ? "selectstart" : "mousedown";
                    return function() {
                        return this.bind(a + ".ui-disableSelection", function(a) {
                            a.preventDefault()
                        })
                    }
                }(),
                enableSelection: function() {
                    return this.unbind(".ui-disableSelection")
                },
                zIndex: function(b) {
                    if (void 0 !== b) return this.css("zIndex", b);
                    if (this.length)
                        for (var c, d, e = a(this[0]); e.length && e[0] !== document;) {
                            if (c = e.css("position"), ("absolute" === c || "relative" === c || "fixed" === c) && (d = parseInt(e.css("zIndex"), 10), !isNaN(d) && 0 !== d)) return d;
                            e = e.parent()
                        }
                    return 0
                }
            }),
            // $.ui.plugin is deprecated. Use $.widget() extensions instead.
            a.ui.plugin = {
                add: function(b, c, d) {
                    var e, f = a.ui[b].prototype;
                    for (e in d) f.plugins[e] = f.plugins[e] || [], f.plugins[e].push([c, d[e]])
                },
                call: function(a, b, c, d) {
                    var e, f = a.plugins[b];
                    if (f && (d || a.element[0].parentNode && 11 !== a.element[0].parentNode.nodeType))
                        for (e = 0; e < f.length; e++) a.options[f[e][0]] && f[e][1].apply(a.element, c)
                }
            }
    }),
    /*!
     * jQuery UI Widget 1.11.4
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/jQuery.widget/
     */
    function(a) {
        "function" == typeof define && define.amd ?
            // AMD. Register as an anonymous module.
            define(["jquery"], a) :
            // Browser globals
            a(jQuery)
    }(function(a) {
        var b = 0,
            c = Array.prototype.slice;
        return a.cleanData = function(b) {
            return function(c) {
                var d, e, f;
                for (f = 0; null != (e = c[f]); f++) try {
                    // Only trigger remove when necessary to save time
                    d = a._data(e, "events"), d && d.remove && a(e).triggerHandler("remove")
                } catch (g) {}
                b(c)
            }
        }(a.cleanData), a.widget = function(b, c, d) {
            var e, f, g, h,
                // proxiedPrototype allows the provided prototype to remain unmodified
                // so that it can be used as a mixin for multiple widgets (#8876)
                i = {},
                j = b.split(".")[0];
            // create selector for plugin
            // extend with the existing constructor to carry over any static properties
            // we need to make the options hash a property directly on the new instance
            // otherwise we'll modify the options hash on the prototype that we're
            // inheriting from
            // If this widget is being redefined then we need to find all widgets that
            // are inheriting from it and redefine all of them so that they inherit from
            // the new version of this widget. We're essentially trying to replace one
            // level in the prototype chain.
            // remove the list of existing child constructors from the old constructor
            // so the old child constructors can be garbage collected
            return b = b.split(".")[1], e = j + "-" + b, d || (d = c, c = a.Widget), a.expr[":"][e.toLowerCase()] = function(b) {
                return !!a.data(b, e)
            }, a[j] = a[j] || {}, f = a[j][b], g = a[j][b] = function(a, b) {
                return this._createWidget ? void(arguments.length && this._createWidget(a, b)) : new g(a, b)
            }, a.extend(g, f, {
                version: d.version,
                _proto: a.extend({}, d),
                _childConstructors: []
            }), h = new c, h.options = a.widget.extend({}, h.options), a.each(d, function(b, d) {
                return a.isFunction(d) ? void(i[b] = function() {
                    var a = function() {
                            return c.prototype[b].apply(this, arguments)
                        },
                        e = function(a) {
                            return c.prototype[b].apply(this, a)
                        };
                    return function() {
                        var b, c = this._super,
                            f = this._superApply;
                        return this._super = a, this._superApply = e, b = d.apply(this, arguments), this._super = c, this._superApply = f, b
                    }
                }()) : void(i[b] = d)
            }), g.prototype = a.widget.extend(h, {
                widgetEventPrefix: f ? h.widgetEventPrefix || b : b
            }, i, {
                constructor: g,
                namespace: j,
                widgetName: b,
                widgetFullName: e
            }), f ? (a.each(f._childConstructors, function(b, c) {
                var d = c.prototype;
                a.widget(d.namespace + "." + d.widgetName, g, c._proto)
            }), delete f._childConstructors) : c._childConstructors.push(g), a.widget.bridge(b, g), g
        }, a.widget.extend = function(b) {
            for (var d, e, f = c.call(arguments, 1), g = 0, h = f.length; h > g; g++)
                for (d in f[g]) e = f[g][d], f[g].hasOwnProperty(d) && void 0 !== e && (a.isPlainObject(e) ? b[d] = a.isPlainObject(b[d]) ? a.widget.extend({}, b[d], e) : a.widget.extend({}, e) : b[d] = e);
            return b
        }, a.widget.bridge = function(b, d) {
            var e = d.prototype.widgetFullName || b;
            a.fn[b] = function(f) {
                var g = "string" == typeof f,
                    h = c.call(arguments, 1),
                    i = this;
                // Allow multiple hashes to be passed on init
                return g ? this.each(function() {
                    var c, d = a.data(this, e);
                    return "instance" === f ? (i = d, !1) : d ? a.isFunction(d[f]) && "_" !== f.charAt(0) ? (c = d[f].apply(d, h), c !== d && void 0 !== c ? (i = c && c.jquery ? i.pushStack(c.get()) : c, !1) : void 0) : a.error("no such method '" + f + "' for " + b + " widget instance") : a.error("cannot call methods on " + b + " prior to initialization; attempted to call method '" + f + "'")
                }) : (h.length && (f = a.widget.extend.apply(null, [f].concat(h))), this.each(function() {
                    var b = a.data(this, e);
                    b ? (b.option(f || {}), b._init && b._init()) : a.data(this, e, new d(f, this))
                })), i
            }
        }, a.Widget = function() {}, a.Widget._childConstructors = [], a.Widget.prototype = {
            widgetName: "widget",
            widgetEventPrefix: "",
            defaultElement: "<div>",
            options: {
                disabled: !1,
                // callbacks
                create: null
            },
            _createWidget: function(c, d) {
                d = a(d || this.defaultElement || this)[0], this.element = a(d), this.uuid = b++, this.eventNamespace = "." + this.widgetName + this.uuid, this.bindings = a(), this.hoverable = a(), this.focusable = a(), d !== this && (a.data(d, this.widgetFullName, this), this._on(!0, this.element, {
                    remove: function(a) {
                        a.target === d && this.destroy()
                    }
                }), this.document = a(d.style ? d.ownerDocument : d.document || d), this.window = a(this.document[0].defaultView || this.document[0].parentWindow)), this.options = a.widget.extend({}, this.options, this._getCreateOptions(), c), this._create(), this._trigger("create", null, this._getCreateEventData()), this._init()
            },
            _getCreateOptions: a.noop,
            _getCreateEventData: a.noop,
            _create: a.noop,
            _init: a.noop,
            destroy: function() {
                this._destroy(),
                    // we can probably remove the unbind calls in 2.0
                    // all event bindings should go through this._on()
                    this.element.unbind(this.eventNamespace).removeData(this.widgetFullName).removeData(a.camelCase(this.widgetFullName)), this.widget().unbind(this.eventNamespace).removeAttr("aria-disabled").removeClass(this.widgetFullName + "-disabled ui-state-disabled"),
                    // clean up events and states
                    this.bindings.unbind(this.eventNamespace), this.hoverable.removeClass("ui-state-hover"), this.focusable.removeClass("ui-state-focus")
            },
            _destroy: a.noop,
            widget: function() {
                return this.element
            },
            option: function(b, c) {
                var d, e, f, g = b;
                if (0 === arguments.length)
                // don't return a reference to the internal hash
                    return a.widget.extend({}, this.options);
                if ("string" == typeof b)
                    if (g = {}, d = b.split("."), b = d.shift(), d.length) {
                        for (e = g[b] = a.widget.extend({}, this.options[b]), f = 0; f < d.length - 1; f++) e[d[f]] = e[d[f]] || {}, e = e[d[f]];
                        if (b = d.pop(), 1 === arguments.length) return void 0 === e[b] ? null : e[b];
                        e[b] = c
                    } else {
                        if (1 === arguments.length) return void 0 === this.options[b] ? null : this.options[b];
                        g[b] = c
                    }
                return this._setOptions(g), this
            },
            _setOptions: function(a) {
                var b;
                for (b in a) this._setOption(b, a[b]);
                return this
            },
            _setOption: function(a, b) {
                // If the widget is becoming disabled, then nothing is interactive
                return this.options[a] = b, "disabled" === a && (this.widget().toggleClass(this.widgetFullName + "-disabled", !!b), b && (this.hoverable.removeClass("ui-state-hover"), this.focusable.removeClass("ui-state-focus"))), this
            },
            enable: function() {
                return this._setOptions({
                    disabled: !1
                })
            },
            disable: function() {
                return this._setOptions({
                    disabled: !0
                })
            },
            _on: function(b, c, d) {
                var e, f = this;
                "boolean" != typeof b && (d = c, c = b, b = !1),
                    // no element argument, shuffle and use this.element
                    d ? (c = e = a(c), this.bindings = this.bindings.add(c)) : (d = c, c = this.element, e = this.widget()), a.each(d, function(d, g) {
                        function h() {
                            // allow widgets to customize the disabled handling
                            // - disabled as an array instead of boolean
                            // - disabled class as method for disabling individual parts
                            // allow widgets to customize the disabled handling
                            // - disabled as an array instead of boolean
                            // - disabled class as method for disabling individual parts
                            return b || f.options.disabled !== !0 && !a(this).hasClass("ui-state-disabled") ? ("string" == typeof g ? f[g] : g).apply(f, arguments) : void 0
                        }
                        // copy the guid so direct unbinding works
                        "string" != typeof g && (h.guid = g.guid = g.guid || h.guid || a.guid++);
                        var i = d.match(/^([\w:-]*)\s*(.*)$/),
                            j = i[1] + f.eventNamespace,
                            k = i[2];
                        k ? e.delegate(k, j, h) : c.bind(j, h)
                    })
            },
            _off: function(b, c) {
                c = (c || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace, b.unbind(c).undelegate(c), this.bindings = a(this.bindings.not(b).get()), this.focusable = a(this.focusable.not(b).get()), this.hoverable = a(this.hoverable.not(b).get())
            },
            _delay: function(a, b) {
                function c() {
                    return ("string" == typeof a ? d[a] : a).apply(d, arguments)
                }
                var d = this;
                return setTimeout(c, b || 0)
            },
            _hoverable: function(b) {
                this.hoverable = this.hoverable.add(b), this._on(b, {
                    mouseenter: function(b) {
                        a(b.currentTarget).addClass("ui-state-hover")
                    },
                    mouseleave: function(b) {
                        a(b.currentTarget).removeClass("ui-state-hover")
                    }
                })
            },
            _focusable: function(b) {
                this.focusable = this.focusable.add(b), this._on(b, {
                    focusin: function(b) {
                        a(b.currentTarget).addClass("ui-state-focus")
                    },
                    focusout: function(b) {
                        a(b.currentTarget).removeClass("ui-state-focus")
                    }
                })
            },
            _trigger: function(b, c, d) {
                var e, f, g = this.options[b];
                if (d = d || {}, c = a.Event(c), c.type = (b === this.widgetEventPrefix ? b : this.widgetEventPrefix + b).toLowerCase(), c.target = this.element[0], f = c.originalEvent)
                    for (e in f) e in c || (c[e] = f[e]);
                return this.element.trigger(c, d), !(a.isFunction(g) && g.apply(this.element[0], [c].concat(d)) === !1 || c.isDefaultPrevented())
            }
        }, a.each({
            show: "fadeIn",
            hide: "fadeOut"
        }, function(b, c) {
            a.Widget.prototype["_" + b] = function(d, e, f) {
                "string" == typeof e && (e = {
                    effect: e
                });
                var g, h = e ? e === !0 || "number" == typeof e ? c : e.effect || c : b;
                e = e || {}, "number" == typeof e && (e = {
                    duration: e
                }), g = !a.isEmptyObject(e), e.complete = f, e.delay && d.delay(e.delay), g && a.effects && a.effects.effect[h] ? d[b](e) : h !== b && d[h] ? d[h](e.duration, e.easing, f) : d.queue(function(c) {
                    a(this)[b](), f && f.call(d[0]), c()
                })
            }
        }), a.widget
    }),
    /*!
     * jQuery UI Datepicker 1.11.4
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/datepicker/
     */
    function(a) {
        "function" == typeof define && define.amd ?
            // AMD. Register as an anonymous module.
            define(["jquery", "./core"], a) :
            // Browser globals
            a(jQuery)
    }(function(a) {
        function b(a) {
            for (var b, c; a.length && a[0] !== document;) {
                if (b = a.css("position"), ("absolute" === b || "relative" === b || "fixed" === b) && (c = parseInt(a.css("zIndex"), 10), !isNaN(c) && 0 !== c)) return c;
                a = a.parent()
            }
            return 0
        }
        /* Date picker manager.
           Use the singleton instance of this class, $.datepicker, to interact with the date picker.
           Settings for (groups of) date pickers are maintained in an instance object,
           allowing multiple different settings on the same page. */
        function c() {
            this._curInst = null, // The current instance in use
                this._keyEvent = !1, // If the last event was a key event
                this._disabledInputs = [], // List of date picker inputs that have been disabled
                this._datepickerShowing = !1, // True if the popup picker is showing , false if not
                this._inDialog = !1, // True if showing within a "dialog", false if not
                this._mainDivId = "ui-datepicker-div", // The ID of the main datepicker division
                this._inlineClass = "ui-datepicker-inline", // The name of the inline marker class
                this._appendClass = "ui-datepicker-append", // The name of the append marker class
                this._triggerClass = "ui-datepicker-trigger", // The name of the trigger marker class
                this._dialogClass = "ui-datepicker-dialog", // The name of the dialog marker class
                this._disableClass = "ui-datepicker-disabled", // The name of the disabled covering marker class
                this._unselectableClass = "ui-datepicker-unselectable", // The name of the unselectable cell marker class
                this._currentClass = "ui-datepicker-current-day", // The name of the current day marker class
                this._dayOverClass = "ui-datepicker-days-cell-over", // The name of the day hover marker class
                this.regional = [], // Available regional settings, indexed by language code
                this.regional[""] = { // Default regional settings
                    closeText: "Done", // Display text for close link
                    prevText: "Prev", // Display text for previous month link
                    nextText: "Next", // Display text for next month link
                    currentText: "Today", // Display text for current month link
                    monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], // Names of months for drop-down and formatting
                    monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], // For formatting
                    dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], // For formatting
                    dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], // For formatting
                    dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"], // Column headings for days starting at Sunday
                    weekHeader: "Wk", // Column header for week of the year
                    dateFormat: "mm/dd/yy", // See format options on parseDate
                    firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
                    isRTL: !1, // True if right-to-left language, false if left-to-right
                    showMonthAfterYear: !1, // True if the year select precedes month, false for month then year
                    yearSuffix: ""
                }, this._defaults = { // Global defaults for all the date picker instances
                    showOn: "focus", // "focus" for popup on focus,
                    // "button" for trigger button, or "both" for either
                    showAnim: "fadeIn", // Name of jQuery animation for popup
                    showOptions: {}, // Options for enhanced animations
                    defaultDate: null, // Used when field is blank: actual date,
                    // +/-number for offset from today, null for today
                    appendText: "", // Display text following the input box, e.g. showing the format
                    buttonText: "...", // Text for trigger button
                    buttonImage: "", // URL for trigger button image
                    buttonImageOnly: !1, // True if the image appears alone, false if it appears on a button
                    hideIfNoPrevNext: !1, // True to hide next/previous month links
                    // if not applicable, false to just disable them
                    navigationAsDateFormat: !1, // True if date formatting applied to prev/today/next links
                    gotoCurrent: !1, // True if today link goes back to current selection instead
                    changeMonth: !1, // True if month can be selected directly, false if only prev/next
                    changeYear: !1, // True if year can be selected directly, false if only prev/next
                    yearRange: "c-10:c+10", // Range of years to display in drop-down,
                    // either relative to today's year (-nn:+nn), relative to currently displayed year
                    // (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
                    showOtherMonths: !1, // True to show dates in other months, false to leave blank
                    selectOtherMonths: !1, // True to allow selection of dates in other months, false for unselectable
                    showWeek: !1, // True to show week of the year, false to not show it
                    calculateWeek: this.iso8601Week, // How to calculate the week of the year,
                    // takes a Date and returns the number of the week for it
                    shortYearCutoff: "+10", // Short year values < this are in the current century,
                    // > this are in the previous century,
                    // string value starting with "+" for current year + value
                    minDate: null, // The earliest selectable date, or null for no limit
                    maxDate: null, // The latest selectable date, or null for no limit
                    duration: "fast", // Duration of display/closure
                    beforeShowDay: null, // Function that takes a date and returns an array with
                    // [0] = true if selectable, false if not, [1] = custom CSS class name(s) or "",
                    // [2] = cell title (optional), e.g. $.datepicker.noWeekends
                    beforeShow: null, // Function that takes an input field and
                    // returns a set of custom settings for the date picker
                    onSelect: null, // Define a callback function when a date is selected
                    onChangeMonthYear: null, // Define a callback function when the month or year is changed
                    onClose: null, // Define a callback function when the datepicker is closed
                    numberOfMonths: 1, // Number of months to show at a time
                    showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
                    stepMonths: 1, // Number of months to step back/forward
                    stepBigMonths: 12, // Number of months to step back/forward for the big links
                    altField: "", // Selector for an alternate field to store selected dates into
                    altFormat: "", // The date format to use for the alternate field
                    constrainInput: !0, // The input is constrained by the current date format
                    showButtonPanel: !1, // True to show button panel, false to not show it
                    autoSize: !1, // True to size the input for the date format, false to leave as is
                    disabled: !1
                }, a.extend(this._defaults, this.regional[""]), this.regional.en = a.extend(!0, {}, this.regional[""]), this.regional["en-US"] = a.extend(!0, {}, this.regional.en), this.dpDiv = d(a("<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"))
        }
        /*
         * Bind hover events for datepicker elements.
         * Done via delegate so the binding only occurs once in the lifetime of the parent div.
         * Global datepicker_instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
         */
        function d(b) {
            var c = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
            return b.delegate(c, "mouseout", function() {
                a(this).removeClass("ui-state-hover"), -1 !== this.className.indexOf("ui-datepicker-prev") && a(this).removeClass("ui-datepicker-prev-hover"), -1 !== this.className.indexOf("ui-datepicker-next") && a(this).removeClass("ui-datepicker-next-hover")
            }).delegate(c, "mouseover", e)
        }

        function e() {
            a.datepicker._isDisabledDatepicker(g.inline ? g.dpDiv.parent()[0] : g.input[0]) || (a(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover"), a(this).addClass("ui-state-hover"), -1 !== this.className.indexOf("ui-datepicker-prev") && a(this).addClass("ui-datepicker-prev-hover"), -1 !== this.className.indexOf("ui-datepicker-next") && a(this).addClass("ui-datepicker-next-hover"))
        } /* jQuery extend now ignores nulls! */
        function f(b, c) {
            a.extend(b, c);
            for (var d in c) null == c[d] && (b[d] = c[d]);
            return b
        }
        a.extend(a.ui, {
            datepicker: {
                version: "1.11.4"
            }
        });
        var g;
        /* Invoke the datepicker functionality.
           @param  options  string - a command, optionally followed by additional parameters or
        					Object - settings for attaching new datepicker functionality
           @return  jQuery object */
        // singleton instance
        return a.extend(c.prototype, { /* Class name added to elements to indicate already configured with a date picker. */
            markerClassName: "hasDatepicker",
            //Keep track of the maximum number of rows displayed (see #7043)
            maxRows: 4,
            // TODO rename to "widget" when switching to widget factory
            _widgetDatepicker: function() {
                return this.dpDiv
            },
            /* Override the default settings for all instances of the date picker.
             * @param  settings  object - the new settings to use as defaults (anonymous object)
             * @return the manager object
             */
            setDefaults: function(a) {
                return f(this._defaults, a || {}), this
            },
            /* Attach the date picker to a jQuery selection.
             * @param  target	element - the target input field or division or span
             * @param  settings  object - the new settings to use for this date picker instance (anonymous)
             */
            _attachDatepicker: function(b, c) {
                var d, e, f;
                d = b.nodeName.toLowerCase(), e = "div" === d || "span" === d, b.id || (this.uuid += 1, b.id = "dp" + this.uuid), f = this._newInst(a(b), e), f.settings = a.extend({}, c || {}), "input" === d ? this._connectDatepicker(b, f) : e && this._inlineDatepicker(b, f)
            },
            /* Create a new instance object. */
            _newInst: function(b, c) {
                var e = b[0].id.replace(/([^A-Za-z0-9_\-])/g, "\\\\$1"); // escape jQuery meta chars
                return {
                    id: e,
                    input: b, // associated target
                    selectedDay: 0,
                    selectedMonth: 0,
                    selectedYear: 0, // current selection
                    drawMonth: 0,
                    drawYear: 0, // month being drawn
                    inline: c, // is datepicker inline or not
                    dpDiv: c ? // presentation div
                        d(a("<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")) : this.dpDiv
                }
            },
            /* Attach the date picker to an input field. */
            _connectDatepicker: function(b, c) {
                var d = a(b);
                c.append = a([]), c.trigger = a([]), d.hasClass(this.markerClassName) || (this._attachments(d, c), d.addClass(this.markerClassName).keydown(this._doKeyDown).keypress(this._doKeyPress).keyup(this._doKeyUp), this._autoSize(c), a.data(b, "datepicker", c),
                    //If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
                    c.settings.disabled && this._disableDatepicker(b))
            },
            /* Make attachments based on settings. */
            _attachments: function(b, c) {
                var d, e, f, g = this._get(c, "appendText"),
                    h = this._get(c, "isRTL");
                c.append && c.append.remove(), g && (c.append = a("<span class='" + this._appendClass + "'>" + g + "</span>"), b[h ? "before" : "after"](c.append)), b.unbind("focus", this._showDatepicker), c.trigger && c.trigger.remove(), d = this._get(c, "showOn"), "focus" !== d && "both" !== d || b.focus(this._showDatepicker), "button" !== d && "both" !== d || (e = this._get(c, "buttonText"), f = this._get(c, "buttonImage"), c.trigger = a(this._get(c, "buttonImageOnly") ? a("<img/>").addClass(this._triggerClass).attr({
                    src: f,
                    alt: e,
                    title: e
                }) : a("<button type='button'></button>").addClass(this._triggerClass).html(f ? a("<img/>").attr({
                    src: f,
                    alt: e,
                    title: e
                }) : e)), b[h ? "before" : "after"](c.trigger), c.trigger.click(function() {
                    return a.datepicker._datepickerShowing && a.datepicker._lastInput === b[0] ? a.datepicker._hideDatepicker() : a.datepicker._datepickerShowing && a.datepicker._lastInput !== b[0] ? (a.datepicker._hideDatepicker(), a.datepicker._showDatepicker(b[0])) : a.datepicker._showDatepicker(b[0]), !1
                }))
            },
            /* Apply the maximum length for the date format. */
            _autoSize: function(a) {
                if (this._get(a, "autoSize") && !a.inline) {
                    var b, c, d, e, f = new Date(2009, 11, 20), // Ensure double digits
                        g = this._get(a, "dateFormat");
                    g.match(/[DM]/) && (b = function(a) {
                        for (c = 0, d = 0, e = 0; e < a.length; e++) a[e].length > c && (c = a[e].length, d = e);
                        return d
                    }, f.setMonth(b(this._get(a, g.match(/MM/) ? "monthNames" : "monthNamesShort"))), f.setDate(b(this._get(a, g.match(/DD/) ? "dayNames" : "dayNamesShort")) + 20 - f.getDay())), a.input.attr("size", this._formatDate(a, f).length)
                }
            },
            /* Attach an inline date picker to a div. */
            _inlineDatepicker: function(b, c) {
                var d = a(b);
                d.hasClass(this.markerClassName) || (d.addClass(this.markerClassName).append(c.dpDiv), a.data(b, "datepicker", c), this._setDate(c, this._getDefaultDate(c), !0), this._updateDatepicker(c), this._updateAlternate(c),
                    //If disabled option is true, disable the datepicker before showing it (see ticket #5665)
                    c.settings.disabled && this._disableDatepicker(b),
                    // Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
                    // http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
                    c.dpDiv.css("display", "block"))
            },
            /* Pop-up the date picker in a "dialog" box.
             * @param  input element - ignored
             * @param  date	string or Date - the initial date to display
             * @param  onSelect  function - the function to call when a date is selected
             * @param  settings  object - update the dialog date picker instance's settings (anonymous object)
             * @param  pos int[2] - coordinates for the dialog's position within the screen or
             *					event - with x/y coordinates or
             *					leave empty for default (screen centre)
             * @return the manager object
             */
            _dialogDatepicker: function(b, c, d, e, g) {
                var h, i, j, k, l, m = this._dialogInst; // internal instance
                // should use actual width/height below
                // move input on screen for focus, but hidden behind dialog
                return m || (this.uuid += 1, h = "dp" + this.uuid, this._dialogInput = a("<input type='text' id='" + h + "' style='position: absolute; top: -100px; width: 0px;'/>"), this._dialogInput.keydown(this._doKeyDown), a("body").append(this._dialogInput), m = this._dialogInst = this._newInst(this._dialogInput, !1), m.settings = {}, a.data(this._dialogInput[0], "datepicker", m)), f(m.settings, e || {}), c = c && c.constructor === Date ? this._formatDate(m, c) : c, this._dialogInput.val(c), this._pos = g ? g.length ? g : [g.pageX, g.pageY] : null, this._pos || (i = document.documentElement.clientWidth, j = document.documentElement.clientHeight, k = document.documentElement.scrollLeft || document.body.scrollLeft, l = document.documentElement.scrollTop || document.body.scrollTop, this._pos = [i / 2 - 100 + k, j / 2 - 150 + l]), this._dialogInput.css("left", this._pos[0] + 20 + "px").css("top", this._pos[1] + "px"), m.settings.onSelect = d, this._inDialog = !0, this.dpDiv.addClass(this._dialogClass), this._showDatepicker(this._dialogInput[0]), a.blockUI && a.blockUI(this.dpDiv), a.data(this._dialogInput[0], "datepicker", m), this
            },
            /* Detach a datepicker from its control.
             * @param  target	element - the target input field or division or span
             */
            _destroyDatepicker: function(b) {
                var c, d = a(b),
                    e = a.data(b, "datepicker");
                d.hasClass(this.markerClassName) && (c = b.nodeName.toLowerCase(), a.removeData(b, "datepicker"), "input" === c ? (e.append.remove(), e.trigger.remove(), d.removeClass(this.markerClassName).unbind("focus", this._showDatepicker).unbind("keydown", this._doKeyDown).unbind("keypress", this._doKeyPress).unbind("keyup", this._doKeyUp)) : "div" !== c && "span" !== c || d.removeClass(this.markerClassName).empty(), g === e && (g = null))
            },
            /* Enable the date picker to a jQuery selection.
             * @param  target	element - the target input field or division or span
             */
            _enableDatepicker: function(b) {
                var c, d, e = a(b),
                    f = a.data(b, "datepicker");
                e.hasClass(this.markerClassName) && (c = b.nodeName.toLowerCase(), "input" === c ? (b.disabled = !1, f.trigger.filter("button").each(function() {
                    this.disabled = !1
                }).end().filter("img").css({
                    opacity: "1.0",
                    cursor: ""
                })) : "div" !== c && "span" !== c || (d = e.children("." + this._inlineClass), d.children().removeClass("ui-state-disabled"), d.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled", !1)), this._disabledInputs = a.map(this._disabledInputs, function(a) {
                    return a === b ? null : a
                }))
            },
            /* Disable the date picker to a jQuery selection.
             * @param  target	element - the target input field or division or span
             */
            _disableDatepicker: function(b) {
                var c, d, e = a(b),
                    f = a.data(b, "datepicker");
                e.hasClass(this.markerClassName) && (c = b.nodeName.toLowerCase(), "input" === c ? (b.disabled = !0, f.trigger.filter("button").each(function() {
                    this.disabled = !0
                }).end().filter("img").css({
                    opacity: "0.5",
                    cursor: "default"
                })) : "div" !== c && "span" !== c || (d = e.children("." + this._inlineClass), d.children().addClass("ui-state-disabled"), d.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled", !0)), this._disabledInputs = a.map(this._disabledInputs, function(a) {
                    return a === b ? null : a
                }), this._disabledInputs[this._disabledInputs.length] = b)
            },
            /* Is the first field in a jQuery collection disabled as a datepicker?
             * @param  target	element - the target input field or division or span
             * @return boolean - true if disabled, false if enabled
             */
            _isDisabledDatepicker: function(a) {
                if (!a) return !1;
                for (var b = 0; b < this._disabledInputs.length; b++)
                    if (this._disabledInputs[b] === a) return !0;
                return !1
            },
            /* Retrieve the instance data for the target control.
             * @param  target  element - the target input field or division or span
             * @return  object - the associated instance data
             * @throws  error if a jQuery problem getting data
             */
            _getInst: function(b) {
                try {
                    return a.data(b, "datepicker")
                } catch (c) {
                    throw "Missing instance data for this datepicker"
                }
            },
            /* Update or retrieve the settings for a date picker attached to an input field or division.
             * @param  target  element - the target input field or division or span
             * @param  name	object - the new settings to update or
             *				string - the name of the setting to change or retrieve,
             *				when retrieving also "all" for all instance settings or
             *				"defaults" for all global defaults
             * @param  value   any - the new value for the setting
             *				(omit if above is an object or to retrieve a value)
             */
            _optionDatepicker: function(b, c, d) {
                var e, g, h, i, j = this._getInst(b);
                // reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
                return 2 === arguments.length && "string" == typeof c ? "defaults" === c ? a.extend({}, a.datepicker._defaults) : j ? "all" === c ? a.extend({}, j.settings) : this._get(j, c) : null : (e = c || {}, "string" == typeof c && (e = {}, e[c] = d), void(j && (this._curInst === j && this._hideDatepicker(), g = this._getDateDatepicker(b, !0), h = this._getMinMaxDate(j, "min"), i = this._getMinMaxDate(j, "max"), f(j.settings, e), null !== h && void 0 !== e.dateFormat && void 0 === e.minDate && (j.settings.minDate = this._formatDate(j, h)), null !== i && void 0 !== e.dateFormat && void 0 === e.maxDate && (j.settings.maxDate = this._formatDate(j, i)), "disabled" in e && (e.disabled ? this._disableDatepicker(b) : this._enableDatepicker(b)), this._attachments(a(b), j), this._autoSize(j), this._setDate(j, g), this._updateAlternate(j), this._updateDatepicker(j))))
            },
            // change method deprecated
            _changeDatepicker: function(a, b, c) {
                this._optionDatepicker(a, b, c)
            },
            /* Redraw the date picker attached to an input field or division.
             * @param  target  element - the target input field or division or span
             */
            _refreshDatepicker: function(a) {
                var b = this._getInst(a);
                b && this._updateDatepicker(b)
            },
            /* Set the dates for a jQuery selection.
             * @param  target element - the target input field or division or span
             * @param  date	Date - the new date
             */
            _setDateDatepicker: function(a, b) {
                var c = this._getInst(a);
                c && (this._setDate(c, b), this._updateDatepicker(c), this._updateAlternate(c))
            },
            /* Get the date(s) for the first entry in a jQuery selection.
             * @param  target element - the target input field or division or span
             * @param  noDefault boolean - true if no default date is to be used
             * @return Date - the current date
             */
            _getDateDatepicker: function(a, b) {
                var c = this._getInst(a);
                return c && !c.inline && this._setDateFromField(c, b), c ? this._getDate(c) : null
            },
            /* Handle keystrokes. */
            _doKeyDown: function(b) {
                var c, d, e, f = a.datepicker._getInst(b.target),
                    g = !0,
                    h = f.dpDiv.is(".ui-datepicker-rtl");
                if (f._keyEvent = !0, a.datepicker._datepickerShowing) switch (b.keyCode) {
                    case 9:
                        a.datepicker._hideDatepicker(), g = !1;
                        break; // hide on tab out
                    case 13:
                        // trigger custom callback
                        return e = a("td." + a.datepicker._dayOverClass + ":not(." + a.datepicker._currentClass + ")", f.dpDiv), e[0] && a.datepicker._selectDay(b.target, f.selectedMonth, f.selectedYear, e[0]), c = a.datepicker._get(f, "onSelect"), c ? (d = a.datepicker._formatDate(f), c.apply(f.input ? f.input[0] : null, [d, f])) : a.datepicker._hideDatepicker(), !1; // don't submit the form
                    case 27:
                        a.datepicker._hideDatepicker();
                        break; // hide on escape
                    case 33:
                        a.datepicker._adjustDate(b.target, b.ctrlKey ? -a.datepicker._get(f, "stepBigMonths") : -a.datepicker._get(f, "stepMonths"), "M");
                        break; // previous month/year on page up/+ ctrl
                    case 34:
                        a.datepicker._adjustDate(b.target, b.ctrlKey ? +a.datepicker._get(f, "stepBigMonths") : +a.datepicker._get(f, "stepMonths"), "M");
                        break; // next month/year on page down/+ ctrl
                    case 35:
                        (b.ctrlKey || b.metaKey) && a.datepicker._clearDate(b.target), g = b.ctrlKey || b.metaKey;
                        break; // clear on ctrl or command +end
                    case 36:
                        (b.ctrlKey || b.metaKey) && a.datepicker._gotoToday(b.target), g = b.ctrlKey || b.metaKey;
                        break; // current on ctrl or command +home
                    case 37:
                        (b.ctrlKey || b.metaKey) && a.datepicker._adjustDate(b.target, h ? 1 : -1, "D"), g = b.ctrlKey || b.metaKey,
                            // -1 day on ctrl or command +left
                            b.originalEvent.altKey && a.datepicker._adjustDate(b.target, b.ctrlKey ? -a.datepicker._get(f, "stepBigMonths") : -a.datepicker._get(f, "stepMonths"), "M");
                        // next month/year on alt +left on Mac
                        break;
                    case 38:
                        (b.ctrlKey || b.metaKey) && a.datepicker._adjustDate(b.target, -7, "D"), g = b.ctrlKey || b.metaKey;
                        break; // -1 week on ctrl or command +up
                    case 39:
                        (b.ctrlKey || b.metaKey) && a.datepicker._adjustDate(b.target, h ? -1 : 1, "D"), g = b.ctrlKey || b.metaKey,
                            // +1 day on ctrl or command +right
                            b.originalEvent.altKey && a.datepicker._adjustDate(b.target, b.ctrlKey ? +a.datepicker._get(f, "stepBigMonths") : +a.datepicker._get(f, "stepMonths"), "M");
                        // next month/year on alt +right
                        break;
                    case 40:
                        (b.ctrlKey || b.metaKey) && a.datepicker._adjustDate(b.target, 7, "D"), g = b.ctrlKey || b.metaKey;
                        break; // +1 week on ctrl or command +down
                    default:
                        g = !1
                } else 36 === b.keyCode && b.ctrlKey ? // display the date picker on ctrl+home
                    a.datepicker._showDatepicker(this) : g = !1;
                g && (b.preventDefault(), b.stopPropagation())
            },
            /* Filter entered characters - based on date format. */
            _doKeyPress: function(b) {
                var c, d, e = a.datepicker._getInst(b.target);
                return a.datepicker._get(e, "constrainInput") ? (c = a.datepicker._possibleChars(a.datepicker._get(e, "dateFormat")), d = String.fromCharCode(null == b.charCode ? b.keyCode : b.charCode), b.ctrlKey || b.metaKey || " " > d || !c || c.indexOf(d) > -1) : void 0
            },
            /* Synchronise manual entry and field/alternate field. */
            _doKeyUp: function(b) {
                var c, d = a.datepicker._getInst(b.target);
                if (d.input.val() !== d.lastVal) try {
                    c = a.datepicker.parseDate(a.datepicker._get(d, "dateFormat"), d.input ? d.input.val() : null, a.datepicker._getFormatConfig(d)), c && ( // only if valid
                        a.datepicker._setDateFromField(d), a.datepicker._updateAlternate(d), a.datepicker._updateDatepicker(d))
                } catch (e) {}
                return !0
            },
            /* Pop-up the date picker for a given input field.
             * If false returned from beforeShow event handler do not show.
             * @param  input  element - the input field attached to the date picker or
             *					event - if triggered by focus
             */
            _showDatepicker: function(c) {
                if (c = c.target || c, "input" !== c.nodeName.toLowerCase() && (c = a("input", c.parentNode)[0]), !a.datepicker._isDisabledDatepicker(c) && a.datepicker._lastInput !== c) {
                    var d, e, g, h, i, j, k;
                    d = a.datepicker._getInst(c), a.datepicker._curInst && a.datepicker._curInst !== d && (a.datepicker._curInst.dpDiv.stop(!0, !0), d && a.datepicker._datepickerShowing && a.datepicker._hideDatepicker(a.datepicker._curInst.input[0])), e = a.datepicker._get(d, "beforeShow"), g = e ? e.apply(c, [c, d]) : {}, g !== !1 && (f(d.settings, g), d.lastVal = null, a.datepicker._lastInput = c, a.datepicker._setDateFromField(d), a.datepicker._inDialog && ( // hide cursor
                        c.value = ""), a.datepicker._pos || ( // position below input
                        a.datepicker._pos = a.datepicker._findPos(c), a.datepicker._pos[1] += c.offsetHeight), h = !1, a(c).parents().each(function() {
                        return h |= "fixed" === a(this).css("position"), !h
                    }), i = {
                        left: a.datepicker._pos[0],
                        top: a.datepicker._pos[1]
                    }, a.datepicker._pos = null, d.dpDiv.empty(), d.dpDiv.css({
                        position: "absolute",
                        display: "block",
                        top: "-1000px"
                    }), a.datepicker._updateDatepicker(d), i = a.datepicker._checkOffset(d, i, h), d.dpDiv.css({
                        position: a.datepicker._inDialog && a.blockUI ? "static" : h ? "fixed" : "absolute",
                        display: "none",
                        left: i.left + "px",
                        top: i.top + "px"
                    }), d.inline || (j = a.datepicker._get(d, "showAnim"), k = a.datepicker._get(d, "duration"), d.dpDiv.css("z-index", b(a(c)) + 1), a.datepicker._datepickerShowing = !0, a.effects && a.effects.effect[j] ? d.dpDiv.show(j, a.datepicker._get(d, "showOptions"), k) : d.dpDiv[j || "show"](j ? k : null), a.datepicker._shouldFocusInput(d) && d.input.focus(), a.datepicker._curInst = d))
                }
            },
            /* Generate the date picker content. */
            _updateDatepicker: function(b) {
                this.maxRows = 4, g = b, b.dpDiv.empty().append(this._generateHTML(b)), this._attachHandlers(b);
                var c, d = this._getNumberOfMonths(b),
                    f = d[1],
                    h = 17,
                    i = b.dpDiv.find("." + this._dayOverClass + " a");
                i.length > 0 && e.apply(i.get(0)), b.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width(""), f > 1 && b.dpDiv.addClass("ui-datepicker-multi-" + f).css("width", h * f + "em"), b.dpDiv[(1 !== d[0] || 1 !== d[1] ? "add" : "remove") + "Class"]("ui-datepicker-multi"), b.dpDiv[(this._get(b, "isRTL") ? "add" : "remove") + "Class"]("ui-datepicker-rtl"), b === a.datepicker._curInst && a.datepicker._datepickerShowing && a.datepicker._shouldFocusInput(b) && b.input.focus(),
                    // deffered render of the years select (to avoid flashes on Firefox)
                    b.yearshtml && (c = b.yearshtml, setTimeout(function() {
                        c === b.yearshtml && b.yearshtml && b.dpDiv.find("select.ui-datepicker-year:first").replaceWith(b.yearshtml), c = b.yearshtml = null
                    }, 0))
            },
            // #6694 - don't focus the input if it's already focused
            // this breaks the change event in IE
            // Support: IE and jQuery <1.9
            _shouldFocusInput: function(a) {
                return a.input && a.input.is(":visible") && !a.input.is(":disabled") && !a.input.is(":focus")
            },
            /* Check positioning to remain on screen. */
            _checkOffset: function(b, c, d) {
                var e = b.dpDiv.outerWidth(),
                    f = b.dpDiv.outerHeight(),
                    g = b.input ? b.input.outerWidth() : 0,
                    h = b.input ? b.input.outerHeight() : 0,
                    i = document.documentElement.clientWidth + (d ? 0 : a(document).scrollLeft()),
                    j = document.documentElement.clientHeight + (d ? 0 : a(document).scrollTop());
                // now check if datepicker is showing outside window viewport - move to a better place if so.
                return c.left -= this._get(b, "isRTL") ? e - g : 0, c.left -= d && c.left === b.input.offset().left ? a(document).scrollLeft() : 0, c.top -= d && c.top === b.input.offset().top + h ? a(document).scrollTop() : 0, c.left -= Math.min(c.left, c.left + e > i && i > e ? Math.abs(c.left + e - i) : 0), c.top -= Math.min(c.top, c.top + f > j && j > f ? Math.abs(f + h) : 0), c
            },
            /* Find an object's position on the screen. */
            _findPos: function(b) {
                for (var c, d = this._getInst(b), e = this._get(d, "isRTL"); b && ("hidden" === b.type || 1 !== b.nodeType || a.expr.filters.hidden(b));) b = b[e ? "previousSibling" : "nextSibling"];
                return c = a(b).offset(), [c.left, c.top]
            },
            /* Hide the date picker from view.
             * @param  input  element - the input field attached to the date picker
             */
            _hideDatepicker: function(b) {
                var c, d, e, f, g = this._curInst;
                !g || b && g !== a.data(b, "datepicker") || this._datepickerShowing && (c = this._get(g, "showAnim"), d = this._get(g, "duration"), e = function() {
                    a.datepicker._tidyDialog(g)
                }, a.effects && (a.effects.effect[c] || a.effects[c]) ? g.dpDiv.hide(c, a.datepicker._get(g, "showOptions"), d, e) : g.dpDiv["slideDown" === c ? "slideUp" : "fadeIn" === c ? "fadeOut" : "hide"](c ? d : null, e), c || e(), this._datepickerShowing = !1, f = this._get(g, "onClose"), f && f.apply(g.input ? g.input[0] : null, [g.input ? g.input.val() : "", g]), this._lastInput = null, this._inDialog && (this._dialogInput.css({
                    position: "absolute",
                    left: "0",
                    top: "-100px"
                }), a.blockUI && (a.unblockUI(), a("body").append(this.dpDiv))), this._inDialog = !1)
            },
            /* Tidy up after a dialog display. */
            _tidyDialog: function(a) {
                a.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar")
            },
            /* Close date picker if clicked elsewhere. */
            _checkExternalClick: function(b) {
                if (a.datepicker._curInst) {
                    var c = a(b.target),
                        d = a.datepicker._getInst(c[0]);
                    (c[0].id === a.datepicker._mainDivId || 0 !== c.parents("#" + a.datepicker._mainDivId).length || c.hasClass(a.datepicker.markerClassName) || c.closest("." + a.datepicker._triggerClass).length || !a.datepicker._datepickerShowing || a.datepicker._inDialog && a.blockUI) && (!c.hasClass(a.datepicker.markerClassName) || a.datepicker._curInst === d) || a.datepicker._hideDatepicker()
                }
            },
            /* Adjust one of the date sub-fields. */
            _adjustDate: function(b, c, d) {
                var e = a(b),
                    f = this._getInst(e[0]);
                this._isDisabledDatepicker(e[0]) || (this._adjustInstDate(f, c + ("M" === d ? this._get(f, "showCurrentAtPos") : 0), // undo positioning
                    d), this._updateDatepicker(f))
            },
            /* Action for current link. */
            _gotoToday: function(b) {
                var c, d = a(b),
                    e = this._getInst(d[0]);
                this._get(e, "gotoCurrent") && e.currentDay ? (e.selectedDay = e.currentDay, e.drawMonth = e.selectedMonth = e.currentMonth, e.drawYear = e.selectedYear = e.currentYear) : (c = new Date, e.selectedDay = c.getDate(), e.drawMonth = e.selectedMonth = c.getMonth(), e.drawYear = e.selectedYear = c.getFullYear()), this._notifyChange(e), this._adjustDate(d)
            },
            /* Action for selecting a new month/year. */
            _selectMonthYear: function(b, c, d) {
                var e = a(b),
                    f = this._getInst(e[0]);
                f["selected" + ("M" === d ? "Month" : "Year")] = f["draw" + ("M" === d ? "Month" : "Year")] = parseInt(c.options[c.selectedIndex].value, 10), this._notifyChange(f), this._adjustDate(e)
            },
            /* Action for selecting a day. */
            _selectDay: function(b, c, d, e) {
                var f, g = a(b);
                a(e).hasClass(this._unselectableClass) || this._isDisabledDatepicker(g[0]) || (f = this._getInst(g[0]), f.selectedDay = f.currentDay = a("a", e).html(), f.selectedMonth = f.currentMonth = c, f.selectedYear = f.currentYear = d, this._selectDate(b, this._formatDate(f, f.currentDay, f.currentMonth, f.currentYear)))
            },
            /* Erase the input field and hide the date picker. */
            _clearDate: function(b) {
                var c = a(b);
                this._selectDate(c, "")
            },
            /* Update the input field with the selected date. */
            _selectDate: function(b, c) {
                var d, e = a(b),
                    f = this._getInst(e[0]);
                c = null != c ? c : this._formatDate(f), f.input && f.input.val(c), this._updateAlternate(f), d = this._get(f, "onSelect"), d ? d.apply(f.input ? f.input[0] : null, [c, f]) : f.input && f.input.trigger("change"), f.inline ? this._updateDatepicker(f) : (this._hideDatepicker(), this._lastInput = f.input[0], "object" != typeof f.input[0] && f.input.focus(), this._lastInput = null)
            },
            /* Update any alternate field to synchronise with the main field. */
            _updateAlternate: function(b) {
                var c, d, e, f = this._get(b, "altField");
                f && (c = this._get(b, "altFormat") || this._get(b, "dateFormat"), d = this._getDate(b), e = this.formatDate(c, d, this._getFormatConfig(b)), a(f).each(function() {
                    a(this).val(e)
                }))
            },
            /* Set as beforeShowDay function to prevent selection of weekends.
             * @param  date  Date - the date to customise
             * @return [boolean, string] - is this date selectable?, what is its CSS class?
             */
            noWeekends: function(a) {
                var b = a.getDay();
                return [b > 0 && 6 > b, ""]
            },
            /* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
             * @param  date  Date - the date to get the week for
             * @return  number - the number of the week within the year that contains this date
             */
            iso8601Week: function(a) {
                var b, c = new Date(a.getTime());
                // Find Thursday of this week starting on Monday
                // Compare with Jan 1
                return c.setDate(c.getDate() + 4 - (c.getDay() || 7)), b = c.getTime(), c.setMonth(0), c.setDate(1), Math.floor(Math.round((b - c) / 864e5) / 7) + 1
            },
            /* Parse a string value into a date object.
             * See formatDate below for the possible formats.
             *
             * @param  format string - the expected format of the date
             * @param  value string - the date in the above format
             * @param  settings Object - attributes include:
             *					shortYearCutoff  number - the cutoff year for determining the century (optional)
             *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
             *					dayNames		string[7] - names of the days from Sunday (optional)
             *					monthNamesShort string[12] - abbreviated names of the months (optional)
             *					monthNames		string[12] - names of the months (optional)
             * @return  Date - the extracted date value or null if value is blank
             */
            parseDate: function(b, c, d) {
                if (null == b || null == c) throw "Invalid arguments";
                if (c = "object" == typeof c ? c.toString() : c + "", "" === c) return null;
                var e, f, g, h, i = 0,
                    j = (d ? d.shortYearCutoff : null) || this._defaults.shortYearCutoff,
                    k = "string" != typeof j ? j : (new Date).getFullYear() % 100 + parseInt(j, 10),
                    l = (d ? d.dayNamesShort : null) || this._defaults.dayNamesShort,
                    m = (d ? d.dayNames : null) || this._defaults.dayNames,
                    n = (d ? d.monthNamesShort : null) || this._defaults.monthNamesShort,
                    o = (d ? d.monthNames : null) || this._defaults.monthNames,
                    p = -1,
                    q = -1,
                    r = -1,
                    s = -1,
                    t = !1,
                    // Check whether a format character is doubled
                    u = function(a) {
                        var c = e + 1 < b.length && b.charAt(e + 1) === a;
                        return c && e++, c
                    },
                    // Extract a number from the string value
                    v = function(a) {
                        var b = u(a),
                            d = "@" === a ? 14 : "!" === a ? 20 : "y" === a && b ? 4 : "o" === a ? 3 : 2,
                            e = "y" === a ? d : 1,
                            f = new RegExp("^\\d{" + e + "," + d + "}"),
                            g = c.substring(i).match(f);
                        if (!g) throw "Missing number at position " + i;
                        return i += g[0].length, parseInt(g[0], 10)
                    },
                    // Extract a name from the string value and convert to an index
                    w = function(b, d, e) {
                        var f = -1,
                            g = a.map(u(b) ? e : d, function(a, b) {
                                return [
                                    [b, a]
                                ]
                            }).sort(function(a, b) {
                                return -(a[1].length - b[1].length)
                            });
                        if (a.each(g, function(a, b) {
                                var d = b[1];
                                return c.substr(i, d.length).toLowerCase() === d.toLowerCase() ? (f = b[0], i += d.length, !1) : void 0
                            }), -1 !== f) return f + 1;
                        throw "Unknown name at position " + i
                    },
                    // Confirm that a literal character matches the string value
                    x = function() {
                        if (c.charAt(i) !== b.charAt(e)) throw "Unexpected literal at position " + i;
                        i++
                    };
                for (e = 0; e < b.length; e++)
                    if (t) "'" !== b.charAt(e) || u("'") ? x() : t = !1;
                    else switch (b.charAt(e)) {
                        case "d":
                            r = v("d");
                            break;
                        case "D":
                            w("D", l, m);
                            break;
                        case "o":
                            s = v("o");
                            break;
                        case "m":
                            q = v("m");
                            break;
                        case "M":
                            q = w("M", n, o);
                            break;
                        case "y":
                            p = v("y");
                            break;
                        case "@":
                            h = new Date(v("@")), p = h.getFullYear(), q = h.getMonth() + 1, r = h.getDate();
                            break;
                        case "!":
                            h = new Date((v("!") - this._ticksTo1970) / 1e4), p = h.getFullYear(), q = h.getMonth() + 1, r = h.getDate();
                            break;
                        case "'":
                            u("'") ? x() : t = !0;
                            break;
                        default:
                            x()
                    }
                    if (i < c.length && (g = c.substr(i), !/^\s+/.test(g))) throw "Extra/unparsed characters found in date: " + g;
                if (-1 === p ? p = (new Date).getFullYear() : 100 > p && (p += (new Date).getFullYear() - (new Date).getFullYear() % 100 + (k >= p ? 0 : -100)), s > -1)
                    for (q = 1, r = s;;) {
                        if (f = this._getDaysInMonth(p, q - 1), f >= r) break;
                        q++, r -= f
                    }
                if (h = this._daylightSavingAdjust(new Date(p, q - 1, r)), h.getFullYear() !== p || h.getMonth() + 1 !== q || h.getDate() !== r) throw "Invalid date";
                return h
            },
            /* Standard date formats. */
            ATOM: "yy-mm-dd", // RFC 3339 (ISO 8601)
            COOKIE: "D, dd M yy",
            ISO_8601: "yy-mm-dd",
            RFC_822: "D, d M y",
            RFC_850: "DD, dd-M-y",
            RFC_1036: "D, d M y",
            RFC_1123: "D, d M yy",
            RFC_2822: "D, d M yy",
            RSS: "D, d M y", // RFC 822
            TICKS: "!",
            TIMESTAMP: "@",
            W3C: "yy-mm-dd", // ISO 8601
            _ticksTo1970: 24 * (718685 + Math.floor(492.5) - Math.floor(19.7) + Math.floor(4.925)) * 60 * 60 * 1e7,
            /* Format a date object into a string value.
             * The format can be combinations of the following:
             * d  - day of month (no leading zero)
             * dd - day of month (two digit)
             * o  - day of year (no leading zeros)
             * oo - day of year (three digit)
             * D  - day name short
             * DD - day name long
             * m  - month of year (no leading zero)
             * mm - month of year (two digit)
             * M  - month name short
             * MM - month name long
             * y  - year (two digit)
             * yy - year (four digit)
             * @ - Unix timestamp (ms since 01/01/1970)
             * ! - Windows ticks (100ns since 01/01/0001)
             * "..." - literal text
             * '' - single quote
             *
             * @param  format string - the desired format of the date
             * @param  date Date - the date value to format
             * @param  settings Object - attributes include:
             *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
             *					dayNames		string[7] - names of the days from Sunday (optional)
             *					monthNamesShort string[12] - abbreviated names of the months (optional)
             *					monthNames		string[12] - names of the months (optional)
             * @return  string - the date in the above format
             */
            formatDate: function(a, b, c) {
                if (!b) return "";
                var d, e = (c ? c.dayNamesShort : null) || this._defaults.dayNamesShort,
                    f = (c ? c.dayNames : null) || this._defaults.dayNames,
                    g = (c ? c.monthNamesShort : null) || this._defaults.monthNamesShort,
                    h = (c ? c.monthNames : null) || this._defaults.monthNames,
                    // Check whether a format character is doubled
                    i = function(b) {
                        var c = d + 1 < a.length && a.charAt(d + 1) === b;
                        return c && d++, c
                    },
                    // Format a number, with leading zero if necessary
                    j = function(a, b, c) {
                        var d = "" + b;
                        if (i(a))
                            for (; d.length < c;) d = "0" + d;
                        return d
                    },
                    // Format a name, short or long as requested
                    k = function(a, b, c, d) {
                        return i(a) ? d[b] : c[b]
                    },
                    l = "",
                    m = !1;
                if (b)
                    for (d = 0; d < a.length; d++)
                        if (m) "'" !== a.charAt(d) || i("'") ? l += a.charAt(d) : m = !1;
                        else switch (a.charAt(d)) {
                            case "d":
                                l += j("d", b.getDate(), 2);
                                break;
                            case "D":
                                l += k("D", b.getDay(), e, f);
                                break;
                            case "o":
                                l += j("o", Math.round((new Date(b.getFullYear(), b.getMonth(), b.getDate()).getTime() - new Date(b.getFullYear(), 0, 0).getTime()) / 864e5), 3);
                                break;
                            case "m":
                                l += j("m", b.getMonth() + 1, 2);
                                break;
                            case "M":
                                l += k("M", b.getMonth(), g, h);
                                break;
                            case "y":
                                l += i("y") ? b.getFullYear() : (b.getYear() % 100 < 10 ? "0" : "") + b.getYear() % 100;
                                break;
                            case "@":
                                l += b.getTime();
                                break;
                            case "!":
                                l += 1e4 * b.getTime() + this._ticksTo1970;
                                break;
                            case "'":
                                i("'") ? l += "'" : m = !0;
                                break;
                            default:
                                l += a.charAt(d)
                        }
                        return l
            },
            /* Extract all possible characters from the date format. */
            _possibleChars: function(a) {
                var b, c = "",
                    d = !1,
                    // Check whether a format character is doubled
                    e = function(c) {
                        var d = b + 1 < a.length && a.charAt(b + 1) === c;
                        return d && b++, d
                    };
                for (b = 0; b < a.length; b++)
                    if (d) "'" !== a.charAt(b) || e("'") ? c += a.charAt(b) : d = !1;
                    else switch (a.charAt(b)) {
                        case "d":
                        case "m":
                        case "y":
                        case "@":
                            c += "0123456789";
                            break;
                        case "D":
                        case "M":
                            return null; // Accept anything
                        case "'":
                            e("'") ? c += "'" : d = !0;
                            break;
                        default:
                            c += a.charAt(b)
                    }
                    return c
            },
            /* Get a setting value, defaulting if necessary. */
            _get: function(a, b) {
                return void 0 !== a.settings[b] ? a.settings[b] : this._defaults[b]
            },
            /* Parse existing date and initialise date picker. */
            _setDateFromField: function(a, b) {
                if (a.input.val() !== a.lastVal) {
                    var c = this._get(a, "dateFormat"),
                        d = a.lastVal = a.input ? a.input.val() : null,
                        e = this._getDefaultDate(a),
                        f = e,
                        g = this._getFormatConfig(a);
                    try {
                        f = this.parseDate(c, d, g) || e
                    } catch (h) {
                        d = b ? "" : d
                    }
                    a.selectedDay = f.getDate(), a.drawMonth = a.selectedMonth = f.getMonth(), a.drawYear = a.selectedYear = f.getFullYear(), a.currentDay = d ? f.getDate() : 0, a.currentMonth = d ? f.getMonth() : 0, a.currentYear = d ? f.getFullYear() : 0, this._adjustInstDate(a)
                }
            },
            /* Retrieve the default date shown on opening. */
            _getDefaultDate: function(a) {
                return this._restrictMinMax(a, this._determineDate(a, this._get(a, "defaultDate"), new Date))
            },
            /* A date may be specified as an exact value or a relative one. */
            _determineDate: function(b, c, d) {
                var e = function(a) {
                        var b = new Date;
                        return b.setDate(b.getDate() + a), b
                    },
                    f = function(c) {
                        try {
                            return a.datepicker.parseDate(a.datepicker._get(b, "dateFormat"), c, a.datepicker._getFormatConfig(b))
                        } catch (d) {}
                        for (var e = (c.toLowerCase().match(/^c/) ? a.datepicker._getDate(b) : null) || new Date, f = e.getFullYear(), g = e.getMonth(), h = e.getDate(), i = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g, j = i.exec(c); j;) {
                            switch (j[2] || "d") {
                                case "d":
                                case "D":
                                    h += parseInt(j[1], 10);
                                    break;
                                case "w":
                                case "W":
                                    h += 7 * parseInt(j[1], 10);
                                    break;
                                case "m":
                                case "M":
                                    g += parseInt(j[1], 10), h = Math.min(h, a.datepicker._getDaysInMonth(f, g));
                                    break;
                                case "y":
                                case "Y":
                                    f += parseInt(j[1], 10), h = Math.min(h, a.datepicker._getDaysInMonth(f, g))
                            }
                            j = i.exec(c)
                        }
                        return new Date(f, g, h)
                    },
                    g = null == c || "" === c ? d : "string" == typeof c ? f(c) : "number" == typeof c ? isNaN(c) ? d : e(c) : new Date(c.getTime());
                return g = g && "Invalid Date" === g.toString() ? d : g, g && (g.setHours(0), g.setMinutes(0), g.setSeconds(0), g.setMilliseconds(0)), this._daylightSavingAdjust(g)
            },
            /* Handle switch to/from daylight saving.
             * Hours may be non-zero on daylight saving cut-over:
             * > 12 when midnight changeover, but then cannot generate
             * midnight datetime, so jump to 1AM, otherwise reset.
             * @param  date  (Date) the date to check
             * @return  (Date) the corrected date
             */
            _daylightSavingAdjust: function(a) {
                return a ? (a.setHours(a.getHours() > 12 ? a.getHours() + 2 : 0), a) : null
            },
            /* Set the date(s) directly. */
            _setDate: function(a, b, c) {
                var d = !b,
                    e = a.selectedMonth,
                    f = a.selectedYear,
                    g = this._restrictMinMax(a, this._determineDate(a, b, new Date));
                a.selectedDay = a.currentDay = g.getDate(), a.drawMonth = a.selectedMonth = a.currentMonth = g.getMonth(), a.drawYear = a.selectedYear = a.currentYear = g.getFullYear(), e === a.selectedMonth && f === a.selectedYear || c || this._notifyChange(a), this._adjustInstDate(a), a.input && a.input.val(d ? "" : this._formatDate(a))
            },
            /* Retrieve the date(s) directly. */
            _getDate: function(a) {
                var b = !a.currentYear || a.input && "" === a.input.val() ? null : this._daylightSavingAdjust(new Date(a.currentYear, a.currentMonth, a.currentDay));
                return b
            },
            /* Attach the onxxx handlers.  These are declared statically so
             * they work with static code transformers like Caja.
             */
            _attachHandlers: function(b) {
                var c = this._get(b, "stepMonths"),
                    d = "#" + b.id.replace(/\\\\/g, "\\");
                b.dpDiv.find("[data-handler]").map(function() {
                    var b = {
                        prev: function() {
                            a.datepicker._adjustDate(d, -c, "M")
                        },
                        next: function() {
                            a.datepicker._adjustDate(d, +c, "M")
                        },
                        hide: function() {
                            a.datepicker._hideDatepicker()
                        },
                        today: function() {
                            a.datepicker._gotoToday(d)
                        },
                        selectDay: function() {
                            return a.datepicker._selectDay(d, +this.getAttribute("data-month"), +this.getAttribute("data-year"), this), !1
                        },
                        selectMonth: function() {
                            return a.datepicker._selectMonthYear(d, this, "M"), !1
                        },
                        selectYear: function() {
                            return a.datepicker._selectMonthYear(d, this, "Y"), !1
                        }
                    };
                    a(this).bind(this.getAttribute("data-event"), b[this.getAttribute("data-handler")])
                })
            },
            /* Generate the HTML for the current state of the date picker. */
            _generateHTML: function(a) {
                var b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O = new Date,
                    P = this._daylightSavingAdjust(new Date(O.getFullYear(), O.getMonth(), O.getDate())), // clear time
                    Q = this._get(a, "isRTL"),
                    R = this._get(a, "showButtonPanel"),
                    S = this._get(a, "hideIfNoPrevNext"),
                    T = this._get(a, "navigationAsDateFormat"),
                    U = this._getNumberOfMonths(a),
                    V = this._get(a, "showCurrentAtPos"),
                    W = this._get(a, "stepMonths"),
                    X = 1 !== U[0] || 1 !== U[1],
                    Y = this._daylightSavingAdjust(a.currentDay ? new Date(a.currentYear, a.currentMonth, a.currentDay) : new Date(9999, 9, 9)),
                    Z = this._getMinMaxDate(a, "min"),
                    $ = this._getMinMaxDate(a, "max"),
                    _ = a.drawMonth - V,
                    aa = a.drawYear;
                if (0 > _ && (_ += 12, aa--), $)
                    for (b = this._daylightSavingAdjust(new Date($.getFullYear(), $.getMonth() - U[0] * U[1] + 1, $.getDate())), b = Z && Z > b ? Z : b; this._daylightSavingAdjust(new Date(aa, _, 1)) > b;) _--, 0 > _ && (_ = 11, aa--);
                for (a.drawMonth = _, a.drawYear = aa, c = this._get(a, "prevText"), c = T ? this.formatDate(c, this._daylightSavingAdjust(new Date(aa, _ - W, 1)), this._getFormatConfig(a)) : c, d = this._canAdjustMonth(a, -1, aa, _) ? "<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click' title='" + c + "'><span class='ui-icon ui-icon-circle-triangle-" + (Q ? "e" : "w") + "'>" + c + "</span></a>" : S ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='" + c + "'><span class='ui-icon ui-icon-circle-triangle-" + (Q ? "e" : "w") + "'>" + c + "</span></a>", e = this._get(a, "nextText"), e = T ? this.formatDate(e, this._daylightSavingAdjust(new Date(aa, _ + W, 1)), this._getFormatConfig(a)) : e, f = this._canAdjustMonth(a, 1, aa, _) ? "<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click' title='" + e + "'><span class='ui-icon ui-icon-circle-triangle-" + (Q ? "w" : "e") + "'>" + e + "</span></a>" : S ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='" + e + "'><span class='ui-icon ui-icon-circle-triangle-" + (Q ? "w" : "e") + "'>" + e + "</span></a>", g = this._get(a, "currentText"), h = this._get(a, "gotoCurrent") && a.currentDay ? Y : P, g = T ? this.formatDate(g, h, this._getFormatConfig(a)) : g, i = a.inline ? "" : "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" + this._get(a, "closeText") + "</button>", j = R ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + (Q ? i : "") + (this._isInRange(a, h) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'>" + g + "</button>" : "") + (Q ? "" : i) + "</div>" : "", k = parseInt(this._get(a, "firstDay"), 10), k = isNaN(k) ? 0 : k, l = this._get(a, "showWeek"), m = this._get(a, "dayNames"), n = this._get(a, "dayNamesMin"), o = this._get(a, "monthNames"), p = this._get(a, "monthNamesShort"), q = this._get(a, "beforeShowDay"), r = this._get(a, "showOtherMonths"), s = this._get(a, "selectOtherMonths"), t = this._getDefaultDate(a), u = "", w = 0; w < U[0]; w++) {
                    for (x = "", this.maxRows = 4, y = 0; y < U[1]; y++) {
                        if (z = this._daylightSavingAdjust(new Date(aa, _, a.selectedDay)), A = " ui-corner-all", B = "", X) {
                            if (B += "<div class='ui-datepicker-group", U[1] > 1) switch (y) {
                                case 0:
                                    B += " ui-datepicker-group-first", A = " ui-corner-" + (Q ? "right" : "left");
                                    break;
                                case U[1] - 1:
                                    B += " ui-datepicker-group-last", A = " ui-corner-" + (Q ? "left" : "right");
                                    break;
                                default:
                                    B += " ui-datepicker-group-middle", A = ""
                            }
                            B += "'>"
                        }
                        for (B += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + A + "'>" + (/all|left/.test(A) && 0 === w ? Q ? f : d : "") + (/all|right/.test(A) && 0 === w ? Q ? d : f : "") + this._generateMonthYearHeader(a, _, aa, Z, $, w > 0 || y > 0, o, p) + // draw month headers
                            "</div><table class='ui-datepicker-calendar'><thead><tr>", C = l ? "<th class='ui-datepicker-week-col'>" + this._get(a, "weekHeader") + "</th>" : "", v = 0; 7 > v; v++) D = (v + k) % 7, C += "<th scope='col'" + ((v + k + 6) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "") + "><span title='" + m[D] + "'>" + n[D] + "</span></th>";
                        for (B += C + "</tr></thead><tbody>", E = this._getDaysInMonth(aa, _), aa === a.selectedYear && _ === a.selectedMonth && (a.selectedDay = Math.min(a.selectedDay, E)), F = (this._getFirstDayOfMonth(aa, _) - k + 7) % 7, G = Math.ceil((F + E) / 7), H = X && this.maxRows > G ? this.maxRows : G, this.maxRows = H, I = this._daylightSavingAdjust(new Date(aa, _, 1 - F)), J = 0; H > J; J++) {
                            for (B += "<tr>", K = l ? "<td class='ui-datepicker-week-col'>" + this._get(a, "calculateWeek")(I) + "</td>" : "", v = 0; 7 > v; v++) L = q ? q.apply(a.input ? a.input[0] : null, [I]) : [!0, ""], M = I.getMonth() !== _, N = M && !s || !L[0] || Z && Z > I || $ && I > $, K += "<td class='" + ((v + k + 6) % 7 >= 5 ? " ui-datepicker-week-end" : "") + (M ? " ui-datepicker-other-month" : "") + (I.getTime() === z.getTime() && _ === a.selectedMonth && a._keyEvent || t.getTime() === I.getTime() && t.getTime() === z.getTime() ? " " + this._dayOverClass : "") + (N ? " " + this._unselectableClass + " ui-state-disabled" : "") + (M && !r ? "" : " " + L[1] + (I.getTime() === Y.getTime() ? " " + this._currentClass : "") + (I.getTime() === P.getTime() ? " ui-datepicker-today" : "")) + "'" + (M && !r || !L[2] ? "" : " title='" + L[2].replace(/'/g, "&#39;") + "'") + (N ? "" : " data-handler='selectDay' data-event='click' data-month='" + I.getMonth() + "' data-year='" + I.getFullYear() + "'") + ">" + (M && !r ? "&#xa0;" : N ? "<span class='ui-state-default'>" + I.getDate() + "</span>" : "<a class='ui-state-default" + (I.getTime() === P.getTime() ? " ui-state-highlight" : "") + (I.getTime() === Y.getTime() ? " ui-state-active" : "") + (M ? " ui-priority-secondary" : "") + "' href='#'>" + I.getDate() + "</a>") + "</td>", I.setDate(I.getDate() + 1), I = this._daylightSavingAdjust(I);
                            B += K + "</tr>"
                        }
                        _++, _ > 11 && (_ = 0, aa++), B += "</tbody></table>" + (X ? "</div>" + (U[0] > 0 && y === U[1] - 1 ? "<div class='ui-datepicker-row-break'></div>" : "") : ""), x += B
                    }
                    u += x
                }
                return u += j, a._keyEvent = !1, u
            },
            /* Generate the month and year header. */
            _generateMonthYearHeader: function(a, b, c, d, e, f, g, h) {
                var i, j, k, l, m, n, o, p, q = this._get(a, "changeMonth"),
                    r = this._get(a, "changeYear"),
                    s = this._get(a, "showMonthAfterYear"),
                    t = "<div class='ui-datepicker-title'>",
                    u = "";
                // month selection
                if (f || !q) u += "<span class='ui-datepicker-month'>" + g[b] + "</span>";
                else {
                    for (i = d && d.getFullYear() === c, j = e && e.getFullYear() === c, u += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>", k = 0; 12 > k; k++)(!i || k >= d.getMonth()) && (!j || k <= e.getMonth()) && (u += "<option value='" + k + "'" + (k === b ? " selected='selected'" : "") + ">" + h[k] + "</option>");
                    u += "</select>"
                }
                // year selection
                if (s || (t += u + (!f && q && r ? "" : "&#xa0;")), !a.yearshtml)
                    if (a.yearshtml = "", f || !r) t += "<span class='ui-datepicker-year'>" + c + "</span>";
                    else {
                        for (
                            // determine range of years to display
                            l = this._get(a, "yearRange").split(":"), m = (new Date).getFullYear(), n = function(a) {
                                var b = a.match(/c[+\-].*/) ? c + parseInt(a.substring(1), 10) : a.match(/[+\-].*/) ? m + parseInt(a, 10) : parseInt(a, 10);
                                return isNaN(b) ? m : b
                            }, o = n(l[0]), p = Math.max(o, n(l[1] || "")), o = d ? Math.max(o, d.getFullYear()) : o, p = e ? Math.min(p, e.getFullYear()) : p, a.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>"; p >= o; o++) a.yearshtml += "<option value='" + o + "'" + (o === c ? " selected='selected'" : "") + ">" + o + "</option>";
                        a.yearshtml += "</select>", t += a.yearshtml, a.yearshtml = null
                    } // Close datepicker_header
                return t += this._get(a, "yearSuffix"), s && (t += (!f && q && r ? "" : "&#xa0;") + u), t += "</div>"
            },
            /* Adjust one of the date sub-fields. */
            _adjustInstDate: function(a, b, c) {
                var d = a.drawYear + ("Y" === c ? b : 0),
                    e = a.drawMonth + ("M" === c ? b : 0),
                    f = Math.min(a.selectedDay, this._getDaysInMonth(d, e)) + ("D" === c ? b : 0),
                    g = this._restrictMinMax(a, this._daylightSavingAdjust(new Date(d, e, f)));
                a.selectedDay = g.getDate(), a.drawMonth = a.selectedMonth = g.getMonth(), a.drawYear = a.selectedYear = g.getFullYear(), "M" !== c && "Y" !== c || this._notifyChange(a)
            },
            /* Ensure a date is within any min/max bounds. */
            _restrictMinMax: function(a, b) {
                var c = this._getMinMaxDate(a, "min"),
                    d = this._getMinMaxDate(a, "max"),
                    e = c && c > b ? c : b;
                return d && e > d ? d : e
            },
            /* Notify change of month/year. */
            _notifyChange: function(a) {
                var b = this._get(a, "onChangeMonthYear");
                b && b.apply(a.input ? a.input[0] : null, [a.selectedYear, a.selectedMonth + 1, a])
            },
            /* Determine the number of months to show. */
            _getNumberOfMonths: function(a) {
                var b = this._get(a, "numberOfMonths");
                return null == b ? [1, 1] : "number" == typeof b ? [1, b] : b
            },
            /* Determine the current maximum date - ensure no time components are set. */
            _getMinMaxDate: function(a, b) {
                return this._determineDate(a, this._get(a, b + "Date"), null)
            },
            /* Find the number of days in a given month. */
            _getDaysInMonth: function(a, b) {
                return 32 - this._daylightSavingAdjust(new Date(a, b, 32)).getDate()
            },
            /* Find the day of the week of the first of a month. */
            _getFirstDayOfMonth: function(a, b) {
                return new Date(a, b, 1).getDay()
            },
            /* Determines if we should allow a "next/prev" month display change. */
            _canAdjustMonth: function(a, b, c, d) {
                var e = this._getNumberOfMonths(a),
                    f = this._daylightSavingAdjust(new Date(c, d + (0 > b ? b : e[0] * e[1]), 1));
                return 0 > b && f.setDate(this._getDaysInMonth(f.getFullYear(), f.getMonth())), this._isInRange(a, f)
            },
            /* Is the given date in the accepted range? */
            _isInRange: function(a, b) {
                var c, d, e = this._getMinMaxDate(a, "min"),
                    f = this._getMinMaxDate(a, "max"),
                    g = null,
                    h = null,
                    i = this._get(a, "yearRange");
                return i && (c = i.split(":"), d = (new Date).getFullYear(), g = parseInt(c[0], 10), h = parseInt(c[1], 10), c[0].match(/[+\-].*/) && (g += d), c[1].match(/[+\-].*/) && (h += d)), (!e || b.getTime() >= e.getTime()) && (!f || b.getTime() <= f.getTime()) && (!g || b.getFullYear() >= g) && (!h || b.getFullYear() <= h)
            },
            /* Provide the configuration settings for formatting/parsing. */
            _getFormatConfig: function(a) {
                var b = this._get(a, "shortYearCutoff");
                return b = "string" != typeof b ? b : (new Date).getFullYear() % 100 + parseInt(b, 10), {
                    shortYearCutoff: b,
                    dayNamesShort: this._get(a, "dayNamesShort"),
                    dayNames: this._get(a, "dayNames"),
                    monthNamesShort: this._get(a, "monthNamesShort"),
                    monthNames: this._get(a, "monthNames")
                }
            },
            /* Format the given date for display. */
            _formatDate: function(a, b, c, d) {
                b || (a.currentDay = a.selectedDay, a.currentMonth = a.selectedMonth, a.currentYear = a.selectedYear);
                var e = b ? "object" == typeof b ? b : this._daylightSavingAdjust(new Date(d, c, b)) : this._daylightSavingAdjust(new Date(a.currentYear, a.currentMonth, a.currentDay));
                return this.formatDate(this._get(a, "dateFormat"), e, this._getFormatConfig(a))
            }
        }), a.fn.datepicker = function(b) { /* Verify an empty collection wasn't passed - Fixes #6976 */
            if (!this.length) return this; /* Initialise the date picker. */
            a.datepicker.initialized || (a(document).mousedown(a.datepicker._checkExternalClick), a.datepicker.initialized = !0), /* Append datepicker main container to body if not exist. */
                0 === a("#" + a.datepicker._mainDivId).length && a("body").append(a.datepicker.dpDiv);
            var c = Array.prototype.slice.call(arguments, 1);
            return "string" != typeof b || "isDisabled" !== b && "getDate" !== b && "widget" !== b ? "option" === b && 2 === arguments.length && "string" == typeof arguments[1] ? a.datepicker["_" + b + "Datepicker"].apply(a.datepicker, [this[0]].concat(c)) : this.each(function() {
                "string" == typeof b ? a.datepicker["_" + b + "Datepicker"].apply(a.datepicker, [this].concat(c)) : a.datepicker._attachDatepicker(this, b)
            }) : a.datepicker["_" + b + "Datepicker"].apply(a.datepicker, [this[0]].concat(c))
        }, a.datepicker = new c, a.datepicker.initialized = !1, a.datepicker.uuid = (new Date).getTime(), a.datepicker.version = "1.11.4", a.datepicker
    }),
    /*!
     * fancyBox - jQuery Plugin
     * version: 2.1.5 (Fri, 14 Jun 2013)
     * @requires jQuery v1.6 or later
     *
     * Examples at http://fancyapps.com/fancybox/
     * License: www.fancyapps.com/fancybox/#license
     *
     * Copyright 2012 Janis Skarnelis - janis@fancyapps.com
     *
     */
    function(a, b, c, d) {
        "use strict";
        var e = c("html"),
            f = c(a),
            g = c(b),
            h = c.fancybox = function() {
                h.open.apply(this, arguments)
            },
            i = navigator.userAgent.match(/msie/i),
            j = null,
            k = b.createTouch !== d,
            l = function(a) {
                return a && a.hasOwnProperty && a instanceof c
            },
            m = function(a) {
                return a && "string" === c.type(a)
            },
            n = function(a) {
                return m(a) && a.indexOf("%") > 0
            },
            o = function(a) {
                return a && !(a.style.overflow && "hidden" === a.style.overflow) && (a.clientWidth && a.scrollWidth > a.clientWidth || a.clientHeight && a.scrollHeight > a.clientHeight)
            },
            p = function(a, b) {
                var c = parseInt(a, 10) || 0;
                return b && n(a) && (c = h.getViewport()[b] / 100 * c), Math.ceil(c)
            },
            q = function(a, b) {
                return p(a, b) + "px"
            };
        c.extend(h, {
                // The current version of fancyBox
                version: "2.1.5",
                defaults: {
                    padding: 15,
                    margin: 20,
                    width: 800,
                    height: 600,
                    minWidth: 100,
                    minHeight: 100,
                    maxWidth: 9999,
                    maxHeight: 9999,
                    pixelRatio: 1, // Set to 2 for retina display support
                    autoSize: !0,
                    autoHeight: !1,
                    autoWidth: !1,
                    autoResize: !0,
                    autoCenter: !k,
                    fitToView: !0,
                    aspectRatio: !1,
                    topRatio: .5,
                    leftRatio: .5,
                    scrolling: "auto", // 'auto', 'yes' or 'no'
                    wrapCSS: "",
                    arrows: !0,
                    closeBtn: !0,
                    closeClick: !1,
                    nextClick: !1,
                    mouseWheel: !0,
                    autoPlay: !1,
                    playSpeed: 3e3,
                    preload: 3,
                    modal: !1,
                    loop: !0,
                    ajax: {
                        dataType: "html",
                        headers: {
                            "X-fancyBox": !0
                        }
                    },
                    iframe: {
                        scrolling: "auto",
                        preload: !0
                    },
                    swf: {
                        wmode: "transparent",
                        allowfullscreen: "true",
                        allowscriptaccess: "always"
                    },
                    keys: {
                        next: {
                            13: "left", // enter
                            34: "up", // page down
                            39: "left", // right arrow
                            40: "up"
                        },
                        prev: {
                            8: "right", // backspace
                            33: "down", // page up
                            37: "right", // left arrow
                            38: "down"
                        },
                        close: [27], // escape key
                        play: [32], // space - start/stop slideshow
                        toggle: [70]
                    },
                    direction: {
                        next: "left",
                        prev: "right"
                    },
                    scrollOutside: !0,
                    // Override some properties
                    index: 0,
                    type: null,
                    href: null,
                    content: null,
                    title: null,
                    // HTML templates
                    tpl: {
                        wrap: '<div class="fancybox-wrap" tabIndex="-1"><div class="fancybox-skin"><div class="fancybox-outer"><div class="fancybox-inner"></div></div></div></div>',
                        image: '<img class="fancybox-image" src="{href}" alt="" />',
                        iframe: '<iframe id="fancybox-frame{rnd}" name="fancybox-frame{rnd}" class="fancybox-iframe" frameborder="0" vspace="0" hspace="0" webkitAllowFullScreen mozallowfullscreen allowFullScreen' + (i ? ' allowtransparency="true"' : "") + "></iframe>",
                        error: '<p class="fancybox-error">The requested content cannot be loaded.<br/>Please try again later.</p>',
                        closeBtn: '<a title="Close" class="fancybox-item fancybox-close" href="javascript:;"></a>',
                        next: '<a title="Next" class="fancybox-nav fancybox-next" href="javascript:;"><span></span></a>',
                        prev: '<a title="Previous" class="fancybox-nav fancybox-prev" href="javascript:;"><span></span></a>'
                    },
                    // Properties for each animation type
                    // Opening fancyBox
                    openEffect: "fade", // 'elastic', 'fade' or 'none'
                    openSpeed: 250,
                    openEasing: "swing",
                    openOpacity: !0,
                    openMethod: "zoomIn",
                    // Closing fancyBox
                    closeEffect: "fade", // 'elastic', 'fade' or 'none'
                    closeSpeed: 250,
                    closeEasing: "swing",
                    closeOpacity: !0,
                    closeMethod: "zoomOut",
                    // Changing next gallery item
                    nextEffect: "elastic", // 'elastic', 'fade' or 'none'
                    nextSpeed: 250,
                    nextEasing: "swing",
                    nextMethod: "changeIn",
                    // Changing previous gallery item
                    prevEffect: "elastic", // 'elastic', 'fade' or 'none'
                    prevSpeed: 250,
                    prevEasing: "swing",
                    prevMethod: "changeOut",
                    // Enable default helpers
                    helpers: {
                        overlay: !0,
                        title: !0
                    },
                    // Callbacks
                    onCancel: c.noop, // If canceling
                    beforeLoad: c.noop, // Before loading
                    afterLoad: c.noop, // After loading
                    beforeShow: c.noop, // Before changing in current item
                    afterShow: c.noop, // After opening
                    beforeChange: c.noop, // Before changing gallery item
                    beforeClose: c.noop, // Before closing
                    afterClose: c.noop
                },
                //Current state
                group: {}, // Selected group
                opts: {}, // Group options
                previous: null, // Previous element
                coming: null, // Element being loaded
                current: null, // Currently loaded element
                isActive: !1, // Is activated
                isOpen: !1, // Is currently open
                isOpened: !1, // Have been fully opened at least once
                wrap: null,
                skin: null,
                outer: null,
                inner: null,
                player: {
                    timer: null,
                    isActive: !1
                },
                // Loaders
                ajaxLoad: null,
                imgPreload: null,
                // Some collections
                transitions: {},
                helpers: {},
                /*
                 *	Static methods
                 */
                open: function(a, b) {
                    // Normalize group
                    // Recheck if the type of each element is `object` and set content type (image, ajax, etc)
                    // Extend the defaults
                    // All options are merged recursive except keys
                    return a && (c.isPlainObject(b) || (b = {}), !1 !== h.close(!0)) ? (c.isArray(a) || (a = l(a) ? c(a).get() : [a]), c.each(a, function(e, f) {
                        var g, i, j, k, n, o, p, q = {};
                        "object" === c.type(f) && (
                            // Check if is DOM element
                            f.nodeType && (f = c(f)), l(f) ? (q = {
                                href: f.data("fancybox-href") || f.attr("href"),
                                title: f.data("fancybox-title") || f.attr("title"),
                                isDom: !0,
                                element: f
                            }, c.metadata && c.extend(!0, q, f.metadata())) : q = f), g = b.href || q.href || (m(f) ? f : null), i = b.title !== d ? b.title : q.title || "", j = b.content || q.content, k = j ? "html" : b.type || q.type, !k && q.isDom && (k = f.data("fancybox-type"), k || (n = f.prop("class").match(/fancybox\.(\w+)/), k = n ? n[1] : null)), m(g) && (k || (h.isImage(g) ? k = "image" : h.isSWF(g) ? k = "swf" : "#" === g.charAt(0) ? k = "inline" : m(f) && (k = "html", j = f)), "ajax" === k && (o = g.split(/\s+/, 2), g = o.shift(), p = o.shift())), j || ("inline" === k ? g ? j = c(m(g) ? g.replace(/.*(?=#[^\s]+$)/, "") : g) : q.isDom && (j = f) : "html" === k ? j = g : k || g || !q.isDom || (k = "inline", j = f)), c.extend(q, {
                            href: g,
                            type: k,
                            content: j,
                            title: i,
                            selector: p
                        }), a[e] = q
                    }), h.opts = c.extend(!0, {}, h.defaults, b), b.keys !== d && (h.opts.keys = b.keys ? c.extend({}, h.defaults.keys, b.keys) : !1), h.group = a, h._start(h.opts.index)) : void 0
                },
                // Cancel image loading or abort ajax request
                cancel: function() {
                    var a = h.coming;
                    a && !1 !== h.trigger("onCancel") && (h.hideLoading(), h.ajaxLoad && h.ajaxLoad.abort(), h.ajaxLoad = null, h.imgPreload && (h.imgPreload.onload = h.imgPreload.onerror = null), a.wrap && a.wrap.stop(!0, !0).trigger("onReset").remove(), h.coming = null,
                        // If the first item has been canceled, then clear everything
                        h.current || h._afterZoomOut(a))
                },
                // Start closing animation if is open; remove immediately if opening/closing
                close: function(a) {
                    h.cancel(), !1 !== h.trigger("beforeClose") && (h.unbindEvents(), h.isActive && (h.isOpen && a !== !0 ? (h.isOpen = h.isOpened = !1, h.isClosing = !0, c(".fancybox-item, .fancybox-nav").remove(), h.wrap.stop(!0, !0).removeClass("fancybox-opened"), h.transitions[h.current.closeMethod]()) : (c(".fancybox-wrap").stop(!0).trigger("onReset").remove(), h._afterZoomOut())))
                },
                // Manage slideshow:
                //   $.fancybox.play(); - toggle slideshow
                //   $.fancybox.play( true ); - start
                //   $.fancybox.play( false ); - stop
                play: function(a) {
                    var b = function() {
                            clearTimeout(h.player.timer)
                        },
                        c = function() {
                            b(), h.current && h.player.isActive && (h.player.timer = setTimeout(h.next, h.current.playSpeed))
                        },
                        d = function() {
                            b(), g.unbind(".player"), h.player.isActive = !1, h.trigger("onPlayEnd")
                        },
                        e = function() {
                            h.current && (h.current.loop || h.current.index < h.group.length - 1) && (h.player.isActive = !0, g.bind({
                                "onCancel.player beforeClose.player": d,
                                "onUpdate.player": c,
                                "beforeLoad.player": b
                            }), c(), h.trigger("onPlayStart"))
                        };
                    a === !0 || !h.player.isActive && a !== !1 ? e() : d()
                },
                // Navigate to next gallery item
                next: function(a) {
                    var b = h.current;
                    b && (m(a) || (a = b.direction.next), h.jumpto(b.index + 1, a, "next"))
                },
                // Navigate to previous gallery item
                prev: function(a) {
                    var b = h.current;
                    b && (m(a) || (a = b.direction.prev), h.jumpto(b.index - 1, a, "prev"))
                },
                // Navigate to gallery item by index
                jumpto: function(a, b, c) {
                    var e = h.current;
                    e && (a = p(a), h.direction = b || e.direction[a >= e.index ? "next" : "prev"], h.router = c || "jumpto", e.loop && (0 > a && (a = e.group.length + a % e.group.length), a %= e.group.length), e.group[a] !== d && (h.cancel(), h._start(a)))
                },
                // Center inside viewport and toggle position type to fixed or absolute if needed
                reposition: function(a, b) {
                    var d, e = h.current,
                        f = e ? e.wrap : null;
                    f && (d = h._getPosition(b), a && "scroll" === a.type ? (delete d.position, f.stop(!0, !0).animate(d, 200)) : (f.css(d), e.pos = c.extend({}, e.dim, d)))
                },
                update: function(a) {
                    var b = a && a.type,
                        c = !b || "orientationchange" === b;
                    c && (clearTimeout(j), j = null), h.isOpen && !j && (j = setTimeout(function() {
                        var d = h.current;
                        d && !h.isClosing && (h.wrap.removeClass("fancybox-tmp"), (c || "load" === b || "resize" === b && d.autoResize) && h._setDimension(), "scroll" === b && d.canShrink || h.reposition(a), h.trigger("onUpdate"), j = null)
                    }, c && !k ? 0 : 300))
                },
                // Shrink content to fit inside viewport or restore if resized
                toggle: function(a) {
                    h.isOpen && (h.current.fitToView = "boolean" === c.type(a) ? a : !h.current.fitToView,
                        // Help browser to restore document dimensions
                        k && (h.wrap.removeAttr("style").addClass("fancybox-tmp"), h.trigger("onUpdate")), h.update())
                },
                hideLoading: function() {
                    g.unbind(".loading"), c("#fancybox-loading").remove()
                },
                showLoading: function() {
                    var a, b;
                    h.hideLoading(), a = c('<div id="fancybox-loading"><div></div></div>').click(h.cancel).appendTo("body"), g.bind("keydown.loading", function(a) {
                        27 === (a.which || a.keyCode) && (a.preventDefault(), h.cancel())
                    }), h.defaults.fixed || (b = h.getViewport(), a.css({
                        position: "absolute",
                        top: .5 * b.h + b.y,
                        left: .5 * b.w + b.x
                    }))
                },
                getViewport: function() {
                    var b = h.current && h.current.locked || !1,
                        c = {
                            x: f.scrollLeft(),
                            y: f.scrollTop()
                        };
                    // See http://bugs.jquery.com/ticket/6724
                    return b ? (c.w = b[0].clientWidth, c.h = b[0].clientHeight) : (c.w = k && a.innerWidth ? a.innerWidth : f.width(), c.h = k && a.innerHeight ? a.innerHeight : f.height()), c
                },
                // Unbind the keyboard / clicking actions
                unbindEvents: function() {
                    h.wrap && l(h.wrap) && h.wrap.unbind(".fb"), g.unbind(".fb"), f.unbind(".fb")
                },
                bindEvents: function() {
                    var a, b = h.current;
                    b && (
                        // Changing document height on iOS devices triggers a 'resize' event,
                        // that can change document height... repeating infinitely
                        f.bind("orientationchange.fb" + (k ? "" : " resize.fb") + (b.autoCenter && !b.locked ? " scroll.fb" : ""), h.update), a = b.keys, a && g.bind("keydown.fb", function(e) {
                            var f = e.which || e.keyCode,
                                g = e.target || e.srcElement;
                            return 27 === f && h.coming ? !1 : void(e.ctrlKey || e.altKey || e.shiftKey || e.metaKey || g && (g.type || c(g).is("[contenteditable]")) || c.each(a, function(a, g) {
                                return b.group.length > 1 && g[f] !== d ? (h[a](g[f]), e.preventDefault(), !1) : c.inArray(f, g) > -1 ? (h[a](), e.preventDefault(), !1) : void 0
                            }))
                        }), c.fn.mousewheel && b.mouseWheel && h.wrap.bind("mousewheel.fb", function(a, d, e, f) {
                            for (var g = a.target || null, i = c(g), j = !1; i.length && !(j || i.is(".fancybox-skin") || i.is(".fancybox-wrap"));) j = o(i[0]), i = c(i).parent();
                            0 === d || j || h.group.length > 1 && !b.canShrink && (f > 0 || e > 0 ? h.prev(f > 0 ? "down" : "left") : (0 > f || 0 > e) && h.next(0 > f ? "up" : "right"), a.preventDefault())
                        }))
                },
                trigger: function(a, b) {
                    var d, e = b || h.coming || h.current;
                    if (e) {
                        if (c.isFunction(e[a]) && (d = e[a].apply(e, Array.prototype.slice.call(arguments, 1))), d === !1) return !1;
                        e.helpers && c.each(e.helpers, function(b, d) {
                            d && h.helpers[b] && c.isFunction(h.helpers[b][a]) && h.helpers[b][a](c.extend(!0, {}, h.helpers[b].defaults, d), e)
                        }), g.trigger(a)
                    }
                },
                isImage: function(a) {
                    return m(a) && a.match(/(^data:image\/.*,)|(\.(jp(e|g|eg)|gif|png|bmp|webp|svg)((\?|#).*)?$)/i)
                },
                isSWF: function(a) {
                    return m(a) && a.match(/\.(swf)((\?|#).*)?$/i)
                },
                _start: function(a) {
                    var b, d, e, f, g, i = {};
                    if (a = p(a), b = h.group[a] || null, !b) return !1;
                    if (i = c.extend(!0, {}, h.opts, b), f = i.margin, g = i.padding, "number" === c.type(f) && (i.margin = [f, f, f, f]), "number" === c.type(g) && (i.padding = [g, g, g, g]), i.modal && c.extend(!0, i, {
                            closeBtn: !1,
                            closeClick: !1,
                            nextClick: !1,
                            arrows: !1,
                            mouseWheel: !1,
                            keys: null,
                            helpers: {
                                overlay: {
                                    closeClick: !1
                                }
                            }
                        }), i.autoSize && (i.autoWidth = i.autoHeight = !0), "auto" === i.width && (i.autoWidth = !0), "auto" === i.height && (i.autoHeight = !0), i.group = h.group, i.index = a, h.coming = i, !1 === h.trigger("beforeLoad")) return void(h.coming = null);
                    if (e = i.type, d = i.href, !e)
                    //If we can not determine content type then drop silently or display next/prev item if looping through gallery
                    //If we can not determine content type then drop silently or display next/prev item if looping through gallery
                        return h.coming = null, h.current && h.router && "jumpto" !== h.router ? (h.current.index = a, h[h.router](h.direction)) : !1;
                    // Check before try to load; 'inline' and 'html' types need content, others - href
                    if (h.isActive = !0, "image" !== e && "swf" !== e || (i.autoHeight = i.autoWidth = !1, i.scrolling = "visible"), "image" === e && (i.aspectRatio = !0), "iframe" === e && k && (i.scrolling = "scroll"),
                        // Build the neccessary markup
                        i.wrap = c(i.tpl.wrap).addClass("fancybox-" + (k ? "mobile" : "desktop") + " fancybox-type-" + e + " fancybox-tmp " + i.wrapCSS).appendTo(i.parent || "body"), c.extend(i, {
                            skin: c(".fancybox-skin", i.wrap),
                            outer: c(".fancybox-outer", i.wrap),
                            inner: c(".fancybox-inner", i.wrap)
                        }), c.each(["Top", "Right", "Bottom", "Left"], function(a, b) {
                            i.skin.css("padding" + b, q(i.padding[a]))
                        }), h.trigger("onReady"), "inline" === e || "html" === e) {
                        if (!i.content || !i.content.length) return h._error("content")
                    } else if (!d) return h._error("href");
                    "image" === e ? h._loadImage() : "ajax" === e ? h._loadAjax() : "iframe" === e ? h._loadIframe() : h._afterLoad()
                },
                _error: function(a) {
                    c.extend(h.coming, {
                        type: "html",
                        autoWidth: !0,
                        autoHeight: !0,
                        minWidth: 0,
                        minHeight: 0,
                        scrolling: "no",
                        hasError: a,
                        content: h.coming.tpl.error
                    }), h._afterLoad()
                },
                _loadImage: function() {
                    // Reset preload image so it is later possible to check "complete" property
                    var a = h.imgPreload = new Image;
                    a.onload = function() {
                        this.onload = this.onerror = null, h.coming.width = this.width / h.opts.pixelRatio, h.coming.height = this.height / h.opts.pixelRatio, h._afterLoad()
                    }, a.onerror = function() {
                        this.onload = this.onerror = null, h._error("image")
                    }, a.src = h.coming.href, a.complete !== !0 && h.showLoading()
                },
                _loadAjax: function() {
                    var a = h.coming;
                    h.showLoading(), h.ajaxLoad = c.ajax(c.extend({}, a.ajax, {
                        url: a.href,
                        error: function(a, b) {
                            h.coming && "abort" !== b ? h._error("ajax", a) : h.hideLoading()
                        },
                        success: function(b, c) {
                            "success" === c && (a.content = b, h._afterLoad())
                        }
                    }))
                },
                _loadIframe: function() {
                    var a = h.coming,
                        b = c(a.tpl.iframe.replace(/\{rnd\}/g, (new Date).getTime())).attr("scrolling", k ? "auto" : a.iframe.scrolling).attr("src", a.href);
                    // This helps IE
                    c(a.wrap).bind("onReset", function() {
                        try {
                            c(this).find("iframe").hide().attr("src", "//about:blank").end().empty()
                        } catch (a) {}
                    }), a.iframe.preload && (h.showLoading(), b.one("load", function() {
                        c(this).data("ready", 1),
                            // iOS will lose scrolling if we resize
                            k || c(this).bind("load.fb", h.update),
                            // Without this trick:
                            //   - iframe won't scroll on iOS devices
                            //   - IE7 sometimes displays empty iframe
                            c(this).parents(".fancybox-wrap").width("100%").removeClass("fancybox-tmp").show(), h._afterLoad()
                    })), a.content = b.appendTo(a.inner), a.iframe.preload || h._afterLoad()
                },
                _preloadImages: function() {
                    var a, b, c = h.group,
                        d = h.current,
                        e = c.length,
                        f = d.preload ? Math.min(d.preload, e - 1) : 0;
                    for (b = 1; f >= b; b += 1) a = c[(d.index + b) % e], "image" === a.type && a.href && ((new Image).src = a.href)
                },
                _afterLoad: function() {
                    var a, b, d, e, f, g, i = h.coming,
                        j = h.current,
                        k = "fancybox-placeholder";
                    if (h.hideLoading(), i && h.isActive !== !1) {
                        if (!1 === h.trigger("afterLoad", i, j)) return i.wrap.stop(!0).trigger("onReset").remove(), void(h.coming = null);
                        switch (j && (h.trigger("beforeChange", j), j.wrap.stop(!0).removeClass("fancybox-opened").find(".fancybox-item, .fancybox-nav").remove()), h.unbindEvents(), a = i, b = i.content, d = i.type, e = i.scrolling, c.extend(h, {
                            wrap: a.wrap,
                            skin: a.skin,
                            outer: a.outer,
                            inner: a.inner,
                            current: a,
                            previous: j
                        }), f = a.href, d) {
                            case "inline":
                            case "ajax":
                            case "html":
                                a.selector ? b = c("<div>").html(b).find(a.selector) : l(b) && (b.data(k) || b.data(k, c('<div class="' + k + '"></div>').insertAfter(b).hide()), b = b.show().detach(), a.wrap.bind("onReset", function() {
                                    c(this).find(b).length && b.hide().replaceAll(b.data(k)).data(k, !1)
                                }));
                                break;
                            case "image":
                                b = a.tpl.image.replace("{href}", f);
                                break;
                            case "swf":
                                b = '<object id="fancybox-swf" classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" width="100%" height="100%"><param name="movie" value="' + f + '"></param>', g = "", c.each(a.swf, function(a, c) {
                                    b += '<param name="' + a + '" value="' + c + '"></param>', g += " " + a + '="' + c + '"'
                                }), b += '<embed src="' + f + '" type="application/x-shockwave-flash" width="100%" height="100%"' + g + "></embed></object>"
                        }
                        l(b) && b.parent().is(a.inner) || a.inner.append(b),
                            // Give a chance for helpers or callbacks to update elements
                            h.trigger("beforeShow"),
                            // Set scrolling before calculating dimensions
                            a.inner.css("overflow", "yes" === e ? "scroll" : "no" === e ? "hidden" : e),
                            // Set initial dimensions and start position
                            h._setDimension(), h.reposition(), h.isOpen = !1, h.coming = null, h.bindEvents(), h.isOpened ? j.prevMethod && h.transitions[j.prevMethod]() : c(".fancybox-wrap").not(a.wrap).stop(!0).trigger("onReset").remove(), h.transitions[h.isOpened ? a.nextMethod : a.openMethod](), h._preloadImages()
                    }
                },
                _setDimension: function() {
                    var a, b, d, e, f, g, i, j, k, l, m, o, r, s, t, u = h.getViewport(),
                        v = 0,
                        w = !1,
                        x = !1,
                        y = h.wrap,
                        z = h.skin,
                        A = h.inner,
                        B = h.current,
                        C = B.width,
                        D = B.height,
                        E = B.minWidth,
                        F = B.minHeight,
                        G = B.maxWidth,
                        H = B.maxHeight,
                        I = B.scrolling,
                        J = B.scrollOutside ? B.scrollbarWidth : 0,
                        K = B.margin,
                        L = p(K[1] + K[3]),
                        M = p(K[0] + K[2]);
                    if (
                        // Reset dimensions so we could re-check actual size
                        y.add(z).add(A).width("auto").height("auto").removeClass("fancybox-tmp"), a = p(z.outerWidth(!0) - z.width()), b = p(z.outerHeight(!0) - z.height()), d = L + a, e = M + b, f = n(C) ? (u.w - d) * p(C) / 100 : C, g = n(D) ? (u.h - e) * p(D) / 100 : D, "iframe" === B.type) {
                        if (s = B.content, B.autoHeight && 1 === s.data("ready")) try {
                            s[0].contentWindow.document.location && (A.width(f).height(9999), t = s.contents().find("body"), J && t.css("overflow-x", "hidden"), g = t.outerHeight(!0))
                        } catch (N) {}
                    } else(B.autoWidth || B.autoHeight) && (A.addClass("fancybox-tmp"),
                        // Set width or height in case we need to calculate only one dimension
                        B.autoWidth || A.width(f), B.autoHeight || A.height(g), B.autoWidth && (f = A.width()), B.autoHeight && (g = A.height()), A.removeClass("fancybox-tmp"));
                    // Try to fit inside viewport (including the title)
                    if (C = p(f), D = p(g), k = f / g, E = p(n(E) ? p(E, "w") - d : E), G = p(n(G) ? p(G, "w") - d : G), F = p(n(F) ? p(F, "h") - e : F), H = p(n(H) ? p(H, "h") - e : H), i = G, j = H, B.fitToView && (G = Math.min(u.w - d, G), H = Math.min(u.h - e, H)), o = u.w - L, r = u.h - M, B.aspectRatio ? (C > G && (C = G, D = p(C / k)), D > H && (D = H, C = p(D * k)), E > C && (C = E, D = p(C / k)), F > D && (D = F, C = p(D * k))) : (C = Math.max(E, Math.min(C, G)), B.autoHeight && "iframe" !== B.type && (A.width(C), D = A.height()), D = Math.max(F, Math.min(D, H))), B.fitToView)
                        if (A.width(C).height(D), y.width(C + a), l = y.width(), m = y.height(), B.aspectRatio)
                            for (;
                                (l > o || m > r) && C > E && D > F && !(v++ > 19);) D = Math.max(F, Math.min(H, D - 10)), C = p(D * k), E > C && (C = E, D = p(C / k)), C > G && (C = G, D = p(C / k)), A.width(C).height(D), y.width(C + a), l = y.width(), m = y.height();
                        else C = Math.max(E, Math.min(C, C - (l - o))), D = Math.max(F, Math.min(D, D - (m - r)));
                    J && "auto" === I && g > D && o > C + a + J && (C += J), A.width(C).height(D), y.width(C + a), l = y.width(), m = y.height(), w = (l > o || m > r) && C > E && D > F, x = B.aspectRatio ? i > C && j > D && f > C && g > D : (i > C || j > D) && (f > C || g > D), c.extend(B, {
                        dim: {
                            width: q(l),
                            height: q(m)
                        },
                        origWidth: f,
                        origHeight: g,
                        canShrink: w,
                        canExpand: x,
                        wPadding: a,
                        hPadding: b,
                        wrapSpace: m - z.outerHeight(!0),
                        skinSpace: z.height() - D
                    }), !s && B.autoHeight && D > F && H > D && !x && A.height("auto")
                },
                _getPosition: function(a) {
                    var b = h.current,
                        c = h.getViewport(),
                        d = b.margin,
                        e = h.wrap.width() + d[1] + d[3],
                        f = h.wrap.height() + d[0] + d[2],
                        g = {
                            position: "absolute",
                            top: d[0],
                            left: d[3]
                        };
                    return b.autoCenter && b.fixed && !a && f <= c.h && e <= c.w ? g.position = "fixed" : b.locked || (g.top += c.y, g.left += c.x), g.top = q(Math.max(g.top, g.top + (c.h - f) * b.topRatio)), g.left = q(Math.max(g.left, g.left + (c.w - e) * b.leftRatio)), g
                },
                _afterZoomIn: function() {
                    var a = h.current;
                    a && (h.isOpen = h.isOpened = !0, h.wrap.css("overflow", "visible").addClass("fancybox-opened"), h.update(),
                        // Assign a click event
                        (a.closeClick || a.nextClick && h.group.length > 1) && h.inner.css("cursor", "pointer").bind("click.fb", function(b) {
                            c(b.target).is("a") || c(b.target).parent().is("a") || (b.preventDefault(), h[a.closeClick ? "close" : "next"]())
                        }),
                        // Create a close button
                        a.closeBtn && c(a.tpl.closeBtn).appendTo(h.skin).bind("click.fb", function(a) {
                            a.preventDefault(), h.close()
                        }),
                        // Create navigation arrows
                        a.arrows && h.group.length > 1 && ((a.loop || a.index > 0) && c(a.tpl.prev).appendTo(h.outer).bind("click.fb", h.prev), (a.loop || a.index < h.group.length - 1) && c(a.tpl.next).appendTo(h.outer).bind("click.fb", h.next)), h.trigger("afterShow"),
                        // Stop the slideshow if this is the last item
                        a.loop || a.index !== a.group.length - 1 ? h.opts.autoPlay && !h.player.isActive && (h.opts.autoPlay = !1, h.play()) : h.play(!1))
                },
                _afterZoomOut: function(a) {
                    a = a || h.current, c(".fancybox-wrap").trigger("onReset").remove(), c.extend(h, {
                        group: {},
                        opts: {},
                        router: !1,
                        current: null,
                        isActive: !1,
                        isOpened: !1,
                        isOpen: !1,
                        isClosing: !1,
                        wrap: null,
                        skin: null,
                        outer: null,
                        inner: null
                    }), h.trigger("afterClose", a)
                }
            }),
            /*
             *	Default transitions
             */
            h.transitions = {
                getOrigPosition: function() {
                    var a = h.current,
                        b = a.element,
                        c = a.orig,
                        d = {},
                        e = 50,
                        f = 50,
                        g = a.hPadding,
                        i = a.wPadding,
                        j = h.getViewport();
                    return !c && a.isDom && b.is(":visible") && (c = b.find("img:first"), c.length || (c = b)), l(c) ? (d = c.offset(), c.is("img") && (e = c.outerWidth(), f = c.outerHeight())) : (d.top = j.y + (j.h - f) * a.topRatio, d.left = j.x + (j.w - e) * a.leftRatio), ("fixed" === h.wrap.css("position") || a.locked) && (d.top -= j.y, d.left -= j.x), d = {
                        top: q(d.top - g * a.topRatio),
                        left: q(d.left - i * a.leftRatio),
                        width: q(e + i),
                        height: q(f + g)
                    }
                },
                step: function(a, b) {
                    var c, d, e, f = b.prop,
                        g = h.current,
                        i = g.wrapSpace,
                        j = g.skinSpace;
                    "width" !== f && "height" !== f || (c = b.end === b.start ? 1 : (a - b.start) / (b.end - b.start), h.isClosing && (c = 1 - c), d = "width" === f ? g.wPadding : g.hPadding, e = a - d, h.skin[f](p("width" === f ? e : e - i * c)), h.inner[f](p("width" === f ? e : e - i * c - j * c)))
                },
                zoomIn: function() {
                    var a = h.current,
                        b = a.pos,
                        d = a.openEffect,
                        e = "elastic" === d,
                        f = c.extend({
                            opacity: 1
                        }, b);
                    // Remove "position" property that breaks older IE
                    delete f.position, e ? (b = this.getOrigPosition(), a.openOpacity && (b.opacity = .1)) : "fade" === d && (b.opacity = .1), h.wrap.css(b).animate(f, {
                        duration: "none" === d ? 0 : a.openSpeed,
                        easing: a.openEasing,
                        step: e ? this.step : null,
                        complete: h._afterZoomIn
                    })
                },
                zoomOut: function() {
                    var a = h.current,
                        b = a.closeEffect,
                        c = "elastic" === b,
                        d = {
                            opacity: .1
                        };
                    c && (d = this.getOrigPosition(), a.closeOpacity && (d.opacity = .1)), h.wrap.animate(d, {
                        duration: "none" === b ? 0 : a.closeSpeed,
                        easing: a.closeEasing,
                        step: c ? this.step : null,
                        complete: h._afterZoomOut
                    })
                },
                changeIn: function() {
                    var a, b = h.current,
                        c = b.nextEffect,
                        d = b.pos,
                        e = {
                            opacity: 1
                        },
                        f = h.direction,
                        g = 200;
                    d.opacity = .1, "elastic" === c && (a = "down" === f || "up" === f ? "top" : "left", "down" === f || "right" === f ? (d[a] = q(p(d[a]) - g), e[a] = "+=" + g + "px") : (d[a] = q(p(d[a]) + g), e[a] = "-=" + g + "px")),
                        // Workaround for http://bugs.jquery.com/ticket/12273
                        "none" === c ? h._afterZoomIn() : h.wrap.css(d).animate(e, {
                            duration: b.nextSpeed,
                            easing: b.nextEasing,
                            complete: h._afterZoomIn
                        })
                },
                changeOut: function() {
                    var a = h.previous,
                        b = a.prevEffect,
                        d = {
                            opacity: .1
                        },
                        e = h.direction,
                        f = 200;
                    "elastic" === b && (d["down" === e || "up" === e ? "top" : "left"] = ("up" === e || "left" === e ? "-" : "+") + "=" + f + "px"), a.wrap.animate(d, {
                        duration: "none" === b ? 0 : a.prevSpeed,
                        easing: a.prevEasing,
                        complete: function() {
                            c(this).trigger("onReset").remove()
                        }
                    })
                }
            },
            /*
             *	Overlay helper
             */
            h.helpers.overlay = {
                defaults: {
                    closeClick: !0, // if true, fancyBox will be closed when user clicks on the overlay
                    speedOut: 200, // duration of fadeOut animation
                    showEarly: !0, // indicates if should be opened immediately or wait until the content is ready
                    css: {}, // custom CSS properties
                    locked: !k, // if true, the content will be locked into overlay
                    fixed: !0
                },
                overlay: null, // current handle
                fixed: !1, // indicates if the overlay has position "fixed"
                el: c("html"), // element that contains "the lock"
                // Public methods
                create: function(a) {
                    a = c.extend({}, this.defaults, a), this.overlay && this.close(), this.overlay = c('<div class="fancybox-overlay"></div>').appendTo(h.coming ? h.coming.parent : a.parent), this.fixed = !1, a.fixed && h.defaults.fixed && (this.overlay.addClass("fancybox-overlay-fixed"), this.fixed = !0)
                },
                open: function(a) {
                    var b = this;
                    a = c.extend({}, this.defaults, a), this.overlay ? this.overlay.unbind(".overlay").width("auto").height("auto") : this.create(a), this.fixed || (f.bind("resize.overlay", c.proxy(this.update, this)), this.update()), a.closeClick && this.overlay.bind("click.overlay", function(a) {
                        return c(a.target).hasClass("fancybox-overlay") ? (h.isActive ? h.close() : b.close(), !1) : void 0
                    }), this.overlay.css(a.css).show()
                },
                close: function() {
                    var a, b;
                    f.unbind("resize.overlay"), this.el.hasClass("fancybox-lock") && (c(".fancybox-margin").removeClass("fancybox-margin"), a = f.scrollTop(), b = f.scrollLeft(), this.el.removeClass("fancybox-lock"), f.scrollTop(a).scrollLeft(b)), c(".fancybox-overlay").remove().hide(), c.extend(this, {
                        overlay: null,
                        fixed: !1
                    })
                },
                // Private, callbacks
                update: function() {
                    var a, c = "100%";
                    // Reset width/height so it will not mess
                    this.overlay.width(c).height("100%"),
                        // jQuery does not return reliable result for IE
                        i ? (a = Math.max(b.documentElement.offsetWidth, b.body.offsetWidth), g.width() > a && (c = g.width())) : g.width() > f.width() && (c = g.width()), this.overlay.width(c).height(g.height())
                },
                // This is where we can manipulate DOM, because later it would cause iframes to reload
                onReady: function(a, b) {
                    var d = this.overlay;
                    c(".fancybox-overlay").stop(!0, !0), d || this.create(a), a.locked && this.fixed && b.fixed && (d || (this.margin = g.height() > f.height() ? c("html").css("margin-right").replace("px", "") : !1), b.locked = this.overlay.append(b.wrap), b.fixed = !1), a.showEarly === !0 && this.beforeShow.apply(this, arguments)
                },
                beforeShow: function(a, b) {
                    var d, e;
                    b.locked && (this.margin !== !1 && (c("*").filter(function() {
                        return "fixed" === c(this).css("position") && !c(this).hasClass("fancybox-overlay") && !c(this).hasClass("fancybox-wrap")
                    }).addClass("fancybox-margin"), this.el.addClass("fancybox-margin")), d = f.scrollTop(), e = f.scrollLeft(), this.el.addClass("fancybox-lock"), f.scrollTop(d).scrollLeft(e)), this.open(a)
                },
                onUpdate: function() {
                    this.fixed || this.update()
                },
                afterClose: function(a) {
                    // Remove overlay if exists and fancyBox is not opening
                    // (e.g., it is not being open using afterClose callback)
                    //if (this.overlay && !F.isActive) {
                    this.overlay && !h.coming && this.overlay.fadeOut(a.speedOut, c.proxy(this.close, this))
                }
            },
            /*
             *	Title helper
             */
            h.helpers.title = {
                defaults: {
                    type: "float", // 'float', 'inside', 'outside' or 'over',
                    position: "bottom"
                },
                beforeShow: function(a) {
                    var b, d, e = h.current,
                        f = e.title,
                        g = a.type;
                    if (c.isFunction(f) && (f = f.call(e.element, e)), m(f) && "" !== c.trim(f)) {
                        switch (b = c('<div class="fancybox-title fancybox-title-' + g + '-wrap">' + f + "</div>"), g) {
                            case "inside":
                                d = h.skin;
                                break;
                            case "outside":
                                d = h.wrap;
                                break;
                            case "over":
                                d = h.inner;
                                break;
                            default: // 'float'
                                d = h.skin, b.appendTo("body"), i && b.width(b.width()), b.wrapInner('<span class="child"></span>'),
                                    //Increase bottom margin so this title will also fit into viewport
                                    h.current.margin[2] += Math.abs(p(b.css("margin-bottom")))
                        }
                        b["top" === a.position ? "prependTo" : "appendTo"](d)
                    }
                }
            },
            // jQuery plugin initialization
            c.fn.fancybox = function(a) {
                var b, d = c(this),
                    e = this.selector || "",
                    f = function(f) {
                        var g, i, j = c(this).blur(),
                            k = b;
                        f.ctrlKey || f.altKey || f.shiftKey || f.metaKey || j.is(".fancybox-wrap") || (g = a.groupAttr || "data-fancybox-group", i = j.attr(g), i || (g = "rel", i = j.get(0)[g]), i && "" !== i && "nofollow" !== i && (j = e.length ? c(e) : d, j = j.filter("[" + g + '="' + i + '"]'), k = j.index(this)), a.index = k, h.open(j, a) !== !1 && f.preventDefault())
                    };
                return a = a || {}, b = a.index || 0, e && a.live !== !1 ? g.undelegate(e, "click.fb-start").delegate(e + ":not('.fancybox-item, .fancybox-nav')", "click.fb-start", f) : d.unbind("click.fb-start").bind("click.fb-start", f), this.filter("[data-fancybox-start=1]").trigger("click"), this
            },
            // Tests that need a body at doc ready
            g.ready(function() {
                var b, f;
                c.scrollbarWidth === d && (
                    // http://benalman.com/projects/jquery-misc-plugins/#scrollbarwidth
                    c.scrollbarWidth = function() {
                        var a = c('<div style="width:50px;height:50px;overflow:auto"><div/></div>').appendTo("body"),
                            b = a.children(),
                            d = b.innerWidth() - b.height(99).innerWidth();
                        return a.remove(), d
                    }), c.support.fixedPosition === d && (c.support.fixedPosition = function() {
                    var a = c('<div style="position:fixed;top:20px;"></div>').appendTo("body"),
                        b = 20 === a[0].offsetTop || 15 === a[0].offsetTop;
                    return a.remove(), b
                }()), c.extend(h.defaults, {
                    scrollbarWidth: c.scrollbarWidth(),
                    fixed: c.support.fixedPosition,
                    parent: c("body")
                }), b = c(a).width(), e.addClass("fancybox-lock-test"), f = c(a).width(), e.removeClass("fancybox-lock-test"), c("<style type='text/css'>.fancybox-margin{margin-right:" + (f - b) + "px;}</style>").appendTo("head")
            })
    }(window, document, jQuery);
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mr.doob / http://mrdoob.com/
 */
var Detector = {
    canvas: !!window.CanvasRenderingContext2D,
    webgl: function() {
        try {
            var a = document.createElement("canvas");
            return !(!window.WebGLRenderingContext || !a.getContext("webgl") && !a.getContext("experimental-webgl"))
        } catch (b) {
            return !1
        }
    }(),
    workers: !!window.Worker,
    fileapi: window.File && window.FileReader && window.FileList && window.Blob,
    getWebGLErrorMessage: function() {
        var a = document.createElement("div");
        return a.id = "webgl-error-message", a.style.fontFamily = "monospace", a.style.fontSize = "13px", a.style.fontWeight = "normal", a.style.textAlign = "center", a.style.background = "#fff", a.style.color = "#000", a.style.padding = "1.5em", a.style.width = "400px", a.style.margin = "5em auto 0", this.webgl || (a.innerHTML = window.WebGLRenderingContext ? ['Your graphics card does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">WebGL</a>.<br />', 'Find out how to get it <a href="http://get.webgl.org/" style="color:#000">here</a>.'].join("\n") : ['Your browser does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">WebGL</a>.<br/>', 'Find out how to get it <a href="http://get.webgl.org/" style="color:#000">here</a>.'].join("\n")), a
    },
    addGetWebGLMessage: function(a) {
        var b, c, d;
        a = a || {}, b = void 0 !== a.parent ? a.parent : document.body, c = void 0 !== a.id ? a.id : "oldie", d = Detector.getWebGLErrorMessage(), d.id = c, b.appendChild(d)
    }
};
// browserify support
"object" == typeof module && (module.exports = Detector),
    function(a) {
        var b = a({});
        a.subscribe = b.on.bind(b), a.unsubscribe = b.off.bind(b, arguments), a.publish = b.trigger.bind(b)
    }(jQuery),
    function(a, b) {
        b.Router = {
            fire: function(a, c, d) {
                var e, f = b.Main;
                c = void 0 === c ? "init" : c, e = "" !== a, e = e && f[a], e = e && "function" == typeof f[a][c], e && f[a][c](d)
            },
            init: function() {
                this.fire("common");
                var b = this;
                a.each(document.body.className.replace(/-/g, "_").split(/\s+/), function(a, c) {
                    b.fire(c), b.fire(c, "finalize")
                }), this.fire("common", "finalize")
            }
        }, a(document).ready(a.proxy(b.Router.init, b.Router))
    }(jQuery, window.Edge = window.Edge || {}),
    function(a) {
        function b() {
            var a = document.createElement("edge"),
                b = {
                    WebkitTransition: "webkitTransitionEnd",
                    MozTransition: "transitionend",
                    OTransition: "oTransitionEnd otransitionend",
                    transition: "transitionend"
                };
            for (var c in b)
                if (void 0 !== a.style[c]) return {
                    end: b[c]
                };
            return !1
        }
        a.fn.emulateTransitionEnd = function(b) {
            var c = !1,
                d = a(this);
            return d.one("edgeTransitionEnd", function() {
                c = !0
            }), setTimeout(function() {
                c || d.trigger(a.support.transition.end)
            }, b), this
        }, a(function() {
            a.support.transition = b(), a.support.transition && (a.event.special.edgeTransitionEnd = {
                bindType: a.support.transition.end,
                delegateType: a.support.transition.end,
                handle: function(b) {
                    return a(b.target).is(this) ? b.handleObj.handler.apply(this, arguments) : void 0
                }
            })
        })
    }(jQuery),
    function(a, b) {
        b.Alert = {
            settings: {
                hideState: "--hide"
            },
            init: function() {
                this.dom(), this.events()
            },
            dom: function() {
                this.$document = a(document)
            },
            events: function() {
                this.$document.on("click", ".alert__close", a.proxy(this.handleClose, this))
            },
            handleClose: function(b) {
                b && b.preventDefault();
                var c = a(b.target),
                    d = c.parent(".alert");
                d.length && (d.addClass(this.settings.hideState), a.support.transition ? d.one("edgeTransitionEnd", a.proxy(this.alertTransitionEnd)).emulateTransitionEnd(150) : this.alertTransitionEnd())
            },
            alertTransitionEnd: function() {
                a(this).remove()
            }
        }
    }(jQuery, window.Edge = window.Edge || {}),
    function(a, b) {
        b.ArchiveCaseStudy = {
            settings: {
                lazySettings: {
                    effect: "fadeIn",
                    effectTime: 1500,
                    visibleOnly: !0
                }
            },
            init: function() {
                this.dom(), this.initLazy()
            },
            dom: function() {
                this.$el = a(".archive-case-study"), this.$images = this.$el.find(".archive-case-study__column__image")
            },
            initLazy: function() {
                this.$images.length && this.$images.lazy(this.settings.lazySettings)
            }
        }
    }(jQuery, window.Edge = window.Edge || {}),
    function(a, b) {
        b.Breadcrumbs = {
            init: function() {
                this.dom(), this.events()
            },
            dom: function() {
                this.$window = a(window), this.$el = a(".breadcrumb"), this.offset = this.$el.css("bottom")
            },
            events: function() {
                this.$window.scroll(a.proxy(this.scroll, this))
            },
            scroll: function() {
                this.$window.width() >= 768 ? this.$el.css("bottom", this.$window.scrollTop() + parseInt(this.offset) + "px") : this.$el.css("bottom", parseInt(this.offset) + "px")
            }
        }
    }(jQuery, window.Edge = window.Edge || {}),
    function(a, b) {
        b.CaseStudyArchitecture = {
            settings: {
                fancyboxSettings: {
                    openEffect: "elastic",
                    closeEffect: "elastic",
                    helpers: {
                        title: null,
                        overlay: {
                            locked: !1
                        }
                    }
                }
            },
            init: function() {
                this.dom(), this.initFancybox()
            },
            dom: function() {
                this.$el = a(".case-study-architecture"), this.$links = this.$el.find(".case-study-architecture__sitemap, .case-study-architecture__item__link")
            },
            initFancybox: function() {
                this.$links.length && this.$links.attr("rel", "gallery").fancybox(this.settings.fancyboxSettings)
            }
        }
    }(jQuery, window.Edge = window.Edge || {}),
    function(a, b) {
        b.CaseStudyBrief = {
            settings: {
                backstretchSettings: {
                    centeredX: !0,
                    centeredY: !0,
                    fade: 750
                }
            },
            init: function() {
                this.dom(), this.initBackstretch()
            },
            dom: function() {
                this.$el = a(".case-study-brief"), this.$background = this.$el.children(".case-study-brief__background")
            },
            initBackstretch: function() {
                this.$background.length && this.$background.backstretch(this.$background.data("background"), this.settings.backstretchSettings)
            }
        }
    }(jQuery, window.Edge = window.Edge || {}),
    function(a, b) {
        b.CaseStudyHero = {
            settings: {
                backstretchSettings: {
                    centeredX: !0,
                    centeredY: !0,
                    fade: 750
                }
            },
            init: function() {
                this.dom(), this.initBackstretch()
            },
            dom: function() {
                this.$el = a(".case-study-hero"), this.$background = this.$el.children(".case-study-hero__background")
            },
            initBackstretch: function() {
                this.$background.length && this.$background.backstretch(this.$background.data("background"), this.settings.backstretchSettings)
            }
        }
    }(jQuery, window.Edge = window.Edge || {}),
    function(a, b) {
        b.CaseStudyResult = {
            settings: {
                backstretchSettings: {
                    centeredX: !0,
                    centeredY: !0,
                    fade: 750
                }
            },
            init: function() {
                this.dom(), this.initBackstretch()
            },
            dom: function() {
                this.$el = a(".case-study-result"), this.$background = this.$el.children(".case-study-result__background")
            },
            initBackstretch: function() {
                this.$background.length && this.$background.backstretch(this.$background.data("background"), this.settings.backstretchSettings)
            }
        }
    }(jQuery, window.Edge = window.Edge || {}),
    function(a, b) {
        b.CaseStudyTechnology = {
            settings: {},
            init: function() {
                this.dom(), this.events()
            },
            dom: function() {
                this.$el = a(".case-study-technology"), this.$items = this.$el.find(".case-study-technology__item")
            },
            events: function() {
                this.$items.length && this.$items.hover(a.proxy(this.show), a.proxy(this.hide))
            },
            show: function() {
                a(this).children(".case-study-technology__description").stop(!0).fadeIn()
            },
            hide: function() {
                a(this).children(".case-study-technology__description").stop(!0).fadeOut()
            }
        }
    }(jQuery, window.Edge = window.Edge || {}),
    function(a, b) {
        b.ContactMap = {
            settings: {
                modalHideState: "--hide",
                dialogHideState: "--hide"
            },
            init: function() {
                this.dom(), this.initModals(), a.getScript("//maps.google.com/maps/api/js", a.proxy(this.initMaps, this))
            },
            dom: function() {
                this.$el = a(".contact-map"), this.$maps = this.$el.find(".contact-map__location"), this.$modals = this.$el.find(".contact-map__modal")
            },
            initMaps: function() {
                this.$maps.each(function() {
                    var b = a(this),
                        c = new google.maps.LatLng(b.data("lat"), b.data("lng")),
                        d = new google.maps.Map(b[0], {
                            zoom: b.data("zoom"),
                            center: c,
                            mapTypeId: google.maps.MapTypeId.ROADMAP,
                            zoomControl: !1,
                            scaleControl: !1,
                            scrollwheel: !1,
                            disableDoubleClickZoom: !0
                        });
                    new google.maps.Marker({
                        position: c,
                        map: d
                    })
                })
            },
            initModals: function() {
                this.$modals.length && this.$modals.each(function(b, c) {
                    a(c).find(".contact-map__modal__close").click(a.proxy(this.handleModalClose, this))
                }.bind(this))
            },
            handleModalClose: function(b) {
                b && b.preventDefault();
                var c = a(b.target).closest(".contact-map__modal__dialog").addClass(this.settings.dialogHideState);
                a.support.transition ? c.one("edgeTransitionEnd", a.proxy(this.dialogTransitionEnd, this)).emulateTransitionEnd(300) : this.dialogTransitionEnd()
            },
            dialogTransitionEnd: function(b) {
                a(b.target).parent(".contact-map__modal").addClass(this.settings.modalHideState).one("edgeTransitionEnd", a.proxy(this.modalTransitionEnd, this)).emulateTransitionEnd(150)
            },
            modalTransitionEnd: function(b) {
                a(b.target).remove()
            }
        }
    }(jQuery, window.Edge = window.Edge || {}),
    function(a, b) {
        b.Form = {
            settings: {
                inputErrorState: "--error",
                inputLength: 2,
                alertSuccessState: "--success",
                alertErrorState: "--error",
                alertHideState: "--hide",
                alertSettings: {
                    "class": "alert",
                    role: "alert"
                },
                alertButtonSettings: {
                    "class": "alert__close",
                    type: "button",
                    html: "&times"
                },
                alertTextSettings: {
                    "class": "alert__text"
                }
            },
            init: function() {
                this.dom(), this.events()
            },
            dom: function() {
                this.$el = a(".form"), this.$container = this.$el.find(".form__container"), this.endpoint = this.$el.data("endpoint"), this.security = this.$el.data("security"), this.$inputs = this.$el.find(".form__text-field, .form__text-area"), this.$required = this.$inputs.filter("[required]"), this.$button = this.$el.find(".button"), this.$alertText = a("<p/>", this.settings.alertTextSettings), this.$alert = a("<div/>", this.settings.alertSettings).prepend(this.$alertText).prepend(a("<button/>", this.settings.alertButtonSettings))
            },
            events: function() {
                this.$el.submit(a.proxy(this.submit, this))
            },
            submit: function(b) {
                if (b.preventDefault(), this.$el.children(".alert").remove(), this.$alert.removeClass(this.settings.alertSuccessState).removeClass(this.settings.alertErrorState).removeClass(this.settings.alertHideState), this.$required.removeClass(this.settings.inputErrorState).each(a.proxy(this.validate, this)), !this.$required.hasClass(this.settings.inputErrorState)) {
                    var c = this.$el.serializeArray();
                    c.push({
                        name: "security",
                        value: this.security
                    }), a.ajax({
                        type: "post",
                        url: this.endpoint,
                        data: c,
                        beforeSend: a.proxy(this.beforeSend, this),
                        success: a.proxy(this.success, this)
                    })
                }
            },
            validate: function(b, c) {
                var d = a(c);
                d.val().length < this.settings.inputLength && d.addClass(this.settings.inputErrorState)
            },
            beforeSend: function() {
                this.$button.attr("disabled", !0)
            },
            success: function(a) {
                this.$button.attr("disabled", !1), this.$alertText.html(a.data.message), this.$alert.prependTo(this.$el), __gaTracker("send", "event", a.data.form_name, "Form submitted"), a.success ? (this.$inputs.val(""), this.$container.slideUp(), this.$alert.addClass(this.settings.alertSuccessState)) : this.$alert.addClass(this.settings.alertErrorState)
            }
        }
    }(jQuery, window.Edge = window.Edge || {}),
    function(a, b) {
        b.FrontCaseStudy = {
            settings: {
                lazySettings: {
                    effect: "fadeIn",
                    effectTime: 1500,
                    visibleOnly: !0
                }
            },
            init: function() {
                this.dom(), this.$images.lazy(this.settings.lazySettings)
            },
            dom: function() {
                this.$el = a(".front-case-study"), this.$images = this.$el.find(".front-case-study__item__link")
            }
        }
    }(jQuery, window.Edge = window.Edge || {}),
    (jQuery, window.Edge = window.Edge || {}),
    function(a, b) {
        b.HeaderSearch = {
            settings: {
                elHiddenState: "--hidden",
                groupActivatedState: "--activated",
                labelActivatedState: "--activated"
            },
            init: function() {
                this.dom(), this.events()
            },
            dom: function() {
                this.$el = a(".header-search"), this.$button = this.$el.children(".header-search__button"), this.$group = this.$el.children(".header-search__group"), this.$label = this.$group.children(".header-search__label"), this.$document = a(document)
            },
            events: function() {
                this.$button.on("click", a.proxy(this.activate, this)), a.subscribe({
                    "edge.navigationOpen.clicked": a.proxy(this.toggle, this),
                    "edge.navigationClose.clicked": a.proxy(this.toggle, this)
                })
            },
            toggle: function() {
                this.$el.toggleClass(this.settings.elHiddenState)
            },
            activate: function(b) {
                b.preventDefault(), this.$group.addClass(this.settings.groupActivatedState), a.support.transition ? this.$group.one("edgeTransitionEnd", a.proxy(this.labelTransitionEnd, this)).emulateTransitionEnd(200) : this.labelTransitionEnd(), this.$button.off("click", a.proxy(this.activate, this)), this.$document.on("click", a.proxy(this.deactivate, this))
            },
            deactivate: function(b) {
                this.$el.is(b.target) || this.$el.has(b.target).length || (b.preventDefault(), this.$label.removeClass(this.settings.labelActivatedState), a.support.transition ? this.$label.one("edgeTransitionEnd", a.proxy(this.groupTransitionEnd, this)).emulateTransitionEnd(200) : this.groupTransitionEnd(), this.$button.on("click", a.proxy(this.activate, this)), this.$document.off("click", a.proxy(this.deactivate, this)))
            },
            groupTransitionEnd: function() {
                this.$group.removeClass(this.settings.groupActivatedState)
            },
            labelTransitionEnd: function() {
                this.$label.addClass(this.settings.labelActivatedState)
            }
        }
    }(jQuery, window.Edge = window.Edge || {}),
    function(a, b) {
        b.Header = {
            settings: {
                elFixedState: "--fixed",
                elActivatedState: "--activated"
            },
            init: function() {
                this.dom(), this.events()
            },
            dom: function() {
                this.$el = a(".header"), this.$window = a(window), this.$menu = a(".navigation"), this.scrollTimeout = null
            },
            events: function() {
                this.$window.scroll(a.proxy(this.scroll, this))
            },
            scroll: function() {
                this.scrollTimeout && (clearTimeout(this.scrollTimeout), this.scrollTimeout = null), this.scrollTimeout = setTimeout(a.proxy(this.scrollHandler, this), 250)
            },
            scrollHandler: function() {
                this.$window.scrollTop() >= this.$window.height() ? (this.$el.addClass(this.settings.elFixedState), setTimeout(function() {
                    this.$el.addClass(this.settings.elActivatedState)
                }.bind(this), 400)) : this.$el.removeClass(this.settings.elActivatedState).removeClass(this.settings.elFixedState)
            }
        }
    }(jQuery, window.Edge = window.Edge || {}),
    function(a, b) {
        b.Hero = {
            settings: {
                scrollActiveState: "--active",
                backstretchSettings: {
                    centeredX: !0,
                    centeredY: !0,
                    fade: 750
                }
            },
            init: function() {
                this.dom(), this.initBackstretch(), this.events()
            },
            dom: function() {
                this.$el = a(".hero"), this.$background = this.$el.children(".hero__background"), this.$content = this.$el.children(".hero__content"), this.$scroll = this.$el.children(".hero__scroll"), this.$body = a("body"), this.$window = a(window), this.scrollTimeout = null
            },
            initBackstretch: function() {
                var a = this.$background.data("background");
                a.length && this.$background.backstretch(a, this.settings.backstretchSettings), this.$backstretch = this.$background.children(".backstretch"), this.backstretch = this.$background.data("backstretch")
            },
            events: function() {
                this.$window.resize(a.proxy(this.resize, this)).resize().scroll(a.proxy(this.scroll, this)).scroll(), this.$background.on("backstretch.show", a.proxy(this.activateScroll, this))
            },
            resize: function() {
                var a = this.$window.height();
                this.$window.width();
                if (this.$body.hasClass("home") || (a *= .7), this.$el.height(a), this.$window.width() >= 753) 520 > a ? (this.$el.next(".sections").css("marginTop", 520), this.$el.height(520)) : this.$el.next(".sections").css("marginTop", a);
                else {
                    this.$el.next(".sections").css("marginTop", 0);
                    var b = this.$content.height() / .65;
                    b = 480 > b ? 480 : b, this.$el.height(b)
                }
                this.backstretch && this.backstretch.resize()
            },
            scroll: function() {
                this.scrollTimeout && (clearTimeout(this.scrollTimeout), this.scrollTimeout = null), this.scrollTimeout = setTimeout(a.proxy(this.scrollHandler, this))
            },
            scrollHandler: function() {
                var a = this.$window.scrollTop();
                a <= this.$el.height() && this.$window.width() >= 768 && (TweenLite.to(this.$backstretch, 0, {
                    force3D: !0,
                    y: a / 3 * -1,
                    scale: a / 2e3 + 1,
                    ease: Cubic.easeOut,
                    opacity: 1 - a / 800
                }), this.$content.css({
                    marginTop: a / 2 * -1,
                    opacity: 1 - a / 800
                }))
            },
            activateScroll: function() {
                this.$scroll.addClass(this.settings.scrollActiveState)
            }
        }
    }(jQuery, window.Edge = window.Edge || {}),
    function(a, b) {
        b.NavigationOpen = {
            settings: {
                elHiddenState: "--hidden"
            },
            init: function() {
                this.dom(), this.events()
            },
            dom: function() {
                this.$el = a(".navigation-open")
            },
            events: function() {
                this.$el.click(a.proxy(this.click, this)), a.subscribe("edge.navigationClose.clicked", a.proxy(this.toggle, this))
            },
            click: function(b) {
                b.preventDefault(), this.toggle(), a.publish("edge.navigationOpen.clicked")
            },
            toggle: function() {
                this.$el.toggleClass(this.settings.elHiddenState)
            }
        }
    }(jQuery, window.Edge = window.Edge || {}),
    function(a, b) {
        b.Navigation = {
            settings: {
                elShownState: "--shown",
                listMovedInState: "--moved-in",
                listMovedOutState: "--moved-out",
                listShownState: "--shown"
            },
            init: function() {
                this.dom(), this.events()
            },
            dom: function() {
                this.$window = a(window), this.$el = a(".navigation"), this.$close = this.$el.children(".navigation__close"), this.$list = this.$el.children(".navigation__list"), this.$item = this.$list.find(".navigation__item"), this.$link = this.$item.children(".navigation__link"), this.$back = this.$link.filter(".--back")
            },
            events: function() {
                a.subscribe("edge.navigationOpen.clicked", a.proxy(this.show, this)), this.$window.scroll(a.proxy(this.scroll, this)), this.$close.click(a.proxy(this.hide, this)), this.$item.filter(".--depth-0.--has-children").mouseover(a.proxy(this.showChildren, this)).mouseleave(a.proxy(this.hideChildren, this)), this.$link.filter(".--has-children").click(a.proxy(this.showChildren, this)), this.$back.click(a.proxy(this.back, this))
            },
            scroll: function() {
                this.$el.hasClass("--shown") && this.hide()
            },
            show: function() {
                this.$el.addClass(this.settings.elShownState)
            },
            hide: function() {
                this.$el.removeClass(this.settings.elShownState), a.support.transition ? this.$el.one("edgeTransitionEnd", a.proxy(this.hideTransitionEnd, this)).emulateTransitionEnd(500) : this.hideTransitionEnd()
            },
            hideTransitionEnd: function() {
                a.publish("edge.navigationClose.clicked"), this.hideChildren()
            },
            showChildren: function(b) {
                if ("click" === b.type && this.$window.width() < 992 && (b.preventDefault(), a(b.target).next(".navigation__list").addClass(this.settings.listMovedInState).end().parent(".navigation__item.--has-children").parent(".navigation__list").addClass(this.settings.listMovedOutState)), "mouseover" === b.type && this.$window.width() >= 992) {
                    var c = a(b.target).closest(".navigation__item.--depth-0"),
                        d = c.children(".navigation__list");
                    c.prop("hoverTimeout") && c.prop("hoverTimeout", clearTimeout(c.prop("hoverTimeout"))), c.prop("hoverIntent", setTimeout(function() {
                        d.addClass(this.settings.listShownState)
                    }.bind(this), 250))
                }
            },
            hideChildren: function(b) {
                if (!b && this.$window.width() < 992 && this.$el.find(".navigation__list").removeClass(this.settings.listMovedInState).removeClass(this.settings.listMovedOutState), b && "mouseleave" === b.type && this.$window.width() >= 992) {
                    var c = a(b.target).closest(".navigation__item.--depth-0"),
                        d = c.children(".navigation__list");
                    c.prop("hoverIntent") && c.prop("hoverIntent", clearTimeout(c.prop("hoverIntent"))), c.prop("hoverTimeout", setTimeout(function() {
                        d.removeClass(this.settings.listShownState)
                    }.bind(this), 250))
                }
            },
            back: function(b) {
                b.preventDefault(), a(b.target).closest(".navigation__list").removeClass(this.settings.listMovedInState).parent(".navigation__item.--has-children").parent(".navigation__list").removeClass(this.settings.listMovedOutState)
            }
        }
    }(jQuery, window.Edge = window.Edge || {}),
    function(a, b) {
        b.ProjectPlan = {
            settings: {
                datepicker: {
                    dayNamesMin: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
                }
            },
            init: function() {
                this.dom(), this.initCalendar()
            },
            dom: function() {
                this.$el = a(".project-plan"), this.$calendar = this.$el.children(".project-plan__calendar"), this.$list = this.$el.find(".project-plan__list"), this.$item = this.$list.children(".project-plan__item")
            },
            initCalendar: function() {
                if (this.$calendar.length) {
                    var b = this.minDate();
                    this.$calendar.datepicker({
                        dayNamesMin: this.settings.datepicker.dayNamesMin,
                        formatDate: "dd/mm/yy",
                        beforeShowDay: a.proxy(this.highlightDates, this),
                        minDate: b,
                        maxDate: this.maxDate(),
                        defaultDate: b,
                        onSelect: a.proxy(this.selectDate, this)
                    }), this.selectDate(b)
                }
            },
            highlightDates: function(a) {
                var b = plan.length;
                if (b)
                    for (; b--;)
                        if (new Date(plan[b].date / 1e4, plan[b].date % 1e4 / 100 - 1, plan[b].date % 100).toString() === a.toString()) return [!0, "marked", plan[b].title];
                return [!1, ""]
            },
            minDate: function() {
                var a = plan.length;
                if (a) {
                    for (var b = new Date(plan[0].date / 1e4, plan[0].date % 1e4 / 100 - 1, plan[0].date % 100); a--;) {
                        var c = new Date(plan[a].date / 1e4, plan[a].date % 1e4 / 100 - 1, plan[a].date % 100);
                        b > c && (b = c)
                    }
                    return b
                }
                return null
            },
            maxDate: function() {
                var a = plan.length;
                if (a) {
                    for (var b = new Date(plan[0].date / 1e4, plan[0].date % 1e4 / 100 - 1, plan[0].date % 100); a--;) {
                        var c = new Date(plan[a].date / 1e4, plan[a].date % 1e4 / 100 - 1, plan[a].date % 100);
                        c > b && (b = c)
                    }
                    return b
                }
                return null
            },
            selectDate: function(a) {
                var b = new Date(a).getTime(),
                    c = plan.length;
                if (c) {
                    for (var d = []; c--;) {
                        var e = new Date(plan[c].date / 1e4, plan[c].date % 1e4 / 100 - 1, plan[c].date % 100).getTime();
                        e === b && d.push(plan[c])
                    }
                    if (d.length)
                        for (this.$list.empty(), c = d.length; c--;) this.$list.append(this.$item.clone().find(".project-plan__item__title").text(d[c].title).end())
                }
                return null
            }
        }
    }(jQuery, window.Edge = window.Edge || {}),
    function(a, b) {
        b.Shape = {
            init: function() {
                this.$el = a(".shape"), this.$el.length && (this.targetRotationX = 0, this.targetRotationOnMouseDownX = 0, this.targetRotationY = 0, this.targetRotationOnMouseDownY = 0, this.mouseX = 0, this.mouseXOnMouseDown = 0, this.mouseY = 0, this.mouseYOnMouseDown = 0, this.windowHalfX = window.innerWidth / 2, this.windowHalfY = window.innerHeight / 2, this._init(), this.animate())
            },
            _init: function() {
                document.addEventListener("mousemove", this.onDocumentMouseMove.bind(this), !1), document.addEventListener("touchstart", this.onDocumentTouchStart.bind(this), !1), document.addEventListener("touchmove", this.onDocumentTouchMove.bind(this), !1),
                    // SCENE
                    this.scene = new THREE.Scene;
                // CAMERA
                var a = window.innerWidth,
                    b = window.innerHeight,
                    c = 45,
                    d = a / b,
                    e = .1,
                    f = 2e4;
                this.camera = new THREE.PerspectiveCamera(c, d, e, f), this.scene.add(this.camera), this.camera.position.set(0, 150, 200), this.camera.lookAt(this.scene.position),
                    // RENDERER
                    Detector.webgl ? this.renderer = new THREE.WebGLRenderer({
                        antialias: !0
                    }) : this.renderer = new THREE.CanvasRenderer, this.renderer.setSize(a, b), this.container = this.$el[0], this.container.appendChild(this.renderer.domElement),
                    // EVENTS
                    THREEx.WindowResize(this.renderer, this.camera);
                // Using wireframe materials to illustrate shape details.
                var g = new THREE.MeshBasicMaterial({
                        wireframe: !0
                    }),
                    h = new THREE.MeshBasicMaterial({
                        color: 12303291,
                        wireframe: !0,
                        transparent: !0
                    }),
                    i = [g, h];
                // icosahedron
                this.shape = THREE.SceneUtils.createMultiMaterialObject(new THREE.IcosahedronGeometry(40, 1), // radius, subdivisions
                    i), this.shape.position.set(0, 0, 0), this.scene.add(this.shape)
            },
            animate: function() {
                requestAnimationFrame(this.animate.bind(this)), this.render()
            },
            render: function() {
                //horizontal rotation
                this.shape.rotation.y += .1 * (this.targetRotationX - this.shape.rotation.y),
                    //vertical rotation
                    this.finalRotationY = this.targetRotationY - this.shape.rotation.x, this.shape.rotation.x <= 1 && this.shape.rotation.x >= -1 && (this.shape.rotation.x += .1 * this.finalRotationY), this.shape.rotation.x > 1 && (this.shape.rotation.x = 1), this.shape.rotation.x < -1 && (this.shape.rotation.x = -1), this.renderer.render(this.scene, this.camera)
            },
            onDocumentMouseMove: function(a) {
                this.mouseX = a.clientX - this.windowHalfX, this.mouseY = a.clientY - this.windowHalfY, this.targetRotationY = this.targetRotationOnMouseDownY + .002 * (this.mouseY - this.mouseYOnMouseDown), this.targetRotationX = this.targetRotationOnMouseDownX + .002 * (this.mouseX - this.mouseXOnMouseDown)
            },
            onDocumentTouchStart: function(a) {
                1 === a.touches.length && (this.mouseXOnMouseDown = a.touches[0].pageX - this.windowHalfX, this.targetRotationOnMouseDownX = this.targetRotationX, this.mouseYOnMouseDown = a.touches[0].pageY - this.windowHalfY, this.targetRotationOnMouseDownY = this.targetRotationY)
            },
            onDocumentTouchMove: function(a) {
                1 === a.touches.length && (this.mouseX = a.touches[0].pageX - this.windowHalfX, this.targetRotationX = this.targetRotationOnMouseDownX + .005 * (this.mouseX - this.mouseXOnMouseDown), this.mouseY = a.touches[0].pageY - this.windowHalfY, this.targetRotationY = this.targetRotationOnMouseDownY + .005 * (this.mouseY - this.mouseYOnMouseDown))
            }
        }
    }(jQuery, window.Edge = window.Edge || {}),
    function(a, b) {
        b.Share = {
            settings: {
                shareAbsoluteState: "--absolute"
            },
            init: function() {
                this.dom(), this.events()
            },
            dom: function() {
                this.$hero = a(".hero"), this.$share = a(".share"), this.$window = a(window), this.scrollTimeout = null
            },
            events: function() {
                this.$window.scroll(a.proxy(this.scroll, this))
            },
            scroll: function() {
                this.scrollTimeout && (clearTimeout(this.scrollTimeout), this.scrollTimeout = null), this.scrollTimeout = setTimeout(a.proxy(this.scrollHandler, this))
            },
            scrollHandler: function() {
                this.$window.scrollTop() > this.$hero.height() ? this.$share.removeClass(this.settings.shareAbsoluteState) : this.$share.addClass(this.settings.shareAbsoluteState)
            }
        }
    }(jQuery, window.Edge = window.Edge || {}),
    function(a, b) {
        b.ShareableContent = {
            init: function() {
                this.dom(), this.addShare()
            },
            dom: function() {
                this.$el = a(".shareable-content")
            },
            events: function() {},
            addShare: function() {
                this.$el.each(function() {
                    var b = a(this).text(),
                        c = b.length > 83 ? "..." : "";
                    b = b.substr(0, 83).trim(), b = b + c + " via @EdgeThreeSixty " + window.location.href, b = encodeURIComponent(b), a(this).append('<a class="twitter-share-button social__link --twitter --shareable-content" href="https://twitter.com/intent/tweet?text=' + b + '" data-size="large" target="_blank"></a>')
                })
            }
        }
    }(jQuery, window.Edge = window.Edge || {}),
    function(a, b) {
        b.Site = {
            settings: {
                noScrollState: "--no-scroll"
            },
            init: function() {
                this.dom(), this.events()
            },
            dom: function() {
                this.$el = a(".site")
            },
            events: function() {
                a.subscribe({
                    "edge.navigationOpen.clicked": a.proxy(this.toggleNoScrollState, this),
                    "edge.navigationClose.clicked": a.proxy(this.toggleNoScrollState, this)
                })
            },
            toggleNoScrollState: function() {}
        }
    }(jQuery, window.Edge = window.Edge || {}),
    function(a, b) {
        b.TwoColumnsContent = {
            settings: {
                lazySettings: {
                    effect: "fadeIn",
                    effectTime: 1500,
                    visibleOnly: !0
                }
            },
            init: function() {
                this.dom(), this.$images.length && this.$images.lazy(this.settings.lazySettings)
            },
            dom: function() {
                this.$images = a(".two-columns-content__image")
            }
        }
    }(jQuery, window.Edge = window.Edge || {}),
    function(a, b) {
        b.Main = {
            common: {
                init: function() {
                    b.Site.init(), b.Header.init(), b.HeaderSearch.init(), b.Navigation.init(), b.NavigationOpen.init(), b.Form.init(), b.Alert.init(), b.ShareableContent.init(), b.Breadcrumbs.init()
                },
                finalize: function() {
                    a(".site").addClass("--loaded")
                }
            },
            page: {
                init: function() {
                    b.Hero.init(), b.TwoColumnsContent.init()
                }
            },
            home: {
                init: function() {
                    b.Shape.init(), b.FrontCaseStudy.init()
                }
            },
            single_post: {
                init: function() {
                    b.Hero.init(), b.Share.init()
                }
            },
            single_case_study: {
                init: function() {
                    b.CaseStudyTechnology.init(), b.CaseStudyHero.init(), b.CaseStudyBrief.init(), b.ProjectPlan.init(), b.CaseStudyResult.init(), b.CaseStudyArchitecture.init()
                }
            },
            contact_us: {
                init: function() {
                    b.Hero.init(), b.ContactMap.init()
                }
            },
            blog: {
                init: function() {
                    b.Hero.init()
                }
            },
            category: {
                init: function() {
                    b.Hero.init()
                }
            },
            tag: {
                init: function() {
                    b.Hero.init()
                }
            },
            post_type_archive_case_study: {
                init: function() {
                    b.Hero.init(), b.ArchiveCaseStudy.init()
                }
            },
            tax_case_study_technology: {
                init: function() {
                    b.Hero.init(), b.ArchiveCaseStudy.init()
                }
            },
            tax_case_study_client: {
                init: function() {
                    b.Hero.init(), b.ArchiveCaseStudy.init()
                }
            }
        }
    }(jQuery, window.Edge = window.Edge || {});